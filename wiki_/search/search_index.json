{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the Zinit WIKI # The goal is to complement the README.md and Z-Shell ZINIT Blog by easier way to approach, more intuitively organized. With the help of the MkDocs project-documentation tool) and also a more in-depth information. Notice: All documentation planned to be organized in one place in near future.","title":"Home"},{"location":"#this_is_the_zinit_wiki","text":"The goal is to complement the README.md and Z-Shell ZINIT Blog by easier way to approach, more intuitively organized. With the help of the MkDocs project-documentation tool) and also a more in-depth information. Notice: All documentation planned to be organized in one place in near future.","title":"This is the Zinit WIKI"},{"location":"Alternate-Ice-Syntax/","text":"Alternate Ice Syntax # The Standard Syntax # The normal way of specifying ices and their values is by concatenating the ice name and its value quoted, i.e.: zinit wait\"1\" from\"gh-r\" atload\"print Hello World\" zinit load \u2026 (note that there's no ice subcommand - that is currently being fully allowed) The Alternative Syntaxes # However, Zinit supports also other syntaxes: the equal ( = ) syntax: zinit wait=1 from=gh-r atload=\"print Hello World\" zinit load \u2026 the colon ( : ) syntax: zinit wait:1 from:gh-r atload:\"print Hello World\" zinit load \u2026 and also \u2013 with conjunction with all of the above \u2013 the GNU syntax: zinit --wait=1 --from=gh-r --atload=\"print Hello World\" zinit load \u2026 Summary # It's up to the user which syntax to choose. The original motivation behind the standard syntax was: to utilize the syntax highlighting of editors like Vim \u2013 and have the strings following ice names colorized with a distinct color and this way separated from them. However, with the zinit/zinit-vim-syntax syntax definition this motivation can be superseded with the Zinit-specific highlighting, at least for Vim. NOTE: the Vim syntax doesn't yet support the alternate syntaxes, it will soon (PR welcomed).","title":"Alternate Ice Syntax"},{"location":"Alternate-Ice-Syntax/#alternate_ice_syntax","text":"","title":"Alternate Ice Syntax"},{"location":"Alternate-Ice-Syntax/#the_standard_syntax","text":"The normal way of specifying ices and their values is by concatenating the ice name and its value quoted, i.e.: zinit wait\"1\" from\"gh-r\" atload\"print Hello World\" zinit load \u2026 (note that there's no ice subcommand - that is currently being fully allowed)","title":"The Standard Syntax"},{"location":"Alternate-Ice-Syntax/#the_alternative_syntaxes","text":"However, Zinit supports also other syntaxes: the equal ( = ) syntax: zinit wait=1 from=gh-r atload=\"print Hello World\" zinit load \u2026 the colon ( : ) syntax: zinit wait:1 from:gh-r atload:\"print Hello World\" zinit load \u2026 and also \u2013 with conjunction with all of the above \u2013 the GNU syntax: zinit --wait=1 --from=gh-r --atload=\"print Hello World\" zinit load \u2026","title":"The Alternative Syntaxes"},{"location":"Alternate-Ice-Syntax/#summary","text":"It's up to the user which syntax to choose. The original motivation behind the standard syntax was: to utilize the syntax highlighting of editors like Vim \u2013 and have the strings following ice names colorized with a distinct color and this way separated from them. However, with the zinit/zinit-vim-syntax syntax definition this motivation can be superseded with the Zinit-specific highlighting, at least for Vim. NOTE: the Vim syntax doesn't yet support the alternate syntaxes, it will soon (PR welcomed).","title":"Summary"},{"location":"Annexes/","text":"Annexes # What Are They? # They are Zinit Extensions . An annex is added to Zinit by simply loading it just as any other plugin. What Can They Do? # Add a new Zinit subcommand (i.e. the command that\u2019s placed after the function zinit \u2026 when calling Zinit). Add new ice-modifiers. Register four type of hooks: atclone hook \u2013 run after cloning any plugin or downloading any snippet. atpull hook \u2013 run after pulling new commits (i.e. updating) for any plugin / snippet. atinit hook \u2013 run before loading any plugin / snippet, after it has been set-up (i.e. downloaded). atload hook \u2013 run after loading any plugin / snippet. Register hooks for generating help text, shown by the zinit help subcommand. How To Code Them? # Below is an example body of an atclone hook (taken from zinit/z-a-submods annex). It shows how to: Obtain the arguments passed to the hook. Use an ice modifier. It also shows an useful snippet that will trim the whitespace in array elements (see # (4) \u2026 in the code). Utilize the last hook argument \u2013 the plugin\u2019s/snippet\u2019s containing directory. emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent [[ -z \"${ZINIT_ICE[submods]}\" ]] && return 0 # (1) \u2013 get arguments [[ \"$1\" = plugin ]] && \\ local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"$5\" hook=\"$6\" || \\ local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"$4\" hook=\"$6\" # type: snippet # (2) \u2013 we're interested only in plugins/snippets # which have the submods'' ice in their load command [[ -z ${ZINIT_ICE[submods]} ]] && return 0 local -a mods parts local mod # (3) \u2013 process the submods'' ice mods=( ${(@s.;.)ZINIT_ICE[submods]} ) for mod in \"${mods[@]}\"; do parts=( \"${(@s:->:)mod}\" ) # (4) Remove only leading and trailing whitespace parts=( \"${parts[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}\" ) print \"\\nCloning submodule: ${parts[1]} to dir: ${parts[2]}\" parts[1]=\"https://github.com/${parts[1]}\" # (5) \u2013 the use of the input argument: `$dir' command git -C \"$dir\" clone --progress \"${parts[1]}\" \"${parts[2]}\" done The recommended method of creating a hook is to place its body into a file that starts with a right arrow \u2192 ( more information , and also a za- prefix, e.g. \u2192za-myproject-atclone-hook and then to mark it for autoloading via autoload -Uz \u2192za-myproject-atclone-hook . Then register the hook (presumably in the myproject.plugin.zsh file) with the API call: @zinit-register-annex : @zinit-register-annex myproject hook:atclone \\ \u2192za-myproject-atclone-handler \\ \u2192za-myproject-atclone-help-handler \\ \"submods''\" # register a new ice-mod: submods'' The general syntax of the API call is: @zinit-register-annex {project-name} \\ {hook: \\ {name-of-the-handler-function} \\ {name-of-the-HELP-handler-function} \\ \"{ice-mod1}|{ice-mod2}|\u2026\" < hook-type >| subcommand: < new-subcommand-name > } The last argument, i.e. the | -separated ice-list, is optional. That\u2019s all! After this loading the plugin myproject will set up the new ice-mod submods that will have syntax submods'{user}/{plugin} \u2013> {output-dir}; \u2026' and will clone submodules when installing the original plugin or snippet! Example real-world use of the ice-mod: # Load the `zsh-autosuggestions' plugin via Prezto module: `autosuggestions' zinit ice svn submods'zsh-users/zsh-autosuggestions -> external' zinit snippet PZT::modules/autosuggestions Checkout the project which fully implements this idea, zinit/z-a-submods . It e.g. also implements the atpull hook, i.e. supports automatic update of the submodules. The z-a-* prefix is recommended for projects that are being annexes. Details # There are 2 or 3 subtypes for each of the hook: atinit or !atinit \u2013 the ! version is ran before the atinit ice-mod (i.e. before zinit ice atinit'echo this!'; \u2026 ), while the normal version runs after it. atload or !atload \u2013 analogous to the atinit case: the ! version runs before the atload ice-mod (while the normal version runs after it). atclone or !atclone \u2013 analogous to the atinit and atload cases. atpull , !atpull or %atpull \u2013 the first two are being ran only when there are new commits to be downloaded during the update. The % version is being always run, regardless if the update will pull any actual commits or not, and it is being ran after the atpull ice-mod .","title":"Annexes"},{"location":"Annexes/#annexes","text":"","title":"Annexes"},{"location":"Annexes/#what_are_they","text":"They are Zinit Extensions . An annex is added to Zinit by simply loading it just as any other plugin.","title":"What Are They?"},{"location":"Annexes/#what_can_they_do","text":"Add a new Zinit subcommand (i.e. the command that\u2019s placed after the function zinit \u2026 when calling Zinit). Add new ice-modifiers. Register four type of hooks: atclone hook \u2013 run after cloning any plugin or downloading any snippet. atpull hook \u2013 run after pulling new commits (i.e. updating) for any plugin / snippet. atinit hook \u2013 run before loading any plugin / snippet, after it has been set-up (i.e. downloaded). atload hook \u2013 run after loading any plugin / snippet. Register hooks for generating help text, shown by the zinit help subcommand.","title":"What Can They Do?"},{"location":"Annexes/#how_to_code_them","text":"Below is an example body of an atclone hook (taken from zinit/z-a-submods annex). It shows how to: Obtain the arguments passed to the hook. Use an ice modifier. It also shows an useful snippet that will trim the whitespace in array elements (see # (4) \u2026 in the code). Utilize the last hook argument \u2013 the plugin\u2019s/snippet\u2019s containing directory. emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent [[ -z \"${ZINIT_ICE[submods]}\" ]] && return 0 # (1) \u2013 get arguments [[ \"$1\" = plugin ]] && \\ local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"$5\" hook=\"$6\" || \\ local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"$4\" hook=\"$6\" # type: snippet # (2) \u2013 we're interested only in plugins/snippets # which have the submods'' ice in their load command [[ -z ${ZINIT_ICE[submods]} ]] && return 0 local -a mods parts local mod # (3) \u2013 process the submods'' ice mods=( ${(@s.;.)ZINIT_ICE[submods]} ) for mod in \"${mods[@]}\"; do parts=( \"${(@s:->:)mod}\" ) # (4) Remove only leading and trailing whitespace parts=( \"${parts[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}\" ) print \"\\nCloning submodule: ${parts[1]} to dir: ${parts[2]}\" parts[1]=\"https://github.com/${parts[1]}\" # (5) \u2013 the use of the input argument: `$dir' command git -C \"$dir\" clone --progress \"${parts[1]}\" \"${parts[2]}\" done The recommended method of creating a hook is to place its body into a file that starts with a right arrow \u2192 ( more information , and also a za- prefix, e.g. \u2192za-myproject-atclone-hook and then to mark it for autoloading via autoload -Uz \u2192za-myproject-atclone-hook . Then register the hook (presumably in the myproject.plugin.zsh file) with the API call: @zinit-register-annex : @zinit-register-annex myproject hook:atclone \\ \u2192za-myproject-atclone-handler \\ \u2192za-myproject-atclone-help-handler \\ \"submods''\" # register a new ice-mod: submods'' The general syntax of the API call is: @zinit-register-annex {project-name} \\ {hook: \\ {name-of-the-handler-function} \\ {name-of-the-HELP-handler-function} \\ \"{ice-mod1}|{ice-mod2}|\u2026\" < hook-type >| subcommand: < new-subcommand-name > } The last argument, i.e. the | -separated ice-list, is optional. That\u2019s all! After this loading the plugin myproject will set up the new ice-mod submods that will have syntax submods'{user}/{plugin} \u2013> {output-dir}; \u2026' and will clone submodules when installing the original plugin or snippet! Example real-world use of the ice-mod: # Load the `zsh-autosuggestions' plugin via Prezto module: `autosuggestions' zinit ice svn submods'zsh-users/zsh-autosuggestions -> external' zinit snippet PZT::modules/autosuggestions Checkout the project which fully implements this idea, zinit/z-a-submods . It e.g. also implements the atpull hook, i.e. supports automatic update of the submodules. The z-a-* prefix is recommended for projects that are being annexes.","title":"How To Code Them?"},{"location":"Annexes/#details","text":"There are 2 or 3 subtypes for each of the hook: atinit or !atinit \u2013 the ! version is ran before the atinit ice-mod (i.e. before zinit ice atinit'echo this!'; \u2026 ), while the normal version runs after it. atload or !atload \u2013 analogous to the atinit case: the ! version runs before the atload ice-mod (while the normal version runs after it). atclone or !atclone \u2013 analogous to the atinit and atload cases. atpull , !atpull or %atpull \u2013 the first two are being ran only when there are new commits to be downloaded during the update. The % version is being always run, regardless if the update will pull any actual commits or not, and it is being ran after the atpull ice-mod .","title":"Details"},{"location":"Bindkeys/","text":"Manage (remap) bindkeys with bindmap'' # Introduction # Sometimes plugins call bindkey to assign keyboard shortucts. This can cause problems, because multiple plugins can bind the same keys. Also, the user might want a different binding(s), which will require a complicated, additional bindkey commands in .zshrc . Zinit provides a solution to this problem \u2013 the ability to remap the bindkeys with a short ice-modifier specification with the bindmap'' ice. Examples # # Map Ctrl-G instead of Ctrl-R for the history searcher. zinit bindmap'^R -> ^G' for z-shell/history-search-multi-word # Map Ctrl-Shift-Left and \u2026-Right used by URxvt instead of the Xterms' ones. # # Load with the bindkey-tracking \u2194 with light-loading for anything else. # # Could also separate the bindmaps with a semicolon, i.e.: # bindmap'\"\\\\e[1\\;6D\" -> \\\\e[1\\;5D ; \"\\\\e[1\\;6C\" -> ^[[1\\;5C' \\ zinit wait light-mode trackbinds bindmap'\"\\\\e[1\\;6D\" -> \\\\e[1\\;5D\"' \\ bindmap'\"\\\\e[1\\;6C\" -> ^[[1\\;5C' pick'dircycle.zsh' for \\ michaelxmcbride/zsh-dircycle # Map space to regular space and Ctrl-Space to the `globalias' widget, which # expands the alias entered on the left (provided by OMZ globalias plugin). zinit bindmap='!\" \" -> magic-space; !\"^ \" -> globalias' nocompletions \\ depth=1 pick=plugins/globalias/globalias.plugin.zsh for \\ ohmyzsh/ohmyzsh Explanation # As it can be seen, the bindmap'' ice has two modes of operation: normal and exclamation-mark ( bindmap'!\u2026' ). In the first mode, the remapping is beind done from-key to-key, i.e.: bindmap'fromkey -> to-key' . In this mode, the given key is being changed to the second given key in the bindkey command that's being actually issued when loading the plugin. In the second mode, the remapping is being done from-key to-widget, i.e.: bindmap'!from-key -> to-widget' . In this mode, the given key is being mapped to the given widget instead of the widget specified in the bindkey command, i.e.: instead of: bindkey \"^ \" magic-space bindkey \" \" globalias the actual call that'll be done will be: bindkey \"^ \" globalias bindkey \" \" magic-space (for the bindmap='!\" \" -> magic-space; !\"^ \" -> globalias' ice). Using The UPAR , Etc. Shorthands # There are four special values that can be used on the left side of the bind-map: UPAR , DOWNAR , LEFTAR , RIGHTAR . They'll match up arrow, down arrow, etc. So that it's possible to do: zinit bindmap='LEFTAR -> ^F; RIGHTAR -> ^G' \u2026 The benefits of using the UPAR , \u2026 shorthands is that they cover multiple possible cursor-key codes for each of the cursor key, so that they'll work regardless of the terminal being used. Using bindmap'' In Light Mode # When the investigation mode is on \u2013 i.e.: when the full loading mode is being used (default in the for syntax and when zinit load \u2026 is used) \u2013 then the bindmap'' ice works normally. In the non-investigation, i.e.: the light mode \u2013 activated when zinit light \u2026 or the light-mode ice is being used \u2013 the bindmap'' is unavailable, unless the trackbinds ice is specified, i.e.: # With use of the light-mode ice and the for-syntax: zinit light-mode trackbinds bindmap'^R -> ^G' for z-shell/history-search-multi-word # With use of the classic syntax: zinit trackbinds bindmap'^R -> ^G' for z-shell/history-search-multi-word zinit light z-shell/history-search-multi-word","title":"Remapping Bindkeys"},{"location":"Bindkeys/#manage_remap_bindkeys_with_bindmap","text":"","title":"Manage (remap) bindkeys with bindmap''"},{"location":"Bindkeys/#introduction","text":"Sometimes plugins call bindkey to assign keyboard shortucts. This can cause problems, because multiple plugins can bind the same keys. Also, the user might want a different binding(s), which will require a complicated, additional bindkey commands in .zshrc . Zinit provides a solution to this problem \u2013 the ability to remap the bindkeys with a short ice-modifier specification with the bindmap'' ice.","title":"Introduction"},{"location":"Bindkeys/#examples","text":"# Map Ctrl-G instead of Ctrl-R for the history searcher. zinit bindmap'^R -> ^G' for z-shell/history-search-multi-word # Map Ctrl-Shift-Left and \u2026-Right used by URxvt instead of the Xterms' ones. # # Load with the bindkey-tracking \u2194 with light-loading for anything else. # # Could also separate the bindmaps with a semicolon, i.e.: # bindmap'\"\\\\e[1\\;6D\" -> \\\\e[1\\;5D ; \"\\\\e[1\\;6C\" -> ^[[1\\;5C' \\ zinit wait light-mode trackbinds bindmap'\"\\\\e[1\\;6D\" -> \\\\e[1\\;5D\"' \\ bindmap'\"\\\\e[1\\;6C\" -> ^[[1\\;5C' pick'dircycle.zsh' for \\ michaelxmcbride/zsh-dircycle # Map space to regular space and Ctrl-Space to the `globalias' widget, which # expands the alias entered on the left (provided by OMZ globalias plugin). zinit bindmap='!\" \" -> magic-space; !\"^ \" -> globalias' nocompletions \\ depth=1 pick=plugins/globalias/globalias.plugin.zsh for \\ ohmyzsh/ohmyzsh","title":"Examples"},{"location":"Bindkeys/#explanation","text":"As it can be seen, the bindmap'' ice has two modes of operation: normal and exclamation-mark ( bindmap'!\u2026' ). In the first mode, the remapping is beind done from-key to-key, i.e.: bindmap'fromkey -> to-key' . In this mode, the given key is being changed to the second given key in the bindkey command that's being actually issued when loading the plugin. In the second mode, the remapping is being done from-key to-widget, i.e.: bindmap'!from-key -> to-widget' . In this mode, the given key is being mapped to the given widget instead of the widget specified in the bindkey command, i.e.: instead of: bindkey \"^ \" magic-space bindkey \" \" globalias the actual call that'll be done will be: bindkey \"^ \" globalias bindkey \" \" magic-space (for the bindmap='!\" \" -> magic-space; !\"^ \" -> globalias' ice).","title":"Explanation"},{"location":"Bindkeys/#using_the_upar_etc_shorthands","text":"There are four special values that can be used on the left side of the bind-map: UPAR , DOWNAR , LEFTAR , RIGHTAR . They'll match up arrow, down arrow, etc. So that it's possible to do: zinit bindmap='LEFTAR -> ^F; RIGHTAR -> ^G' \u2026 The benefits of using the UPAR , \u2026 shorthands is that they cover multiple possible cursor-key codes for each of the cursor key, so that they'll work regardless of the terminal being used.","title":"Using The UPAR, Etc. Shorthands"},{"location":"Bindkeys/#using_bindmap_in_light_mode","text":"When the investigation mode is on \u2013 i.e.: when the full loading mode is being used (default in the for syntax and when zinit load \u2026 is used) \u2013 then the bindmap'' ice works normally. In the non-investigation, i.e.: the light mode \u2013 activated when zinit light \u2026 or the light-mode ice is being used \u2013 the bindmap'' is unavailable, unless the trackbinds ice is specified, i.e.: # With use of the light-mode ice and the for-syntax: zinit light-mode trackbinds bindmap'^R -> ^G' for z-shell/history-search-multi-word # With use of the classic syntax: zinit trackbinds bindmap'^R -> ^G' for z-shell/history-search-multi-word zinit light z-shell/history-search-multi-word","title":"Using bindmap'' In Light Mode"},{"location":"Code-Documentation/","text":"Code documentation # Here is code documentation generated using Zshelldoc . There are 4 Zinit's source files, the main one is zinit.zsh. The documentation lists all functions, interactions between them, their comments and features used. zinit.zsh \u2013 always loaded, in .zshrc ( pdf ) zinit-side.zsh \u2013 common functions, loaded by *-install and *-autoload scripts ( pdf ) zinit-install.zsh \u2013 functions used only when installing a plugin or snippet ( pdf ) zinit-autoload.zsh \u2013 functions used only in interactive Zinit invocations ( pdf )","title":"Overview"},{"location":"Code-Documentation/#code_documentation","text":"Here is code documentation generated using Zshelldoc . There are 4 Zinit's source files, the main one is zinit.zsh. The documentation lists all functions, interactions between them, their comments and features used. zinit.zsh \u2013 always loaded, in .zshrc ( pdf ) zinit-side.zsh \u2013 common functions, loaded by *-install and *-autoload scripts ( pdf ) zinit-install.zsh \u2013 functions used only when installing a plugin or snippet ( pdf ) zinit-autoload.zsh \u2013 functions used only in interactive Zinit invocations ( pdf )","title":"Code documentation"},{"location":"Compiling-programs/","text":"zinit ice as\"program\" atclone\"rm -f src/auto/config.cache; ./configure\" \\ atpull\"%atclone\" make pick\"src/vim\" zinit light vim/vim as\"program\" \u2013 add file selected by pick'' to $PATH , do not source it, atclone\"\u2026\" \u2013 execute code after downloading, atpull\"%atclone\" \u2013 execute the same code atclone'' is given, but after successful update, make \u2013 run make after atclone'' and atpull'' (note: make'!' will execute before them), pick\"src/vim\" \u2013 set executable flag on src/vim , hint that src/ should be added to $PATH . The same but with installation (i.e. make install is being run) under $ZPFX ( ~/.zinit/polaris by default): zinit ice as\"program\" atclone\"rm -f src/auto/config.cache; \\ ./configure --prefix=$ZPFX\" atpull\"%atclone\" \\ make\"all install\" pick\"$ZPFX/bin/vim\" zinit light vim/vim as\"program\" \u2013 as above, atclone\"\u2026\" \u2013 as above plus pass --prefix=$ZPFX to ./configure , to set the installation directory, atpull\"%atclone\" \u2013 as above, make \u2013 as above, but also run the install target, pick\"src/vim\" \u2013 as above, but for different path ( $ZPFX/bin/vim ). zinit ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' src\"zhook.zsh\" zinit light direnv/direnv make'!' \u2013 execute make before atclone'' and before atpull'' (see make above), src\"zhook.zsh\" \u2013 source file zhook.zsh . In general, Direnv works by hooking up to Zsh. The code that does this is provided by program direnv (built by make'' ). Above atclone'' puts this code into file zhook.zsh , src'' sources it. This way direnv hook zsh is executed only on clone and update, and Zsh starts faster.","title":"Compiling Programs"},{"location":"Direnv-explanation/","text":"The project direnv/direnv registers itself in Zshell to modify environment on directory change. This registration is most often done by eval \"$(direnv hook zsh)\" added to zshrc. Drawback of this standard procedure is that direnv binary is ran on every shell startup and significantly slows it down. Zinit allows to solve this in following way: zinit as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' pick\"direnv\" src\"zhook.zsh\" for \\ direnv/direnv make'!' \u2013 compile direnv (it's written in Go lang); the exclamation mark means: run the make first, before atclone and atpull hooks, atclone'\u2026' \u2013 initially (right after installing the plugin) generate the registration code and save it to zhook.zsh (instead of passing to eval ), atpull'%atclone' \u2013 regenerate the registration code also on update ( atclone'' runs on installation while atpull runs on update of the plugin), src\"zhook.zsh\" \u2013 load ( source ) the generated registration code, pick\"direnv\" \u2013 ensure +x permission on the binary, as\"program\" \u2013 the plugin is a program, there's no main file to source. This way registration code is generated once every installation and update, to then be simply sourced without running direnv . The project is also available as binary Github release. This distribution can be installed by: zinit from\"gh-r\" as\"program\" mv\"direnv* -> direnv\" \\ atclone'./direnv hook zsh > zhook.zsh' atpull'%atclone' \\ pick\"direnv\" src=\"zhook.zsh\" for \\ direnv/direnv from\"gh-r\" \u2013 install from Github releases , mv\"\u2026\" \u2013 after installation, rename direnv.linux-386 or similar file to direnv , atclone'\u2026' , atpull'\u2026' \u2013 as in previous example, pick\"direnv\" \u2013 as in previous example, as\"program\" \u2013 as in previous example.","title":"Direnv Explanation"},{"location":"Example-Minimal-Setup/","text":"Example Minimal Setup # zinit wait lucid light-mode for \\ atinit\"zicompinit; zicdreplay\" \\ z-shell/fast-syntax-highlighting \\ atload\"_zsh_autosuggest_start\" \\ zsh-users/zsh-autosuggestions \\ blockf atpull'zinit creinstall -q .' \\ zsh-users/zsh-completions wait \u2013 load 0 seconds (about 5 ms exactly) after prompt ( Turbo mode ), lucid \u2013 silence the under-prompt messages (\" Loaded {name of the plugin} \"), light-mode \u2013 load the plugin in light mode, in which the tracking of plugin (i.e. activity report gathering, accessible via the zinit report {plugin-spec} subcommand) is being disabled; note that for Turbo mode, the performance gains are almost 0 , so in this mode you can load all plugins with the tracking, i.e.: the light-mode ice can be removed from the command, atpull'' \u2013 execute after updating the plugin \u2013 the command in the ice will install any new completions, atinit'' \u2013 execute code before loading plugin, atload'' \u2013 execute code after loading plugin, zicompinit \u2013 equals to autoload compinit; compinit , zicdreplay \u2013 execute compdef \u2026 calls that plugins did \u2013 they were recorded, so that compinit can be called later ( compinit provides the compdef function, so it must be ran before issuing the taken-over compdef s with zicdreplay ), syntax-highlighting plugins (like fast-syntax-highlighting or zsh-syntax-highlighting ) theoretically expect to be loaded last, even after the completion initialization (i.e. compinit function), however, in practice, you just have to ensure that such plugin is loaded after plugins that are issuing compdef s \u2013 which basically means completions that aren't using the underscore-starting function file; the completion initialization still has to be performed before syntax-highlighting plugin, hence the atinit'' ice, which will load compinit right before loading the plugin, the syntax-highlighting and suggestions plugins are loaded early for a better user experience. The same setup but without using Turbo mode (i.e. no wait'' ice) and without the for-syntax : zinit ice blockf atpull'zinit creinstall -q .' zinit light zsh-users/zsh-completions autoload compinit compinit zinit light z-shell/fast-syntax-highlighting zinit light zsh-users/zsh-autosuggestions Without Turbo the syntax-highlighting plugin can be loaded at the end, as it doesn't make any difference (the prompt will appear after loading all objects, anyway).","title":"Example Minimal Setup"},{"location":"Example-Minimal-Setup/#example_minimal_setup","text":"zinit wait lucid light-mode for \\ atinit\"zicompinit; zicdreplay\" \\ z-shell/fast-syntax-highlighting \\ atload\"_zsh_autosuggest_start\" \\ zsh-users/zsh-autosuggestions \\ blockf atpull'zinit creinstall -q .' \\ zsh-users/zsh-completions wait \u2013 load 0 seconds (about 5 ms exactly) after prompt ( Turbo mode ), lucid \u2013 silence the under-prompt messages (\" Loaded {name of the plugin} \"), light-mode \u2013 load the plugin in light mode, in which the tracking of plugin (i.e. activity report gathering, accessible via the zinit report {plugin-spec} subcommand) is being disabled; note that for Turbo mode, the performance gains are almost 0 , so in this mode you can load all plugins with the tracking, i.e.: the light-mode ice can be removed from the command, atpull'' \u2013 execute after updating the plugin \u2013 the command in the ice will install any new completions, atinit'' \u2013 execute code before loading plugin, atload'' \u2013 execute code after loading plugin, zicompinit \u2013 equals to autoload compinit; compinit , zicdreplay \u2013 execute compdef \u2026 calls that plugins did \u2013 they were recorded, so that compinit can be called later ( compinit provides the compdef function, so it must be ran before issuing the taken-over compdef s with zicdreplay ), syntax-highlighting plugins (like fast-syntax-highlighting or zsh-syntax-highlighting ) theoretically expect to be loaded last, even after the completion initialization (i.e. compinit function), however, in practice, you just have to ensure that such plugin is loaded after plugins that are issuing compdef s \u2013 which basically means completions that aren't using the underscore-starting function file; the completion initialization still has to be performed before syntax-highlighting plugin, hence the atinit'' ice, which will load compinit right before loading the plugin, the syntax-highlighting and suggestions plugins are loaded early for a better user experience. The same setup but without using Turbo mode (i.e. no wait'' ice) and without the for-syntax : zinit ice blockf atpull'zinit creinstall -q .' zinit light zsh-users/zsh-completions autoload compinit compinit zinit light z-shell/fast-syntax-highlighting zinit light zsh-users/zsh-autosuggestions Without Turbo the syntax-highlighting plugin can be loaded at the end, as it doesn't make any difference (the prompt will appear after loading all objects, anyway).","title":"Example Minimal Setup"},{"location":"Example-Oh-My-Zsh-setup/","text":"Using Turbo mode and for-syntax # # A. setopt promptsubst # B. zinit wait lucid for \\ OMZL::git.zsh \\ atload\"unalias grv\" \\ OMZP::git PS1=\"READY >\" # provide a simple prompt till the theme loads # C. zinit wait'!' lucid for \\ OMZL::prompt_info_functions.zsh \\ OMZT::gnzh # D. zinit wait lucid for \\ atinit\"zicompinit; zicdreplay\" \\ z-shell/fast-syntax-highlighting \\ OMZP::colored-man-pages \\ as\"completion\" \\ OMZP::docker/_docker A - Most themes use this option. B - OMZ themes use this library and some other use also the plugin. It provides many aliases \u2013 atload'' shows how to disable some of them (e.g.: to use program rgburke/grv ). C - Set OMZ theme. Loaded separately because the theme needs the ! passed to the wait ice to reset the prompt after loading the snippet in Turbo. D - Some plugins: a) syntax-highlighting, loaded possibly early for a better user experience), b) example functional plugin, c) Docker completion. Above setup loads everything after prompt, because of preceding wait ice. That is called Turbo mode , it shortens Zsh startup time by 50%-80% , so e.g. instead of 200 ms, it'll be getting your shell started up after 40 ms (!). It is using the for-syntax, which is a recent addition to Zinit and it's described in detail on this page . Without using Turbo and for-syntax # The same setup using the classic syntax and without Turbo mode (prompt will be initially set like in typical, normal setup \u2013 you can remove wait only from the theme plugin and its dependencies to have the same effect while still using Turbo for everything remaining): # A. setopt promptsubst # B. zinit snippet OMZL::git.zsh # C. zinit ice atload\"unalias grv\" zinit snippet OMZP::git # D. zinit for OMZL::prompt_info_functions.zsh OMZT::gnzh # E. zinit snippet OMZP::colored-man-pages # F. zinit ice as\"completion\" zinit snippet OMZP::docker/_docker # G. zinit ice atinit\"zicompinit; zicdreplay\" zinit light z-shell/fast-syntax-highlighting In general, Turbo can be optionally enabled only for a subset of plugins or for all plugins. It needs Zsh >= 5.3. The Introduction contains more information on Turbo.","title":"Example Oh My Zsh Setup"},{"location":"Example-Oh-My-Zsh-setup/#using_turbo_mode_and_for-syntax","text":"# A. setopt promptsubst # B. zinit wait lucid for \\ OMZL::git.zsh \\ atload\"unalias grv\" \\ OMZP::git PS1=\"READY >\" # provide a simple prompt till the theme loads # C. zinit wait'!' lucid for \\ OMZL::prompt_info_functions.zsh \\ OMZT::gnzh # D. zinit wait lucid for \\ atinit\"zicompinit; zicdreplay\" \\ z-shell/fast-syntax-highlighting \\ OMZP::colored-man-pages \\ as\"completion\" \\ OMZP::docker/_docker A - Most themes use this option. B - OMZ themes use this library and some other use also the plugin. It provides many aliases \u2013 atload'' shows how to disable some of them (e.g.: to use program rgburke/grv ). C - Set OMZ theme. Loaded separately because the theme needs the ! passed to the wait ice to reset the prompt after loading the snippet in Turbo. D - Some plugins: a) syntax-highlighting, loaded possibly early for a better user experience), b) example functional plugin, c) Docker completion. Above setup loads everything after prompt, because of preceding wait ice. That is called Turbo mode , it shortens Zsh startup time by 50%-80% , so e.g. instead of 200 ms, it'll be getting your shell started up after 40 ms (!). It is using the for-syntax, which is a recent addition to Zinit and it's described in detail on this page .","title":"Using Turbo mode and for-syntax"},{"location":"Example-Oh-My-Zsh-setup/#without_using_turbo_and_for-syntax","text":"The same setup using the classic syntax and without Turbo mode (prompt will be initially set like in typical, normal setup \u2013 you can remove wait only from the theme plugin and its dependencies to have the same effect while still using Turbo for everything remaining): # A. setopt promptsubst # B. zinit snippet OMZL::git.zsh # C. zinit ice atload\"unalias grv\" zinit snippet OMZP::git # D. zinit for OMZL::prompt_info_functions.zsh OMZT::gnzh # E. zinit snippet OMZP::colored-man-pages # F. zinit ice as\"completion\" zinit snippet OMZP::docker/_docker # G. zinit ice atinit\"zicompinit; zicdreplay\" zinit light z-shell/fast-syntax-highlighting In general, Turbo can be optionally enabled only for a subset of plugins or for all plugins. It needs Zsh >= 5.3. The Introduction contains more information on Turbo.","title":"Without using Turbo and for-syntax"},{"location":"Example-wait-conditions/","text":"Note Turbo mode, i.e. the wait ice that implements it needs Zsh >= 5.3. zinit ice wait'0' # or just: zinit ice wait zinit light wfxr/forgit waits for prompt, instantly (\"0\" seconds) after prompt loads given plugin. zinit ice wait'[[ -n ${ZLAST_COMMANDS[(r)cras*]} ]]' zinit light z-shell/zinit-crasis $ZLAST_COMMANDS is an array build by fast-syntax-highlighting , it contains commands currently entered at prompt, (r) searches for element that matches given pattern ( cras* ) and returns it, -n means: not-empty, so it will be true when users enters \"cras\", after 1 second or less, Zinit will detect that wait'' condition is true, and load the plugin, which provides command crasis , Screencast that presents the feature: zinit ice wait'[[ $PWD = */github || $PWD = */github/* ]]' zinit load unixorn/git-extra-commands waits until user enters a github directory. Turbo mode also support a suffix \u2013 the letter a , b or c . The meaning is illustrated by the following example: zinit ice wait\"0b\" as\"command\" pick\"wd.sh\" atinit\"echo Firing 1\" lucid zinit light mfaerevaag/wd zinit ice wait\"0a\" as\"command\" pick\"wd.sh\" atinit\"echo Firing 2\" lucid zinit light mfaerevaag/wd # The output Firing 2 Firing 1 As it can be seen, the second plugin has been loaded first. That's because there are now three sub-slots (the a , b and c ) in which the plugin/snippet loadings can be put into. Plugins from the same time-slot with suffix a will be loaded before plugins with suffix b , etc. In other words, instead of wait'1' you can enter wait'1a' , wait'1b' and wait'1c' \u2013 to this way impose order on the loadings regardless of the order of zinit commands .","title":"Example wait Conditions"},{"location":"For-Syntax/","text":"The For-Syntax # Introduction # The Introduction covers the classic Zinit invocation syntax, which is: zinit ice \u2026 zinit load \u2026 # or zinit light, zinit snippet It is a fundamental Zinit syntax. However, a more concise, optimized syntax, called for-syntax , is also available. It is best presented by a real-world example: zinit as\"null\" wait\"3\" lucid for \\ sbin Fakerr/git-recall \\ sbin paulirish/git-open \\ sbin paulirish/git-recent \\ sbin davidosomething/git-my \\ make\"PREFIX=$ZPFX install\" iwata/git-now \\ make\"PREFIX=$ZPFX\" tj/git-extras Above single command installs 6 plugins (Git extension-packages), with the base ices as\"null\" wait\"3\" lucid that are common to all of the plugins and 6 plugin-specific add-on ices. A Few Remarks # The syntax automatically detects if the object is a snippet or a plugin, by checking if the object is an URL, i.e.: if it starts with http*:// or OMZ:: , etc. To load a local-file snippet (which will be treaten as a local-directory plugin by default) use the is-snippet ice, To load a plugin in light mode use the light-mode ice. If the plugin name collides with an ice name, precede the plugin name with @ , e.g.: @sharkdp/fd (collides with the sh ice, Zinit will take the plugin name as sh\"arkdp/fd\" ), see the next section for an example. Examples # Load a few useful binary (i.e.: binary packages from the GitHub Releases) utils: zinit as\"null\" wait\"2\" lucid from\"gh-r\" for \\ mv\"exa* -> exa\" sbin ogham/exa \\ mv\"fd* -> fd\" sbin\"fd/fd\" @sharkdp/fd \\ sbin\"fzf\" junegunn/fzf-bin Note: sbin'' is an ice added by the z-a-bin-gem-node annex, it provides the command to the command line without altering $PATH . If the name of the command is the same as the name of the plugin, the ice contents can be skipped. Turbo load some plugins, without any plugin-specific ices: zinit wait lucid for \\ hlissner/zsh-autopair \\ urbainvaes/fzf-marks Load two Oh My Zsh files as snippets, in Turbo: zinit wait lucid for \\ OMZ::lib/git.zsh \\ atload\"unalias grv\" OMZ::plugins/git/git.plugin.zsh","title":"The For Syntax"},{"location":"For-Syntax/#the_for-syntax","text":"","title":"The For-Syntax"},{"location":"For-Syntax/#introduction","text":"The Introduction covers the classic Zinit invocation syntax, which is: zinit ice \u2026 zinit load \u2026 # or zinit light, zinit snippet It is a fundamental Zinit syntax. However, a more concise, optimized syntax, called for-syntax , is also available. It is best presented by a real-world example: zinit as\"null\" wait\"3\" lucid for \\ sbin Fakerr/git-recall \\ sbin paulirish/git-open \\ sbin paulirish/git-recent \\ sbin davidosomething/git-my \\ make\"PREFIX=$ZPFX install\" iwata/git-now \\ make\"PREFIX=$ZPFX\" tj/git-extras Above single command installs 6 plugins (Git extension-packages), with the base ices as\"null\" wait\"3\" lucid that are common to all of the plugins and 6 plugin-specific add-on ices.","title":"Introduction"},{"location":"For-Syntax/#a_few_remarks","text":"The syntax automatically detects if the object is a snippet or a plugin, by checking if the object is an URL, i.e.: if it starts with http*:// or OMZ:: , etc. To load a local-file snippet (which will be treaten as a local-directory plugin by default) use the is-snippet ice, To load a plugin in light mode use the light-mode ice. If the plugin name collides with an ice name, precede the plugin name with @ , e.g.: @sharkdp/fd (collides with the sh ice, Zinit will take the plugin name as sh\"arkdp/fd\" ), see the next section for an example.","title":"A Few Remarks"},{"location":"For-Syntax/#examples","text":"Load a few useful binary (i.e.: binary packages from the GitHub Releases) utils: zinit as\"null\" wait\"2\" lucid from\"gh-r\" for \\ mv\"exa* -> exa\" sbin ogham/exa \\ mv\"fd* -> fd\" sbin\"fd/fd\" @sharkdp/fd \\ sbin\"fzf\" junegunn/fzf-bin Note: sbin'' is an ice added by the z-a-bin-gem-node annex, it provides the command to the command line without altering $PATH . If the name of the command is the same as the name of the plugin, the ice contents can be skipped. Turbo load some plugins, without any plugin-specific ices: zinit wait lucid for \\ hlissner/zsh-autopair \\ urbainvaes/fzf-marks Load two Oh My Zsh files as snippets, in Turbo: zinit wait lucid for \\ OMZ::lib/git.zsh \\ atload\"unalias grv\" OMZ::plugins/git/git.plugin.zsh","title":"Examples"},{"location":"GALLERY/","text":"Gallery Of Zinit Invocations # PRs welcomed :) Programs # # junegunn/fzf-bin zinit ice from\"gh-r\" as\"program\" zinit light junegunn/fzf-bin # sharkdp/fd zinit ice as\"command\" from\"gh-r\" mv\"fd* -> fd\" pick\"fd/fd\" zinit light sharkdp/fd # sharkdp/bat zinit ice as\"command\" from\"gh-r\" mv\"bat* -> bat\" pick\"bat/bat\" zinit light sharkdp/bat # ogham/exa, replacement for ls zinit ice wait\"2\" lucid from\"gh-r\" as\"program\" mv\"exa* -> exa\" zinit light ogham/exa # All of the above using the for-syntax and also z-a-bin-gem-node annex zinit wait\"1\" lucid from\"gh-r\" as\"null\" for \\ sbin\"fzf\" junegunn/fzf-bin \\ sbin\"**/fd\" @sharkdp/fd \\ sbin\"**/bat\" @sharkdp/bat \\ sbin\"exa* -> exa\" ogham/exa zinit ice from\"gh-r\" as\"program\" mv\"docker* -> docker-compose\" zinit light docker/compose # jarun/nnn, a file browser, using the for-syntax zinit pick\"misc/quitcd/quitcd.zsh\" sbin make light-mode for jarun/nnn zinit ice as\"program\" atclone\"rm -f src/auto/config.cache; ./configure\" \\ atpull\"%atclone\" make pick\"src/vim\" zinit light vim/vim zinit ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' src\"zhook.zsh\" zinit light direnv/direnv zinit ice from\"gh-r\" as\"program\" mv\"direnv* -> direnv\" zinit light direnv/direnv zinit ice from\"gh-r\" as\"program\" mv\"shfmt* -> shfmt\" zinit light mvdan/sh zinit ice from\"gh-r\" as\"program\" mv\"gotcha_* -> gotcha\" zinit light b4b4r07/gotcha zinit ice as\"program\" pick\"yank\" make zinit light mptre/yank zinit ice atclone'PYENV_ROOT=\"$PWD\" ./libexec/pyenv init - > zpyenv.zsh' \\ atinit'export PYENV_ROOT=\"$PWD\"' atpull\"%atclone\" \\ as'command' pick'bin/pyenv' src\"zpyenv.zsh\" nocompile'!' zinit light pyenv/pyenv zinit ice as\"program\" pick\"$ZPFX/sdkman/bin/sdk\" id-as'sdkman' run-atpull \\ atclone\"wget https://get.sdkman.io/?rcupdate=false -O scr.sh; SDKMAN_DIR=$ZPFX/sdkman bash scr.sh\" \\ atpull\"SDKMAN_DIR=$ZPFX/sdkman sdk selfupdate\" \\ atinit\"export SDKMAN_DIR=$ZPFX/sdkman; source $ZPFX/sdkman/bin/sdkman-init.sh\" zinit light z-shell/null # asciinema zinit ice as\"command\" wait lucid \\ atinit\"export PYTHONPATH=$ZPFX/lib/python3.7/site-packages/\" \\ atclone\"PYTHONPATH=$ZPFX/lib/python3.7/site-packages/ \\ python3 setup.py --quiet install --prefix $ZPFX\" \\ atpull'%atclone' test'0' \\ pick\"$ZPFX/bin/asciinema\" zinit load asciinema/asciinema.git # Installation of Rust compiler environment via the z-a-rust annex zinit id-as\"rust\" wait=1 as=null sbin=\"bin/*\" lucid rustup \\ atload=\"[[ ! -f ${ZINIT[COMPLETIONS_DIR]}/_cargo ]] && zi creinstall -q rust; \\ export CARGO_HOME=\\$PWD; export RUSTUP_HOME=\\$PWD/rustup\" for \\ z-shell/null Completions # zinit ice as\"completion\" zinit snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker Scripts # # ogham/exa also uses the definitions zinit ice wait\"0c\" lucid reset \\ atclone\"local P=${${(M)OSTYPE:#*darwin*}:+g} \\${P}sed -i \\ '/DIR/c\\DIR 38;5;63;1' LS_COLORS; \\ \\${P}dircolors -b LS_COLORS > c.zsh\" \\ atpull'%atclone' pick\"c.zsh\" nocompile'!' \\ atload'zstyle \":completion:*\" list-colors \u201c${(s.:.)LS_COLORS}\u201d' zinit light trapd00r/LS_COLORS # revolver zinit ice wait\"2\" lucid as\"program\" pick\"revolver\" zinit light molovo/revolver # zunit zinit ice wait\"2\" lucid as\"program\" pick\"zunit\" \\ atclone\"./build.zsh\" atpull\"%atclone\" zinit load molovo/zunit zinit ice as\"program\" pick\"$ZPFX/bin/git-*\" make\"PREFIX=$ZPFX\" nocompile zinit light tj/git-extras zinit ice as\"program\" atclone'perl Makefile.PL PREFIX=$ZPFX' \\ atpull'%atclone' make'install' pick\"$ZPFX/bin/git-cal\" zinit light k4rthik/git-cal zinit ice as\"program\" id-as\"git-unique\" pick\"git-unique\" zinit snippet https://github.com/Osse/git-scripts/blob/master/git-unique zinit ice as\"program\" cp\"wd.sh -> wd\" mv\"_wd.sh -> _wd\" \\ atpull'!git reset --hard' pick\"wd\" zinit light mfaerevaag/wd zinit ice as\"program\" pick\"bin/archey\" zinit load obihann/archey-osx Plugins # zinit ice pick\"h.sh\" zinit light paoloantinori/hhighlighter # zsh-tag-search; after ^G, prepend with \"/\" for the regular search zinit ice wait lucid bindmap\"^R -> ^G\" zinit light -b z-shell/zsh-tag-search # forgit zinit ice wait lucid zinit load 'wfxr/forgit' # diff-so-fancy zinit ice wait\"2\" lucid as\"program\" pick\"bin/git-dsf\" zinit load z-shell/zsh-diff-so-fancy # zsh-startify, a vim-startify like plugin zinit ice wait\"0b\" lucid atload\"zsh-startify\" zinit load z-shell/zsh-startify # declare-zsh zinit ice wait\"2\" lucid zinit load z-shell/declare-zsh # fzf-marks zinit ice wait lucid zinit load urbainvaes/fzf-marks # zsh-autopair zinit ice wait lucid zinit load hlissner/zsh-autopair zinit ice wait\"1\" lucid zinit load z-shell/zsh-navigation-tools # z-shell/history-search-multi-word zstyle \":history-search-multi-word\" page-size \"11\" zinit ice wait\"1\" lucid zinit load z-shell/history-search-multi-word # ZUI and Crasis zinit ice wait\"1\" lucid zinit load z-shell/zui zinit ice wait'[[ -n ${ZLAST_COMMANDS[(r)cra*]} ]]' lucid zinit load z-shell/zinit-crasis # Gitignore plugin \u2013 commands gii and gi zinit ice wait\"2\" lucid zinit load voronkovich/gitignore.plugin.zsh # Autosuggestions & fast-syntax-highlighting zinit ice wait lucid atinit\"ZPLGM[COMPINIT_OPTS]=-C; zpcompinit; zpcdreplay\" zinit light z-shell/fast-syntax-highlighting # zsh-autosuggestions zinit ice wait lucid atload\"!_zsh_autosuggest_start\" zinit load zsh-users/zsh-autosuggestions # F-Sy-H automatic per-directory themes plugin \u2013 available for patrons: # https://patreon.com/psprint zinit ice wait\"1\" lucid from\"psprint@gitlab.com\" zinit load psprint/fsh-auto-themes # zredis together with some binding/tying # \u2013 defines the variable $rdhash zstyle \":plugin:zredis\" configure_opts \"--without-tcsetpgrp\" zstyle \":plugin:zredis\" cflags \"-Wall -O2 -g -Wno-unused-but-set-variable\" zinit ice wait\"1\" lucid \\ atload'ztie -d db/redis -a 127.0.0.1:4815/5 -zSL main rdhash' zinit load z-shell/zredis # Github-Issue-Tracker \u2013 the notifier thread zinit ice lucid id-as\"GitHub-notify\" \\ on-update-of'~/.cache/zsh-github-issues/new_titles.log' \\ notify'New issue: $NOTIFY_MESSAGE' zinit light z-shell/zsh-github-issues Services # # a service that runs the redis database, in background, single instance zinit ice wait\"1\" lucid service\"redis\" zinit light zservices/redis # Github-Issue-Tracker \u2013 the issue-puller thread GIT_SLEEP_TIME=700 GIT_PROJECTS=z-shell/zsh-github-issues:z-shell/zinit zinit ice wait\"2\" lucid service\"GIT\" pick\"zsh-github-issues.service.zsh\" zinit light z-shell/zsh-github-issues Snippets # zinit ice svn pick\"completion.zsh\" src\"git.zsh\" zinit snippet OMZ::lib zinit ice svn wait\"0\" lucid atinit\"local ZSH=\\$PWD\" \\ atclone\"mkdir -p plugins; cd plugins; ln -sfn ../. osx\" zinit snippet OMZ::plugins/osx # Or with most recent Zinit and with ~/.zinit/snippets # directory pruned (rm -rf -- ${ZPLGM[SNIPPETS_DIR]}): zinit ice svn zinit snippet OMZ::plugins/osx Themes # GEOMETRY_COLOR_DIR=152 zinit ice wait\"0\" lucid atload\"geometry::prompt\" zinit light geometry-zsh/geometry zinit ice pick\"async.zsh\" src\"pure.zsh\" zinit light sindresorhus/pure zinit light mafredri/zsh-async # dependency zinit ice svn silent atload'prompt sorin' zinit snippet PZT::modules/prompt zinit ice atload\"fpath+=( \\$PWD );\" zinit light chauncey-garrett/zsh-prompt-garrett zinit ice svn atload\"prompt garrett\" silent zinit snippet PZT::modules/prompt zinit ice wait'!' lucid nocompletions \\ compile\"{zinc_functions/*,segments/*,zinc.zsh}\" \\ atload'!prompt_zinc_setup; prompt_zinc_precmd' zinit load robobenklein/zinc # ZINC git info is already async, but if you want it # even faster with gitstatus in Turbo mode: # https://github.com/romkatv/gitstatus zinit ice wait'1' atload'zinc_optional_depenency_loaded' zinit load romkatv/gitstatus # After finishing the configuration wizard change the atload'' ice to: # -> atload'source ~/.p10k.zsh; _p9k_precmd' zinit ice wait'!' lucid atload'true; _p9k_precmd' nocd zinit light romkatv/powerlevel10k","title":"Gallery"},{"location":"GALLERY/#gallery_of_zinit_invocations","text":"PRs welcomed :)","title":"Gallery Of Zinit Invocations"},{"location":"GALLERY/#programs","text":"# junegunn/fzf-bin zinit ice from\"gh-r\" as\"program\" zinit light junegunn/fzf-bin # sharkdp/fd zinit ice as\"command\" from\"gh-r\" mv\"fd* -> fd\" pick\"fd/fd\" zinit light sharkdp/fd # sharkdp/bat zinit ice as\"command\" from\"gh-r\" mv\"bat* -> bat\" pick\"bat/bat\" zinit light sharkdp/bat # ogham/exa, replacement for ls zinit ice wait\"2\" lucid from\"gh-r\" as\"program\" mv\"exa* -> exa\" zinit light ogham/exa # All of the above using the for-syntax and also z-a-bin-gem-node annex zinit wait\"1\" lucid from\"gh-r\" as\"null\" for \\ sbin\"fzf\" junegunn/fzf-bin \\ sbin\"**/fd\" @sharkdp/fd \\ sbin\"**/bat\" @sharkdp/bat \\ sbin\"exa* -> exa\" ogham/exa zinit ice from\"gh-r\" as\"program\" mv\"docker* -> docker-compose\" zinit light docker/compose # jarun/nnn, a file browser, using the for-syntax zinit pick\"misc/quitcd/quitcd.zsh\" sbin make light-mode for jarun/nnn zinit ice as\"program\" atclone\"rm -f src/auto/config.cache; ./configure\" \\ atpull\"%atclone\" make pick\"src/vim\" zinit light vim/vim zinit ice as\"program\" make'!' atclone'./direnv hook zsh > zhook.zsh' \\ atpull'%atclone' src\"zhook.zsh\" zinit light direnv/direnv zinit ice from\"gh-r\" as\"program\" mv\"direnv* -> direnv\" zinit light direnv/direnv zinit ice from\"gh-r\" as\"program\" mv\"shfmt* -> shfmt\" zinit light mvdan/sh zinit ice from\"gh-r\" as\"program\" mv\"gotcha_* -> gotcha\" zinit light b4b4r07/gotcha zinit ice as\"program\" pick\"yank\" make zinit light mptre/yank zinit ice atclone'PYENV_ROOT=\"$PWD\" ./libexec/pyenv init - > zpyenv.zsh' \\ atinit'export PYENV_ROOT=\"$PWD\"' atpull\"%atclone\" \\ as'command' pick'bin/pyenv' src\"zpyenv.zsh\" nocompile'!' zinit light pyenv/pyenv zinit ice as\"program\" pick\"$ZPFX/sdkman/bin/sdk\" id-as'sdkman' run-atpull \\ atclone\"wget https://get.sdkman.io/?rcupdate=false -O scr.sh; SDKMAN_DIR=$ZPFX/sdkman bash scr.sh\" \\ atpull\"SDKMAN_DIR=$ZPFX/sdkman sdk selfupdate\" \\ atinit\"export SDKMAN_DIR=$ZPFX/sdkman; source $ZPFX/sdkman/bin/sdkman-init.sh\" zinit light z-shell/null # asciinema zinit ice as\"command\" wait lucid \\ atinit\"export PYTHONPATH=$ZPFX/lib/python3.7/site-packages/\" \\ atclone\"PYTHONPATH=$ZPFX/lib/python3.7/site-packages/ \\ python3 setup.py --quiet install --prefix $ZPFX\" \\ atpull'%atclone' test'0' \\ pick\"$ZPFX/bin/asciinema\" zinit load asciinema/asciinema.git # Installation of Rust compiler environment via the z-a-rust annex zinit id-as\"rust\" wait=1 as=null sbin=\"bin/*\" lucid rustup \\ atload=\"[[ ! -f ${ZINIT[COMPLETIONS_DIR]}/_cargo ]] && zi creinstall -q rust; \\ export CARGO_HOME=\\$PWD; export RUSTUP_HOME=\\$PWD/rustup\" for \\ z-shell/null","title":"Programs"},{"location":"GALLERY/#completions","text":"zinit ice as\"completion\" zinit snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker","title":"Completions"},{"location":"GALLERY/#scripts","text":"# ogham/exa also uses the definitions zinit ice wait\"0c\" lucid reset \\ atclone\"local P=${${(M)OSTYPE:#*darwin*}:+g} \\${P}sed -i \\ '/DIR/c\\DIR 38;5;63;1' LS_COLORS; \\ \\${P}dircolors -b LS_COLORS > c.zsh\" \\ atpull'%atclone' pick\"c.zsh\" nocompile'!' \\ atload'zstyle \":completion:*\" list-colors \u201c${(s.:.)LS_COLORS}\u201d' zinit light trapd00r/LS_COLORS # revolver zinit ice wait\"2\" lucid as\"program\" pick\"revolver\" zinit light molovo/revolver # zunit zinit ice wait\"2\" lucid as\"program\" pick\"zunit\" \\ atclone\"./build.zsh\" atpull\"%atclone\" zinit load molovo/zunit zinit ice as\"program\" pick\"$ZPFX/bin/git-*\" make\"PREFIX=$ZPFX\" nocompile zinit light tj/git-extras zinit ice as\"program\" atclone'perl Makefile.PL PREFIX=$ZPFX' \\ atpull'%atclone' make'install' pick\"$ZPFX/bin/git-cal\" zinit light k4rthik/git-cal zinit ice as\"program\" id-as\"git-unique\" pick\"git-unique\" zinit snippet https://github.com/Osse/git-scripts/blob/master/git-unique zinit ice as\"program\" cp\"wd.sh -> wd\" mv\"_wd.sh -> _wd\" \\ atpull'!git reset --hard' pick\"wd\" zinit light mfaerevaag/wd zinit ice as\"program\" pick\"bin/archey\" zinit load obihann/archey-osx","title":"Scripts"},{"location":"GALLERY/#plugins","text":"zinit ice pick\"h.sh\" zinit light paoloantinori/hhighlighter # zsh-tag-search; after ^G, prepend with \"/\" for the regular search zinit ice wait lucid bindmap\"^R -> ^G\" zinit light -b z-shell/zsh-tag-search # forgit zinit ice wait lucid zinit load 'wfxr/forgit' # diff-so-fancy zinit ice wait\"2\" lucid as\"program\" pick\"bin/git-dsf\" zinit load z-shell/zsh-diff-so-fancy # zsh-startify, a vim-startify like plugin zinit ice wait\"0b\" lucid atload\"zsh-startify\" zinit load z-shell/zsh-startify # declare-zsh zinit ice wait\"2\" lucid zinit load z-shell/declare-zsh # fzf-marks zinit ice wait lucid zinit load urbainvaes/fzf-marks # zsh-autopair zinit ice wait lucid zinit load hlissner/zsh-autopair zinit ice wait\"1\" lucid zinit load z-shell/zsh-navigation-tools # z-shell/history-search-multi-word zstyle \":history-search-multi-word\" page-size \"11\" zinit ice wait\"1\" lucid zinit load z-shell/history-search-multi-word # ZUI and Crasis zinit ice wait\"1\" lucid zinit load z-shell/zui zinit ice wait'[[ -n ${ZLAST_COMMANDS[(r)cra*]} ]]' lucid zinit load z-shell/zinit-crasis # Gitignore plugin \u2013 commands gii and gi zinit ice wait\"2\" lucid zinit load voronkovich/gitignore.plugin.zsh # Autosuggestions & fast-syntax-highlighting zinit ice wait lucid atinit\"ZPLGM[COMPINIT_OPTS]=-C; zpcompinit; zpcdreplay\" zinit light z-shell/fast-syntax-highlighting # zsh-autosuggestions zinit ice wait lucid atload\"!_zsh_autosuggest_start\" zinit load zsh-users/zsh-autosuggestions # F-Sy-H automatic per-directory themes plugin \u2013 available for patrons: # https://patreon.com/psprint zinit ice wait\"1\" lucid from\"psprint@gitlab.com\" zinit load psprint/fsh-auto-themes # zredis together with some binding/tying # \u2013 defines the variable $rdhash zstyle \":plugin:zredis\" configure_opts \"--without-tcsetpgrp\" zstyle \":plugin:zredis\" cflags \"-Wall -O2 -g -Wno-unused-but-set-variable\" zinit ice wait\"1\" lucid \\ atload'ztie -d db/redis -a 127.0.0.1:4815/5 -zSL main rdhash' zinit load z-shell/zredis # Github-Issue-Tracker \u2013 the notifier thread zinit ice lucid id-as\"GitHub-notify\" \\ on-update-of'~/.cache/zsh-github-issues/new_titles.log' \\ notify'New issue: $NOTIFY_MESSAGE' zinit light z-shell/zsh-github-issues","title":"Plugins"},{"location":"GALLERY/#services","text":"# a service that runs the redis database, in background, single instance zinit ice wait\"1\" lucid service\"redis\" zinit light zservices/redis # Github-Issue-Tracker \u2013 the issue-puller thread GIT_SLEEP_TIME=700 GIT_PROJECTS=z-shell/zsh-github-issues:z-shell/zinit zinit ice wait\"2\" lucid service\"GIT\" pick\"zsh-github-issues.service.zsh\" zinit light z-shell/zsh-github-issues","title":"Services"},{"location":"GALLERY/#snippets","text":"zinit ice svn pick\"completion.zsh\" src\"git.zsh\" zinit snippet OMZ::lib zinit ice svn wait\"0\" lucid atinit\"local ZSH=\\$PWD\" \\ atclone\"mkdir -p plugins; cd plugins; ln -sfn ../. osx\" zinit snippet OMZ::plugins/osx # Or with most recent Zinit and with ~/.zinit/snippets # directory pruned (rm -rf -- ${ZPLGM[SNIPPETS_DIR]}): zinit ice svn zinit snippet OMZ::plugins/osx","title":"Snippets"},{"location":"GALLERY/#themes","text":"GEOMETRY_COLOR_DIR=152 zinit ice wait\"0\" lucid atload\"geometry::prompt\" zinit light geometry-zsh/geometry zinit ice pick\"async.zsh\" src\"pure.zsh\" zinit light sindresorhus/pure zinit light mafredri/zsh-async # dependency zinit ice svn silent atload'prompt sorin' zinit snippet PZT::modules/prompt zinit ice atload\"fpath+=( \\$PWD );\" zinit light chauncey-garrett/zsh-prompt-garrett zinit ice svn atload\"prompt garrett\" silent zinit snippet PZT::modules/prompt zinit ice wait'!' lucid nocompletions \\ compile\"{zinc_functions/*,segments/*,zinc.zsh}\" \\ atload'!prompt_zinc_setup; prompt_zinc_precmd' zinit load robobenklein/zinc # ZINC git info is already async, but if you want it # even faster with gitstatus in Turbo mode: # https://github.com/romkatv/gitstatus zinit ice wait'1' atload'zinc_optional_depenency_loaded' zinit load romkatv/gitstatus # After finishing the configuration wizard change the atload'' ice to: # -> atload'source ~/.p10k.zsh; _p9k_precmd' zinit ice wait'!' lucid atload'true; _p9k_precmd' nocd zinit light romkatv/powerlevel10k","title":"Themes"},{"location":"INTRODUCTION/","text":"Introduction # In the document below you\u2019ll find out how to: use Oh My Zsh and Prezto, manage completions, use the Turbo mode, use the ice-mods like as\"program\" , and much more. Basic Plugin Loading # zinit load z-shell/history-search-multi-word zinit light zsh-users/zsh-syntax-highlighting Above commands show two ways of basic plugin loading. load causes reporting to be enabled \u2013 you can track what plugin does, view the information with zinit report {plugin-spec} and then also unload the plugin with zinit unload {plugin-spec} . light is a significantly faster loading without tracking and reporting, by using which user resigns of the ability to view the plugin report and to unload it. Note In Turbo mode the slowdown caused by tracking is negligible. Oh My Zsh, Prezto # To load Oh My Zsh and Prezto plugins, use snippet feature. Snippets are single files downloaded by curl , wget , etc. (an automatic detection of the download tool is being performed) directly from URL. For example: zinit snippet 'https://github.com/robbyrussell/oh-my-zsh/raw/master/plugins/git/git.plugin.zsh' zinit snippet 'https://github.com/sorin-ionescu/prezto/blob/master/modules/helper/init.zsh' Also, for Oh My Zsh and Prezto, you can use OMZ:: and PZT:: shorthands: zinit snippet OMZ::plugins/git/git.plugin.zsh zinit snippet PZT::modules/helper/init.zsh Moreover, snippets support Subversion protocol, supported also by Github. This allows to load snippets that are multi-file (for example, a Prezto module can consist of two or more files, e.g. init.zsh and alias.zsh ). Default files that will be sourced are: *.plugin.zsh , init.zsh , *.zsh-theme : # URL points to directory zinit ice svn zinit snippet PZT::modules/docker Snippets and Performance # Using curl , wget , etc. along with Subversion allows to almost completely avoid code dedicated to Oh My Zsh and Prezto, and also to other frameworks. This gives profits in performance of Zinit , it is really fast and also compact (causing low memory footprint and short loading time). Some Ice-Modifiers # The command zinit ice provides ice-modifiers for single next command (see the README subsection ice-modifiers ). The logic is that \"ice\" is something something that\u2019s added (e.g. to a drink or a coffee) \u2013 and in the Zinit sense this means that ice is a modifier added to the next Zinit command, and also something that melts (so it doesn\u2019t last long) \u2013 and in the Zinit use it means that the modifier lasts for only single next Zinit command. Using one other ice-modifier \" pick \" user can explicitly select the file to source : zinit ice svn pick\"init.zsh\" zinit snippet PZT::modules/git Content of ice-modifier is simply put into \"\u2026\" , '\u2026' , or $'\u2026' . No need for \":\" after ice-mod name (although it's allowed, so as the equal sign = , so e.g. pick=\"init.zsh\" or pick=init.zsh are being correctly recognized) . This way editors like vim and emacs and also zsh-users/zsh-syntax-highlighting and z-shell/fast-syntax-highlighting will highlight contents of ice-modifiers. as\"program\" # A plugin might not be a file for sourcing, but a command to be added to $PATH . To obtain this effect, use ice-modifier as with value program (or an alias value command ). zinit ice as\"program\" cp\"httpstat.sh -> httpstat\" pick\"httpstat\" zinit light b4b4r07/httpstat Above command will add plugin directory to $PATH , copy file httpstat.sh into httpstat and add execution rights ( +x ) to the file selected with pick , i.e. to httpstat . Other ice-mod exists, mv , which works like cp but moves a file instead of copying it. mv is ran before cp . Note The cp and mv ices (and also as some other ones, like atclone ) are being run when the plugin or snippet is being installed . To test them again first delete the plugin or snippet by zinit delete PZT::modules/osx (for example). atpull\"\u2026\" # Copying file is safe for doing later updates \u2013 original files of repository are unmodified and Git will report no conflicts. However, mv also can be used, if a proper atpull (an ice\u2013modifier ran at update of plugin) will be used: zinit ice as\"program\" mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" atpull'!git reset --hard' zinit light b4b4r07/httpstat If atpull starts with exclamation mark, then it will be run before git pull , and before mv . Nevertheless, atpull , mv , cp are ran only if new commits are to be fetched . So in summary, when user runs zinit update b4b4r07/httpstat to update this plugin, and there are new commits, what happens first is that git reset --hard is ran \u2013 and it restores original httpstat.sh , then git pull is ran and it downloads new commits (doing fast-forward), then mv is ran again so that the command is httpstat not httpstat.sh . This way the mv ice can be used to induce a permanent changes into the plugin's contents without blocking the ability to update it with git (or with subversion in case of snippets, more on this below at ** ). Note For exclamation mark to not be expanded by Zsh in interactive session, use '\u2026' not \"\u2026\" to enclose contents of atpull ice-mod. Snippets-Commands # Commands can also be added to $PATH using snippets . For example: zinit ice mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" as\"program\" zinit snippet \\ https://github.com/b4b4r07/httpstat/blob/master/httpstat.sh ( ** ) Snippets also support atpull ice-mod, so it\u2019s possible to do e.g. atpull'!svn revert' . There\u2019s also atinit ice-mod, executed before each loading of plugin or snippet. Snippets-Completions # By using the as'' ice-mod with value completion you can point the snippet subcommand directly to a completion file, e.g.: zinit ice as\"completion\" zinit snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker Completion Management # Zinit allows to disable and enable each completion in every plugin. Try installing a popular plugin that provides completions: zinit ice blockf zinit light zsh-users/zsh-completions First command (the blockf ice) will block the traditional method of adding completions. Zinit uses own method (based on symlinks instead of adding a number of directories to $fpath ). Zinit will automatically install completions of a newly downloaded plugin. To uninstall the completions and install them again, you would use: zinit cuninstall zsh-users/zsh-completions # uninstall zinit creinstall zsh-users/zsh-completions # install Listing Completions # Note zi is an alias that can be used in interactive sessions. To see what completions all plugins provide, in tabular formatting and with name of each plugin, use: zi clist This command is specially adapted for plugins like zsh-users/zsh-completions , which provide many completions \u2013 listing will have 3 completions per line (so that a smaller number of terminal pages will be occupied) like this: ... atach, bitcoin-cli, bower zsh-users/zsh-completions bundle, caffeinate, cap zsh-users/zsh-completions cask, cf, chattr zsh-users/zsh-completions ... You can show more completions per line by providing an argument to clist , e.g. zi clist 6 , will show: ... bundle, caffeinate, cap, cask, cf, chattr zsh-users/zsh-completions cheat, choc, cmake, coffee, column, composer zsh-users/zsh-completions console, dad, debuild, dget, dhcpcd, diana zsh-users/zsh-completions ... Enabling and Disabling Completions # Completions can be disabled, so that e.g. original Zsh completion will be used. The commands are very basic, they only need completion name : $ zi cdisable cmake Disabled cmake completion belonging to zsh-users/zsh-completions $ zi cenable cmake Enabled cmake completion belonging to zsh-users/zsh-completions That\u2019s all on completions. There\u2019s one more command, zinit csearch , that will search all plugin directories for available completions, and show if they are installed: This sums up to complete control over completions. Subversion for Subdirectories # In general, to use subdirectories of Github projects as snippets add /trunk/{path-to-dir} to URL, for example: zinit ice svn zinit snippet https://github.com/zsh-users/zsh-completions/trunk/src # For Oh My Zsh and Prezto, the OMZ:: and PZT:: prefixes work # without the need to add the `/trunk/` infix (however the path # should point to a directory, not to a file): zinit ice svn zinit snippet PZT::modules/docker Snippets too have completions installed by default, like plugins. Turbo Mode (Zsh >= 5.3) # The ice-mod wait allows the user postponing loading of a plugin to the moment when the processing of .zshrc is finished and the first prompt is being shown. It is like Windows \u2013 during startup, it shows desktop even though it still loads data in background. This has drawbacks, but is for sure better than blank screen for 10 minutes. And here, in Zinit, there are no drawbacks of this approach \u2013 no lags, freezes, etc. \u2013 the command line is fully usable while the plugins are being loaded, for any number of plugins. Note Turbo will speed up Zsh startup by 50%\u201380% . For example, instead of 200 ms, it'll be 40 ms (!) Zsh 5.3 or greater is required. To use this Turbo mode add wait ice to the target plugin in one of following ways: PS1=\"READY > \" zinit ice wait'!0' zinit load halfo/lambda-mod-zsh-theme This sets plugin halfo/lambda-mod-zsh-theme to be loaded 0 seconds after zshrc . It will fire up after c.a. 1 ms of showing of the basic prompt READY > . You probably won't load the prompt in such a way, however it is a good example in which Turbo can be directly observed. The exclamation mark causes Zinit to reset the prompt after loading plugin \u2013 it is needed for themes. The same with Prezto prompts, with a longer delay: zinit ice svn silent wait'!1' atload'prompt smiley' zinit snippet PZT::modules/prompt Using zsh-users/zsh-autosuggestions without any drawbacks: zinit ice wait lucid atload'_zsh_autosuggest_start' zinit light zsh-users/zsh-autosuggestions Explanation: Autosuggestions uses precmd hook, which is being called right after processing zshrc \u2013 precmd hooks are being called right before displaying each prompt . Turbo with the empty wait ice will postpone the loading 1 ms after that, so precmd will not be called at that first prompt. This makes autosuggestions inactive at the first prompt. However the given atload ice-mod fixes this, it calls the same function that precmd would, right after loading autosuggestions, resulting in exactly the same behavior of the plugin. The ice lucid causes the under-prompt message saying Loaded zsh-users/zsh-autosuggestions that normally appears for every Turbo-loaded plugin to not show. A Quick Glance At The For-Syntax # This introduction is based on the classic, two-command syntax ( zinit ice \u2026; zinit load/light/snippet \u2026 ) of Zinit. However, there's also available a recently added so-called for-syntax . It is a right moment to take a glance at it, by rewriting the above autosuggestions invocation using it: zinit wait lucid atload'_zsh_autosuggest_start' light-mode for \\ zsh-users/zsh-autosuggestions The syntax is a more concise one. The single command will work exactly the same as the previous classic-syntax invocation. It also allows solving some typical problems when using Zinit, like providing common/default ices for a set of plugins or sourcing multiple files . For more information refer to the page dedicated to the new syntax ( here ). Turbo-Loading Sophisticated Prompts # For some, mostly advanced themes the initialization of the prompt is being done in a precmd -hook, i.e.; in a function that's gets called before each prompt. The hook is installed by the add-zsh-hook Zsh function by adding its name to the $precmd_functions array. To make the prompt fully initialized after Turbo loading in the middle of the prompt (the same situation as with the zsh-autosuggestions plugin), the hook should be called from atload'' ice. First, find the name of the hook function by examining the $precmd_functions array. For example, for robobenklein/zinc theme, they'll be two functions: prompt_zinc_setup and prompt_zinc_precmd : root@sg > ~ > print $precmd_functions < \u2714 < 22:21:33 _zsh_autosuggest_start prompt_zinc_setup prompt_zinc_precmd Then, add them to the ice-list in the atload'' ice: zinit ice wait'!' lucid nocd \\ atload'!prompt_zinc_setup; prompt_zinc_precmd' zinit load robobenklein/zinc The exclamation mark in atload'!\u2026' is to track the functions allowing the plugin to be unloaded, as described here . It might be useful for the multi-prompt setup described next. Automatic Load/Unload on Condition # Ices load and unload allow to define when you want plugins active or unactive. For example: # Load when in ~/tmp zinit ice load'![[ $PWD = */tmp* ]]' unload'![[ $PWD != */tmp* ]]' \\ atload\"!promptinit; prompt sprint3\" zinit load psprint/zprompts # Load when NOT in ~/tmp zinit ice load'![[ $PWD != */tmp* ]]' unload'![[ $PWD = */tmp* ]]' zinit load russjohnson/angry-fly-zsh Two prompts, each active in different directories. This technique can be used to have plugin-sets, e.g. by defining parameter $PLUGINS with possible values like cpp , web , admin and by setting load / unload conditions to activate different plugins on cpp , on web , etc. Note The difference with wait is that load / unload are constantly active, not only till first activation. Note that for unloading of a plugin to work the plugin needs to be loaded with tracking (so zinit load \u2026 , not zinit light \u2026 ). Tracking causes slight slowdown, however this doesn\u2019t influence Zsh startup time when using Turbo mode. See also Wiki on multiple prompts . It contains a more real-world examples of a multi-prompt setup, which is being close to what the author uses in own setup.","title":"Introduction"},{"location":"INTRODUCTION/#introduction","text":"In the document below you\u2019ll find out how to: use Oh My Zsh and Prezto, manage completions, use the Turbo mode, use the ice-mods like as\"program\" , and much more.","title":"Introduction"},{"location":"INTRODUCTION/#basic_plugin_loading","text":"zinit load z-shell/history-search-multi-word zinit light zsh-users/zsh-syntax-highlighting Above commands show two ways of basic plugin loading. load causes reporting to be enabled \u2013 you can track what plugin does, view the information with zinit report {plugin-spec} and then also unload the plugin with zinit unload {plugin-spec} . light is a significantly faster loading without tracking and reporting, by using which user resigns of the ability to view the plugin report and to unload it. Note In Turbo mode the slowdown caused by tracking is negligible.","title":"Basic Plugin Loading"},{"location":"INTRODUCTION/#oh_my_zsh_prezto","text":"To load Oh My Zsh and Prezto plugins, use snippet feature. Snippets are single files downloaded by curl , wget , etc. (an automatic detection of the download tool is being performed) directly from URL. For example: zinit snippet 'https://github.com/robbyrussell/oh-my-zsh/raw/master/plugins/git/git.plugin.zsh' zinit snippet 'https://github.com/sorin-ionescu/prezto/blob/master/modules/helper/init.zsh' Also, for Oh My Zsh and Prezto, you can use OMZ:: and PZT:: shorthands: zinit snippet OMZ::plugins/git/git.plugin.zsh zinit snippet PZT::modules/helper/init.zsh Moreover, snippets support Subversion protocol, supported also by Github. This allows to load snippets that are multi-file (for example, a Prezto module can consist of two or more files, e.g. init.zsh and alias.zsh ). Default files that will be sourced are: *.plugin.zsh , init.zsh , *.zsh-theme : # URL points to directory zinit ice svn zinit snippet PZT::modules/docker","title":"Oh My Zsh, Prezto"},{"location":"INTRODUCTION/#snippets_and_performance","text":"Using curl , wget , etc. along with Subversion allows to almost completely avoid code dedicated to Oh My Zsh and Prezto, and also to other frameworks. This gives profits in performance of Zinit , it is really fast and also compact (causing low memory footprint and short loading time).","title":"Snippets and Performance"},{"location":"INTRODUCTION/#some_ice-modifiers","text":"The command zinit ice provides ice-modifiers for single next command (see the README subsection ice-modifiers ). The logic is that \"ice\" is something something that\u2019s added (e.g. to a drink or a coffee) \u2013 and in the Zinit sense this means that ice is a modifier added to the next Zinit command, and also something that melts (so it doesn\u2019t last long) \u2013 and in the Zinit use it means that the modifier lasts for only single next Zinit command. Using one other ice-modifier \" pick \" user can explicitly select the file to source : zinit ice svn pick\"init.zsh\" zinit snippet PZT::modules/git Content of ice-modifier is simply put into \"\u2026\" , '\u2026' , or $'\u2026' . No need for \":\" after ice-mod name (although it's allowed, so as the equal sign = , so e.g. pick=\"init.zsh\" or pick=init.zsh are being correctly recognized) . This way editors like vim and emacs and also zsh-users/zsh-syntax-highlighting and z-shell/fast-syntax-highlighting will highlight contents of ice-modifiers.","title":"Some Ice-Modifiers"},{"location":"INTRODUCTION/#asprogram","text":"A plugin might not be a file for sourcing, but a command to be added to $PATH . To obtain this effect, use ice-modifier as with value program (or an alias value command ). zinit ice as\"program\" cp\"httpstat.sh -> httpstat\" pick\"httpstat\" zinit light b4b4r07/httpstat Above command will add plugin directory to $PATH , copy file httpstat.sh into httpstat and add execution rights ( +x ) to the file selected with pick , i.e. to httpstat . Other ice-mod exists, mv , which works like cp but moves a file instead of copying it. mv is ran before cp . Note The cp and mv ices (and also as some other ones, like atclone ) are being run when the plugin or snippet is being installed . To test them again first delete the plugin or snippet by zinit delete PZT::modules/osx (for example).","title":"as\"program\""},{"location":"INTRODUCTION/#atpull","text":"Copying file is safe for doing later updates \u2013 original files of repository are unmodified and Git will report no conflicts. However, mv also can be used, if a proper atpull (an ice\u2013modifier ran at update of plugin) will be used: zinit ice as\"program\" mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" atpull'!git reset --hard' zinit light b4b4r07/httpstat If atpull starts with exclamation mark, then it will be run before git pull , and before mv . Nevertheless, atpull , mv , cp are ran only if new commits are to be fetched . So in summary, when user runs zinit update b4b4r07/httpstat to update this plugin, and there are new commits, what happens first is that git reset --hard is ran \u2013 and it restores original httpstat.sh , then git pull is ran and it downloads new commits (doing fast-forward), then mv is ran again so that the command is httpstat not httpstat.sh . This way the mv ice can be used to induce a permanent changes into the plugin's contents without blocking the ability to update it with git (or with subversion in case of snippets, more on this below at ** ). Note For exclamation mark to not be expanded by Zsh in interactive session, use '\u2026' not \"\u2026\" to enclose contents of atpull ice-mod.","title":"atpull\"\u2026\""},{"location":"INTRODUCTION/#snippets-commands","text":"Commands can also be added to $PATH using snippets . For example: zinit ice mv\"httpstat.sh -> httpstat\" \\ pick\"httpstat\" as\"program\" zinit snippet \\ https://github.com/b4b4r07/httpstat/blob/master/httpstat.sh ( ** ) Snippets also support atpull ice-mod, so it\u2019s possible to do e.g. atpull'!svn revert' . There\u2019s also atinit ice-mod, executed before each loading of plugin or snippet.","title":"Snippets-Commands"},{"location":"INTRODUCTION/#snippets-completions","text":"By using the as'' ice-mod with value completion you can point the snippet subcommand directly to a completion file, e.g.: zinit ice as\"completion\" zinit snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker","title":"Snippets-Completions"},{"location":"INTRODUCTION/#completion_management","text":"Zinit allows to disable and enable each completion in every plugin. Try installing a popular plugin that provides completions: zinit ice blockf zinit light zsh-users/zsh-completions First command (the blockf ice) will block the traditional method of adding completions. Zinit uses own method (based on symlinks instead of adding a number of directories to $fpath ). Zinit will automatically install completions of a newly downloaded plugin. To uninstall the completions and install them again, you would use: zinit cuninstall zsh-users/zsh-completions # uninstall zinit creinstall zsh-users/zsh-completions # install","title":"Completion Management"},{"location":"INTRODUCTION/#listing_completions","text":"Note zi is an alias that can be used in interactive sessions. To see what completions all plugins provide, in tabular formatting and with name of each plugin, use: zi clist This command is specially adapted for plugins like zsh-users/zsh-completions , which provide many completions \u2013 listing will have 3 completions per line (so that a smaller number of terminal pages will be occupied) like this: ... atach, bitcoin-cli, bower zsh-users/zsh-completions bundle, caffeinate, cap zsh-users/zsh-completions cask, cf, chattr zsh-users/zsh-completions ... You can show more completions per line by providing an argument to clist , e.g. zi clist 6 , will show: ... bundle, caffeinate, cap, cask, cf, chattr zsh-users/zsh-completions cheat, choc, cmake, coffee, column, composer zsh-users/zsh-completions console, dad, debuild, dget, dhcpcd, diana zsh-users/zsh-completions ...","title":"Listing Completions"},{"location":"INTRODUCTION/#enabling_and_disabling_completions","text":"Completions can be disabled, so that e.g. original Zsh completion will be used. The commands are very basic, they only need completion name : $ zi cdisable cmake Disabled cmake completion belonging to zsh-users/zsh-completions $ zi cenable cmake Enabled cmake completion belonging to zsh-users/zsh-completions That\u2019s all on completions. There\u2019s one more command, zinit csearch , that will search all plugin directories for available completions, and show if they are installed: This sums up to complete control over completions.","title":"Enabling and Disabling Completions"},{"location":"INTRODUCTION/#subversion_for_subdirectories","text":"In general, to use subdirectories of Github projects as snippets add /trunk/{path-to-dir} to URL, for example: zinit ice svn zinit snippet https://github.com/zsh-users/zsh-completions/trunk/src # For Oh My Zsh and Prezto, the OMZ:: and PZT:: prefixes work # without the need to add the `/trunk/` infix (however the path # should point to a directory, not to a file): zinit ice svn zinit snippet PZT::modules/docker Snippets too have completions installed by default, like plugins.","title":"Subversion for Subdirectories"},{"location":"INTRODUCTION/#turbo_mode_zsh_53","text":"The ice-mod wait allows the user postponing loading of a plugin to the moment when the processing of .zshrc is finished and the first prompt is being shown. It is like Windows \u2013 during startup, it shows desktop even though it still loads data in background. This has drawbacks, but is for sure better than blank screen for 10 minutes. And here, in Zinit, there are no drawbacks of this approach \u2013 no lags, freezes, etc. \u2013 the command line is fully usable while the plugins are being loaded, for any number of plugins. Note Turbo will speed up Zsh startup by 50%\u201380% . For example, instead of 200 ms, it'll be 40 ms (!) Zsh 5.3 or greater is required. To use this Turbo mode add wait ice to the target plugin in one of following ways: PS1=\"READY > \" zinit ice wait'!0' zinit load halfo/lambda-mod-zsh-theme This sets plugin halfo/lambda-mod-zsh-theme to be loaded 0 seconds after zshrc . It will fire up after c.a. 1 ms of showing of the basic prompt READY > . You probably won't load the prompt in such a way, however it is a good example in which Turbo can be directly observed. The exclamation mark causes Zinit to reset the prompt after loading plugin \u2013 it is needed for themes. The same with Prezto prompts, with a longer delay: zinit ice svn silent wait'!1' atload'prompt smiley' zinit snippet PZT::modules/prompt Using zsh-users/zsh-autosuggestions without any drawbacks: zinit ice wait lucid atload'_zsh_autosuggest_start' zinit light zsh-users/zsh-autosuggestions Explanation: Autosuggestions uses precmd hook, which is being called right after processing zshrc \u2013 precmd hooks are being called right before displaying each prompt . Turbo with the empty wait ice will postpone the loading 1 ms after that, so precmd will not be called at that first prompt. This makes autosuggestions inactive at the first prompt. However the given atload ice-mod fixes this, it calls the same function that precmd would, right after loading autosuggestions, resulting in exactly the same behavior of the plugin. The ice lucid causes the under-prompt message saying Loaded zsh-users/zsh-autosuggestions that normally appears for every Turbo-loaded plugin to not show.","title":"Turbo Mode (Zsh >= 5.3)"},{"location":"INTRODUCTION/#a_quick_glance_at_the_for-syntax","text":"This introduction is based on the classic, two-command syntax ( zinit ice \u2026; zinit load/light/snippet \u2026 ) of Zinit. However, there's also available a recently added so-called for-syntax . It is a right moment to take a glance at it, by rewriting the above autosuggestions invocation using it: zinit wait lucid atload'_zsh_autosuggest_start' light-mode for \\ zsh-users/zsh-autosuggestions The syntax is a more concise one. The single command will work exactly the same as the previous classic-syntax invocation. It also allows solving some typical problems when using Zinit, like providing common/default ices for a set of plugins or sourcing multiple files . For more information refer to the page dedicated to the new syntax ( here ).","title":"A Quick Glance At The For-Syntax"},{"location":"INTRODUCTION/#turbo-loading_sophisticated_prompts","text":"For some, mostly advanced themes the initialization of the prompt is being done in a precmd -hook, i.e.; in a function that's gets called before each prompt. The hook is installed by the add-zsh-hook Zsh function by adding its name to the $precmd_functions array. To make the prompt fully initialized after Turbo loading in the middle of the prompt (the same situation as with the zsh-autosuggestions plugin), the hook should be called from atload'' ice. First, find the name of the hook function by examining the $precmd_functions array. For example, for robobenklein/zinc theme, they'll be two functions: prompt_zinc_setup and prompt_zinc_precmd : root@sg > ~ > print $precmd_functions < \u2714 < 22:21:33 _zsh_autosuggest_start prompt_zinc_setup prompt_zinc_precmd Then, add them to the ice-list in the atload'' ice: zinit ice wait'!' lucid nocd \\ atload'!prompt_zinc_setup; prompt_zinc_precmd' zinit load robobenklein/zinc The exclamation mark in atload'!\u2026' is to track the functions allowing the plugin to be unloaded, as described here . It might be useful for the multi-prompt setup described next.","title":"Turbo-Loading Sophisticated Prompts"},{"location":"INTRODUCTION/#automatic_loadunload_on_condition","text":"Ices load and unload allow to define when you want plugins active or unactive. For example: # Load when in ~/tmp zinit ice load'![[ $PWD = */tmp* ]]' unload'![[ $PWD != */tmp* ]]' \\ atload\"!promptinit; prompt sprint3\" zinit load psprint/zprompts # Load when NOT in ~/tmp zinit ice load'![[ $PWD != */tmp* ]]' unload'![[ $PWD = */tmp* ]]' zinit load russjohnson/angry-fly-zsh Two prompts, each active in different directories. This technique can be used to have plugin-sets, e.g. by defining parameter $PLUGINS with possible values like cpp , web , admin and by setting load / unload conditions to activate different plugins on cpp , on web , etc. Note The difference with wait is that load / unload are constantly active, not only till first activation. Note that for unloading of a plugin to work the plugin needs to be loaded with tracking (so zinit load \u2026 , not zinit light \u2026 ). Tracking causes slight slowdown, however this doesn\u2019t influence Zsh startup time when using Turbo mode. See also Wiki on multiple prompts . It contains a more real-world examples of a multi-prompt setup, which is being close to what the author uses in own setup.","title":"Automatic Load/Unload on Condition"},{"location":"Installing-with-make/","text":"zinit ice as\"program\" pick\"$ZPFX/bin/git-*\" make\"PREFIX=$ZPFX\" zinit light tj/git-extras Makefile of this project has only one needed target \u2013 install , which is called by default, it also does building of the scripts that it installs, so it does 2 tasks, for Makefile with 2 targets, one could use make\"all install PREFIX=\u2026\" , pick'\u2026' will chmod +x all matching files and add $ZPFX/bin/ to $PATH , $ZPFX is provided by Zinit, it is ~/.zinit/polaris by default, can be also customized.","title":"Installing With Make"},{"location":"LS_COLORS-explanation/","text":"A repository trapd00r/LS_COLORS provides a file with color definitions for GNU ls command (and also for ogham/exa ; it can be also used to style Zsh completion \u2013 more on this below). Typically one does eval $( dircolors -b $HOME/LS_COLORS) to process this file and set environment for ls . However this means dircolors is ran every shell startup. This costs much time, because a fork has to be done and the program (i.e. dircolors ) binary needs to be loaded and executed, and because dircolors loads the colors' definitions and processes them. Following Zinit invocation solves this problem: zinit ice atclone\"dircolors -b LS_COLORS > clrs.zsh\" \\ atpull'%atclone' pick\"clrs.zsh\" nocompile'!' \\ atload'zstyle \":completion:*\" list-colors \u201c${(s.:.)LS_COLORS}\u201d' zinit light trapd00r/LS_COLORS atclone\"\u2026\" \u2013 generate shell script, but instead of passing it to eval , save it to file, atpull'%atclone' \u2013 do the same at any update of plugin (the atclone is being ran on the installation while the atpull hook is being ran on an update of the trapd00r/LS_COLORS plugin); the %atclone is just a special string that denotes that the atclone'' hook should be copied onto the atpull'' hook, pick\"clrs.zsh\" \u2013 source file clrs.zsh , the one that is generated, nocompile'!' \u2013 invokes compilation after the atclone'' ice-mod (the exclamation mark causes this). atload\"\u2026\" \u2013 additionally sets up the Zsh completion to use the colors provided by the trapd00r package. This way, except for the plugin installation and update, dircolors isn't ran, just normal sourcing is done. The every-day sourced file (i.e. clrs.zsh ) is even being compiled to speed up the loading.","title":"LS_COLORS Explanation"},{"location":"Multiple-prompts/","text":"# Load when MYPROMPT == 1 zinit ice load'![[ $MYPROMPT = 1 ]]' unload'![[ $MYPROMPT != 1 ]]' lucid zinit load halfo/lambda-mod-zsh-theme # Load when MYPROMPT == 2 zinit ice load'![[ $MYPROMPT = 2 ]]' unload'![[ $MYPROMPT != 2 ]]' \\ pick\"/dev/null\" multisrc\"{async,pure}.zsh\" \\ atload'!prompt_pure_precmd' lucid nocd zinit load sindresorhus/pure # Load when MYPROMPT == 3 zinit ice load'![[ $MYPROMPT = 3 ]]' unload'![[ $MYPROMPT != 3 ]]' \\ atload'!geometry::prompt' lucid nocd zinit load geometry-zsh/geometry load'' \u2013 condition that when fulfilled will cause plugin to be loaded, unload'' \u2013 as above, but will unload plugin, note that plugins are loaded with zinit load , not zinit light , to track what plugin does, to be able to unload it, atload'!\u2026' \u2013 run the precmd hooks to make the prompts fully initialized when loaded in the middle of the prompt ( precmd hooks are being normally run before each new prompt); exclamation mark causes the effects of the functions to be tracked, to allow better unloading, conditions are checked every second, you can use conditions like ![[ $PWD == *github* ]] to change prompt after changing directory to *github* , the exclamation mark ![[ \u2026 ]] causes prompt to be reset after loading or unloading the plugin, pick'/dev/null' \u2013 disable sourcing of the default-found file, multisrc'' \u2013 source multiple files, lucid \u2013 don't show the under-prompt message that says e.g.: Loaded geometry-zsh/geometry , nocd \u2013 don't cd into the plugin's directory when executing the atload'' ice \u2013 it could make the path that's displayed by the theme to point to that directory.","title":"Multiple Prompts"},{"location":"NPM-Packages/","text":"Zsh/NPM Packages # Introduction # Zinit can install NPM packages if they contain Zsh-related metadata (i.e.: the field \"zsh-data\" ) in the package.json . So basically what this means is that you can install plugins normally, like before, however with use of a metadata stored in the NPM package registry. This way you don't have to (but still can) specify ices, which might be handy when the ice-mod list is long and complex. Motivation # The motivation for adding such functionality was: Zinit is a very flexible plugin manager however users often feel overwhelmed by its configuration. It has many package-manager -like features, such as: it can run Makefiles , automatically provide shims (i.e.: forwarder scripts) for the binaries, extend $PATH to expose the binaries, and more. In general, Zinit has many hooks which allow surprising and beautiful things, however their content often evolves to a gradually better and better one and it's hard to keep track of the current version of them. So a solution came up : why not publish a package at the NPM-registry with the plugin configurations (i.e.: ice-mods) stored in the package.json file? Introductory Example # This way, instead of the following command used to install fzf : zinit lucid as=program pick=\"$ZPFX/bin/(fzf|fzf-tmux)\" \\ atclone=\"cp shell/completion.zsh _fzf_completion; \\ cp bin/(fzf|fzf-tmux) $ZPFX/bin\" \\ make=\"PREFIX=$ZPFX install\" for \\ junegunn/fzf you only need: zinit pack for fzf to get the complete setup of the fuzzy finder, including: the completion, the additional executable-script fzf-tmux . The installation is real, package-manager -like, because you don't need to invoke Zinit anymore once installed to use fzf (that's because fzf is just a binary program and not e.g.: a shell function). You can also update the package with zinit update fzf \u2013 it'll cause the project to refresh and rebuild, like with a \"normal\" package manager such as apt-get . However, it'll actually be more like to emerge from Gentoo, because the installation will be from the source\u2026 unless\u2026 you'll pick a binary installation :) So Zinit is like apt-get and emerge in one! Pros Of Using Zinit NPM-Support For Regular Software Installations # Using Zinit to install software where one could use a regular package manager has several advantages: Pro: The Zinit NPM packages typically use the URLs to the official and latest distributions of the software (like e.g.: the ecs-cli package, which uses the URL: https://amazon-ecs-cli.s3.amazonaws.com/ecs-cli-linux-amd64-latest when installing on Linux). Pro: You can influence the installation easily by specifying Zinit ice-mods, e.g.: zsh zinit pack=bgn atclone=\"cp fzy.1 $ZPFX/man/man1\" for fzy to install also the man page for the fzy fuzzy finder (this omission in the package will be fixed soon). Pro: The installation is much more flexible than a normal package manager. Example available degrees of freedom: to install from Git or from release-tarball, or from binary-release file, to install via shims or via extending $PATH , or by copying to $ZPFX/bin , to download files and apply patches to the source by using the Patch-Dl annex features. Pro: The installations are located in the user home directory, which doesn't require root access. Also, for Gems and Node modules, they are installed in their plugin directory, which can have advantages (e.g.: isolation allowing e.g: easy removal by rm -rf \u2026 ). Con: You're somewhat \"on your own\", with no support from any package maintainer. Thus, summing up 1. with 4., it might be nice/convenient to, for example, have the latest ECS CLI binary installed in the home directory, without using root access and always the latest, and \u2013 summing up with 2. and 3. \u2013 to, for example, have always the latest README downloaded by an additional ice: dl'https://raw.githubusercontent.com/aws/amazon-ecs-cli/master/README.md' (and then to have the README converted into a man page by the remark Markdown processor or other via an atclone'' ice, as the tool doesn't have any official man page). The z-shell Organization # The home for the packages is z-shell GitHub organization. You can find the available packages there, which as of 2019-12-11 include: asciidoctor \u2013 the AsciiDoc converter, installed as a Gem locally in the plugin directory with use of the Bin-Gem-Node annex, doctoc \u2013 the TOC (table of contents) generator for Markdown documents, installed as a Node package locally in the plugin directory with use of the Bin-Gem-Node annex, ecs-cli \u2013 the Amazon ECS command line tool, downloaded directly from the URL (or from the URL for OS X \u2013 automatically selected), firefox-dev \u2013 Firefox Developer Edition, downloaded from the URL (or from the URL for OS X; the OS X installation only downloads the dmg image, so it is'nt yet complete), fzf \u2013 the fuzzy-finder, installed from source (from a tarball or Git) or from the GitHub-releases binary, ls_colors \u2013 the trapd00r/LS_COLORS color definitions for GNU ls , ogham/exa and Zshell's completion. Adding Your Own Package # You can contact me to have the repository at the z-shell organization. Then, you'll only need to: Create an NPM account Invoke npm login . Populate the package.json \u2013 I suggest grabbing the one for fzf or doctoc and doing a few substitutions like doctoc \u2192 your-project and then simply filling the default profile in the z-shell-ices object \u2013 it's obvious how to do this. The project name in the package.json should start with zsh- . The prefix will be skipped when specifying it with Zinit. Commit and invoke npm publish . That's all!","title":"Zsh/NPM Packages"},{"location":"NPM-Packages/#zshnpm_packages","text":"","title":"Zsh/NPM Packages"},{"location":"NPM-Packages/#introduction","text":"Zinit can install NPM packages if they contain Zsh-related metadata (i.e.: the field \"zsh-data\" ) in the package.json . So basically what this means is that you can install plugins normally, like before, however with use of a metadata stored in the NPM package registry. This way you don't have to (but still can) specify ices, which might be handy when the ice-mod list is long and complex.","title":"Introduction"},{"location":"NPM-Packages/#motivation","text":"The motivation for adding such functionality was: Zinit is a very flexible plugin manager however users often feel overwhelmed by its configuration. It has many package-manager -like features, such as: it can run Makefiles , automatically provide shims (i.e.: forwarder scripts) for the binaries, extend $PATH to expose the binaries, and more. In general, Zinit has many hooks which allow surprising and beautiful things, however their content often evolves to a gradually better and better one and it's hard to keep track of the current version of them. So a solution came up : why not publish a package at the NPM-registry with the plugin configurations (i.e.: ice-mods) stored in the package.json file?","title":"Motivation"},{"location":"NPM-Packages/#introductory_example","text":"This way, instead of the following command used to install fzf : zinit lucid as=program pick=\"$ZPFX/bin/(fzf|fzf-tmux)\" \\ atclone=\"cp shell/completion.zsh _fzf_completion; \\ cp bin/(fzf|fzf-tmux) $ZPFX/bin\" \\ make=\"PREFIX=$ZPFX install\" for \\ junegunn/fzf you only need: zinit pack for fzf to get the complete setup of the fuzzy finder, including: the completion, the additional executable-script fzf-tmux . The installation is real, package-manager -like, because you don't need to invoke Zinit anymore once installed to use fzf (that's because fzf is just a binary program and not e.g.: a shell function). You can also update the package with zinit update fzf \u2013 it'll cause the project to refresh and rebuild, like with a \"normal\" package manager such as apt-get . However, it'll actually be more like to emerge from Gentoo, because the installation will be from the source\u2026 unless\u2026 you'll pick a binary installation :) So Zinit is like apt-get and emerge in one!","title":"Introductory Example"},{"location":"NPM-Packages/#pros_of_using_zinit_npm-support_for_regular_software_installations","text":"Using Zinit to install software where one could use a regular package manager has several advantages: Pro: The Zinit NPM packages typically use the URLs to the official and latest distributions of the software (like e.g.: the ecs-cli package, which uses the URL: https://amazon-ecs-cli.s3.amazonaws.com/ecs-cli-linux-amd64-latest when installing on Linux). Pro: You can influence the installation easily by specifying Zinit ice-mods, e.g.: zsh zinit pack=bgn atclone=\"cp fzy.1 $ZPFX/man/man1\" for fzy to install also the man page for the fzy fuzzy finder (this omission in the package will be fixed soon). Pro: The installation is much more flexible than a normal package manager. Example available degrees of freedom: to install from Git or from release-tarball, or from binary-release file, to install via shims or via extending $PATH , or by copying to $ZPFX/bin , to download files and apply patches to the source by using the Patch-Dl annex features. Pro: The installations are located in the user home directory, which doesn't require root access. Also, for Gems and Node modules, they are installed in their plugin directory, which can have advantages (e.g.: isolation allowing e.g: easy removal by rm -rf \u2026 ). Con: You're somewhat \"on your own\", with no support from any package maintainer. Thus, summing up 1. with 4., it might be nice/convenient to, for example, have the latest ECS CLI binary installed in the home directory, without using root access and always the latest, and \u2013 summing up with 2. and 3. \u2013 to, for example, have always the latest README downloaded by an additional ice: dl'https://raw.githubusercontent.com/aws/amazon-ecs-cli/master/README.md' (and then to have the README converted into a man page by the remark Markdown processor or other via an atclone'' ice, as the tool doesn't have any official man page).","title":"Pros Of Using Zinit NPM-Support For Regular Software Installations"},{"location":"NPM-Packages/#the_z-shell_organization","text":"The home for the packages is z-shell GitHub organization. You can find the available packages there, which as of 2019-12-11 include: asciidoctor \u2013 the AsciiDoc converter, installed as a Gem locally in the plugin directory with use of the Bin-Gem-Node annex, doctoc \u2013 the TOC (table of contents) generator for Markdown documents, installed as a Node package locally in the plugin directory with use of the Bin-Gem-Node annex, ecs-cli \u2013 the Amazon ECS command line tool, downloaded directly from the URL (or from the URL for OS X \u2013 automatically selected), firefox-dev \u2013 Firefox Developer Edition, downloaded from the URL (or from the URL for OS X; the OS X installation only downloads the dmg image, so it is'nt yet complete), fzf \u2013 the fuzzy-finder, installed from source (from a tarball or Git) or from the GitHub-releases binary, ls_colors \u2013 the trapd00r/LS_COLORS color definitions for GNU ls , ogham/exa and Zshell's completion.","title":"The z-shell Organization"},{"location":"NPM-Packages/#adding_your_own_package","text":"You can contact me to have the repository at the z-shell organization. Then, you'll only need to: Create an NPM account Invoke npm login . Populate the package.json \u2013 I suggest grabbing the one for fzf or doctoc and doing a few substitutions like doctoc \u2192 your-project and then simply filling the default profile in the z-shell-ices object \u2013 it's obvious how to do this. The project name in the package.json should start with zsh- . The prefix will be skipped when specifying it with Zinit. Commit and invoke npm publish . That's all!","title":"Adding Your Own Package"},{"location":"Private-Repositories/","text":"Loading Plugins From Private Repositories And Not Only Introduction Explanation Summary Loading Plugins From Private Repositories And Not Only # Introduction # In order to install and load a plugin whose repository is private - i.e.: requires providing credentials in order to log in \u2013 use the from'' ice in the following way: zinit ice from\"psprint@github.com\" zinit load psprint/fsh-auto-themes Explanation # The point is that when the from'' ice isn't one of gh , github , gl , gitlab , bb , bitbucket , nb , notabug , gh-r , github-rel then it is treaten as a domain name and inserted into the domain position into the clone url. I.e.: the following (more or less) git clone command is being run: git clone https://{from-ice-contents}/user/plugin In order to change the protocol, use the proto'' ice. Summary # By using this method you can clone plugins from e.g. GitHub Enterprise or embed the passwords as plain text in .zshrc .","title":"Loading Plugins From Private Repositories"},{"location":"Private-Repositories/#loading_plugins_from_private_repositories_and_not_only","text":"","title":"Loading Plugins From Private Repositories And Not Only"},{"location":"Private-Repositories/#introduction","text":"In order to install and load a plugin whose repository is private - i.e.: requires providing credentials in order to log in \u2013 use the from'' ice in the following way: zinit ice from\"psprint@github.com\" zinit load psprint/fsh-auto-themes","title":"Introduction"},{"location":"Private-Repositories/#explanation","text":"The point is that when the from'' ice isn't one of gh , github , gl , gitlab , bb , bitbucket , nb , notabug , gh-r , github-rel then it is treaten as a domain name and inserted into the domain position into the clone url. I.e.: the following (more or less) git clone command is being run: git clone https://{from-ice-contents}/user/plugin In order to change the protocol, use the proto'' ice.","title":"Explanation"},{"location":"Private-Repositories/#summary","text":"By using this method you can clone plugins from e.g. GitHub Enterprise or embed the passwords as plain text in .zshrc .","title":"Summary"},{"location":"Profiling-plugins/","text":"zinit ice atinit'zmodload zsh/zprof' \\ atload'zprof | head -n 20; zmodload -u zsh/zprof' zinit light z-shell/fast-syntax-highlighting atinit'' loads zsh/zprof module (shipped with Zsh) before loading the plugin \u2013 this starts the profiling, atload'' works after loading the plugin \u2013 shows profiling results ( zprof | head ), unloads zsh/zprof - this stops the profiling; in the effect, only a single plugin (in this case z-shell/fast-syntax-highlighting ) will be profiled while the rest of the e.g. zshrc processing will go on completely normally, the light loads without reporting enabled, so less Zinit code is being run \u2013 no Zinit code responsible for the tracking (i.e. the automatic data gathering, during loading of a plugin, for the reports and the possibility to unload the plugin) will be activated and the functions will not appear in the zprof report. example zprof report: num calls time self name --------------------------------------------------------------------------- 1) 1 57,76 57,76 57,91% 57,76 57,76 57,91% _zsh_highlight_bind_widgets 2) 1 25,81 25,81 25,88% 25,81 25,81 25,88% compinit 3) 4 10,71 2,68 10,74% 8,71 2,18 8,73% --zplg-shadow-autoload 4) 43 2,06 0,05 2,07% 2,06 0,05 2,07% -zplg-add-report 5) 8 1,98 0,25 1,98% 1,98 0,25 1,98% compdef 6) 1 2,85 2,85 2,85% 0,87 0,87 0,87% -zplg-compdef-replay 7) 1 0,68 0,68 0,68% 0,68 0,68 0,68% -zplg-shadow-off 8) 1 0,79 0,79 0,79% 0,49 0,49 0,49% add-zsh-hook 9) 1 0,47 0,47 0,47% 0,47 0,47 0,47% -zplg-shadow-on 10) 3 0,34 0,11 0,35% 0,34 0,11 0,35% (anon) 11) 4 10,91 2,73 10,94% 0,20 0,05 0,20% autoload 12) 1 0,19 0,19 0,19% 0,19 0,19 0,19% -fast-highlight-fill-option-variables 13) 1 25,98 25,98 26,05% 0,17 0,17 0,17% zpcompinit 14) 1 2,88 2,88 2,89% 0,03 0,03 0,03% zpcdreplay 15) 1 0,00 0,00 0,00% 0,00 0,00 0,00% -zplg-load-plugin ----------------------------------------------------------------------------------- the first column is the time is in milliseconds; it denotes the amount of time spent in a function in total so for example, --zplg-shadow-autoload consumed 10.71 ms of the execution time, the fourth column is also a time in milliseconds, but it denotes the amount of time spent on executing only of function's own code , i.e. it doesn't count the time spent in descendant functions that are called from the function; so for example, --zplg-shadow-autoload spent 8.71 ms on executing only its own code. the table is sorted on the self-time column.","title":"Profiling Plugins"},{"location":"Sourcing-multiple-files/","text":"Normally src'' can be used to specify additional file to source: zinit ice pick\"powerless.zsh\" src\"utilities.zsh\" zinit light martinrotter/powerless pick'' \u2013 provide main file to source (can be a pattern like *.sh \u2013 alphabetically first matched file is sourced), src'' \u2013 provide second file to source (not a pattern, plain file name) However, via atload'' ice one can provide simple loop to source more files: zinit ice svn pick\"completion.zsh\" \\ atload'local f; for f in git.zsh misc.zsh; do \\ source $f \\ done' zinit snippet OMZ::lib svn \u2013 use Subversion to clone OMZ::lib (the whole Oh My Zsh lib/ directory), note that atload'' uses apostrophes not double quotes, to literally put $f into the string, atload 's code is automatically being run within the snippet's (or plugin's) directory , atload'' code isn't tracked by Zinit, i.e. cannot be unloaded, unless you load a plugin (not a snippet) with zinit load \u2026 and prepend the value of the ice with exclamation mark, i.e. atload'!local f; for \u2026' , atload'' is executed after loading main files ( pick'' and src'' ones). The multisrc'' ice, which loads multiple files enumerated with spaces as the separator (e.g. multisrc'misc.zsh grep.zsh' ) and also using brace-expansion syntax (e.g. multisrc'{misc,grep}.zsh') . Example: zinit ice svn pick\"completion.zsh\" multisrc'git.zsh \\ functions.zsh {history,grep}.zsh' zinit snippet OMZ::lib The all possible ways to use the multisrc'' ice-mod: zinit ice depth\"1\" multisrc=\"lib/{functions,misc}.zsh\" pick\"/dev/null\" zinit load robbyrussell/oh-my-zsh # Can use patterns zinit ice svn multisrc\"{funct*,misc}.zsh\" pick\"/dev/null\" zinit snippet OMZ::lib array=({functions,misc}.zsh) zinit ice svn multisrc\"$array\" pick\"/dev/null\" zinit snippet OMZ::lib # Will use the array's value at the moment of plugin load # \u2013 this can matter in case of using Turbo mode array=({functions,misc}.zsh) zinit ice svn multisrc\"\\$array\" pick\"/dev/null\" zinit snippet OMZ::lib # Compatible with KSH_ARRAYS option array=({functions,misc}.zsh) zinit ice svn multisrc\"${array[*]}\" pick\"/dev/null\" zinit snippet OMZ::lib # Compatible with KSH_ARRAYS option array=({functions,misc}.zsh) zinit ice svn multisrc\"\\${array[*]}\" pick\"/dev/null\" zinit snippet OMZ::lib zinit ice svn multisrc\"misc.zsh functions.zsh\" pick\"/dev/null\" zinit snippet OMZ::lib # Also \u2013 hack Zinit: the ice's contents is simply `eval'-uated # like follows: eval \"reply=($multisrc)\". So it might get handy on # an occasion to pass code there, but first you must close the paren # and then don't forget to assign `reply', and to provide a trailing # opening paren. In the code be careful to not redefine any variable # used internally by Zinit \u2013 e.g.: `i' is safe: array=({functions,misc}.zsh) zinit ice svn multisrc'); local i; for i in $array; do \\ reply+=( ${i/.zsh/.sh} ); \\ done; ((1)' pick\"/dev/null\" zinit snippet OMZ::lib -- Changes In The Recent Zinit # Recently, Zinit has been extended with the For-Syntax which can in some situations replace a typical multisrc'' loading. The point is that this syntax allows to easily specify snippets to source \u2013 and do this within a single Zinit command. Thus, instead of: zinit ice multisrc'(functions|misc|completion).zsh' zinit snippet OMZ::lib it's possible to write: zinit for \\ OMZL::functions.zsh \\ OMZL::misc.zsh \\ OMZL::completion.zsh which is somewhat easier on eyes. Also \u2013 an important property: the multiple snippets loaded with the for-syntax are being loaded separately , which means that they will not cause a longer keyboard blockage, which could have been noticeable \u2013 when using Turbo. The Zinit scheduler will distribute the work over time and will allow activation of keyboard in between the snippets. The multisrc'' way doesn't work this way \u2013 sourcing many files can cause noticeable keyboard freezes (in Turbo).","title":"Sourcing Multiple Files"},{"location":"Sourcing-multiple-files/#changes_in_the_recent_zinit","text":"Recently, Zinit has been extended with the For-Syntax which can in some situations replace a typical multisrc'' loading. The point is that this syntax allows to easily specify snippets to source \u2013 and do this within a single Zinit command. Thus, instead of: zinit ice multisrc'(functions|misc|completion).zsh' zinit snippet OMZ::lib it's possible to write: zinit for \\ OMZL::functions.zsh \\ OMZL::misc.zsh \\ OMZL::completion.zsh which is somewhat easier on eyes. Also \u2013 an important property: the multiple snippets loaded with the for-syntax are being loaded separately , which means that they will not cause a longer keyboard blockage, which could have been noticeable \u2013 when using Turbo. The Zinit scheduler will distribute the work over time and will allow activation of keyboard in between the snippets. The multisrc'' way doesn't work this way \u2013 sourcing many files can cause noticeable keyboard freezes (in Turbo).","title":"Changes In The Recent Zinit"},{"location":"Z-PLUGINS/","text":"z-plugins # What Are They? # They are Zinit extensions. Note the difference in the name from the Zinit \u2013 the dash and the plural form. What Can They Do? # Add a new Zinit subcommand (i.e. the command that\u2019s placed after the function zinit \u2026 when calling Zinit). Add new ice-modifiers. Register four type of hooks: atclone hook \u2013 run after cloning any plugin or downloading any snippet. atpull hook \u2013 run after pulling new commits (i.e. updating) for any plugin / snippet. atinit hook \u2013 run before loading any plugin / snippet, after it has been set-up (i.e. downloaded). atload hook \u2013 run after loading any plugin / snippet. Register hooks for generating help text, shown by the zinit help subcommand. How To Code Them? # Below is an example body of an atclone hook (taken from z-shell/z-a-submods z-plugin). It shows how to: Obtain the arguments passed to the hook. Use an ice modifier. It also shows an useful snippet that will trim the whitespace in array elements. Utilize the last hook argument \u2013 the plugin\u2019s/snippet\u2019s containing directory. emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent [[ -z \"${ZPLG_ICE[submods]}\" ]] && return 0 # (1) [[ \"$1\" = plugin ]] && \\ local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"$5\" || \\ local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"$4\" # type: snippet local -a mods parts local mod # (2) mods=( ${(@s.;.)ZPLG_ICE[submods]} ) for mod in \"${mods[@]}\"; do parts=( \"${(@s:->:)mod}\" ) # (3) Remove only leading and trailing whitespace parts=( \"${parts[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}\" ) print \"\\nCloning submodule: ${parts[1]} to dir: ${parts[2]}\" parts[1]=\"https://github.com/${parts[1]}\" # (4) \u2013 the: -C \"$dir\" command git -C \"$dir\" clone --progress \"${parts[1]}\" \"${parts[2]}\" done The recommended method of creating a hook is to place its body into a file that starts with a colon, and also a zp- prefix, e.g. :zp-myproject-atclone-hook and then to mark it for autoloading via autoload -Uz :zp-myproject-atclone-hook . Then register the hook (presumably in the myproject.plugin.zsh file) with the API call: @zplg-register-z-plugin : @zplg-register-z-plugin \"myproject\" hook:atclone \\ :zp-myproject-atclone-handler \\ :zp-myproject-atclone-help-handler \\ \"submods''\" # register a new ice-mod: submods'' The general syntax of the API call is: @zplg-register-z-plugin {project-name} \\ {hook: \\ {name-of-the-handler-function} \\ {name-of-the-HELP-handler-function} \\ \"{ice-mod1}|{ice-mod2}|\u2026\" < hook-type >| subcommand: < new-subcommand-name > } The last argument, i.e. the | -separated ice-list, is optional. That\u2019s all! After this loading the plugin myproject will set up the new ice-mod submods that will have syntax submods'{user}/{plugin} \u2013> {output-dir}; \u2026' and will clone submodules when installing the original plugin or snippet! Example real-world use of the ice-mod: # Load the `zsh-autosuggestions' plugin via Prezto module: `autosuggestions' zinit ice svn submods'zsh-users/zsh-autosuggestions -> external' zinit snippet PZT::modules/autosuggestions Checkout the project which fully implements this idea, z-shell/z-a-submods . It e.g. also implements the atpull hook, i.e. supports automatic update of the submodules. The z-p-* prefix is recommended for projects that are being z-plugins. Details # There are 2 or 3 subtypes for each of the hook: atinit or !atinit \u2013 the ! version is ran before the atinit ice-mod (i.e. before zinit ice atinit'echo this!'; \u2026 ), while the normal version runs after it. atload or !atload \u2013 analogous to the atinit case: the ! version runs before the atload ice-mod (while the normal version runs after it). atclone or !atclone \u2013 analogous to the atinit and atload cases. atpull , !atpull or %atpull \u2013 the first two are being ran only when there are new commits to be downloaded during the update. The % version is being always run, regardless if the update will pull any actual commits or not, and it is being ran after the atpull ice-mod .","title":"z-plugins"},{"location":"Z-PLUGINS/#z-plugins","text":"","title":"z-plugins"},{"location":"Z-PLUGINS/#what_are_they","text":"They are Zinit extensions. Note the difference in the name from the Zinit \u2013 the dash and the plural form.","title":"What Are They?"},{"location":"Z-PLUGINS/#what_can_they_do","text":"Add a new Zinit subcommand (i.e. the command that\u2019s placed after the function zinit \u2026 when calling Zinit). Add new ice-modifiers. Register four type of hooks: atclone hook \u2013 run after cloning any plugin or downloading any snippet. atpull hook \u2013 run after pulling new commits (i.e. updating) for any plugin / snippet. atinit hook \u2013 run before loading any plugin / snippet, after it has been set-up (i.e. downloaded). atload hook \u2013 run after loading any plugin / snippet. Register hooks for generating help text, shown by the zinit help subcommand.","title":"What Can They Do?"},{"location":"Z-PLUGINS/#how_to_code_them","text":"Below is an example body of an atclone hook (taken from z-shell/z-a-submods z-plugin). It shows how to: Obtain the arguments passed to the hook. Use an ice modifier. It also shows an useful snippet that will trim the whitespace in array elements. Utilize the last hook argument \u2013 the plugin\u2019s/snippet\u2019s containing directory. emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent [[ -z \"${ZPLG_ICE[submods]}\" ]] && return 0 # (1) [[ \"$1\" = plugin ]] && \\ local type=\"$1\" user=\"$2\" plugin=\"$3\" id_as=\"$4\" dir=\"$5\" || \\ local type=\"$1\" url=\"$2\" id_as=\"$3\" dir=\"$4\" # type: snippet local -a mods parts local mod # (2) mods=( ${(@s.;.)ZPLG_ICE[submods]} ) for mod in \"${mods[@]}\"; do parts=( \"${(@s:->:)mod}\" ) # (3) Remove only leading and trailing whitespace parts=( \"${parts[@]//((#s)[[:space:]]##|[[:space:]]##(#e))/}\" ) print \"\\nCloning submodule: ${parts[1]} to dir: ${parts[2]}\" parts[1]=\"https://github.com/${parts[1]}\" # (4) \u2013 the: -C \"$dir\" command git -C \"$dir\" clone --progress \"${parts[1]}\" \"${parts[2]}\" done The recommended method of creating a hook is to place its body into a file that starts with a colon, and also a zp- prefix, e.g. :zp-myproject-atclone-hook and then to mark it for autoloading via autoload -Uz :zp-myproject-atclone-hook . Then register the hook (presumably in the myproject.plugin.zsh file) with the API call: @zplg-register-z-plugin : @zplg-register-z-plugin \"myproject\" hook:atclone \\ :zp-myproject-atclone-handler \\ :zp-myproject-atclone-help-handler \\ \"submods''\" # register a new ice-mod: submods'' The general syntax of the API call is: @zplg-register-z-plugin {project-name} \\ {hook: \\ {name-of-the-handler-function} \\ {name-of-the-HELP-handler-function} \\ \"{ice-mod1}|{ice-mod2}|\u2026\" < hook-type >| subcommand: < new-subcommand-name > } The last argument, i.e. the | -separated ice-list, is optional. That\u2019s all! After this loading the plugin myproject will set up the new ice-mod submods that will have syntax submods'{user}/{plugin} \u2013> {output-dir}; \u2026' and will clone submodules when installing the original plugin or snippet! Example real-world use of the ice-mod: # Load the `zsh-autosuggestions' plugin via Prezto module: `autosuggestions' zinit ice svn submods'zsh-users/zsh-autosuggestions -> external' zinit snippet PZT::modules/autosuggestions Checkout the project which fully implements this idea, z-shell/z-a-submods . It e.g. also implements the atpull hook, i.e. supports automatic update of the submodules. The z-p-* prefix is recommended for projects that are being z-plugins.","title":"How To Code Them?"},{"location":"Z-PLUGINS/#details","text":"There are 2 or 3 subtypes for each of the hook: atinit or !atinit \u2013 the ! version is ran before the atinit ice-mod (i.e. before zinit ice atinit'echo this!'; \u2026 ), while the normal version runs after it. atload or !atload \u2013 analogous to the atinit case: the ! version runs before the atload ice-mod (while the normal version runs after it). atclone or !atclone \u2013 analogous to the atinit and atload cases. atpull , !atpull or %atpull \u2013 the first two are being ran only when there are new commits to be downloaded during the update. The % version is being always run, regardless if the update will pull any actual commits or not, and it is being ran after the atpull ice-mod .","title":"Details"},{"location":"Zinit-Packages/","text":"Zinit Packages # Introduction # Zinit can install from so-called packages \u2013 GitHub repositories holding a package.json file with the Zinit meta-data in them. This way you don't have to (but still can) specify ices, which might be handy when the ice-mod list is long and complex. Motivation # The motivation for adding such functionality was: Zinit is a flexible plugin manager, however, users often feel overwhelmed by its configuration. It has multiple package-manager -like features, such as: it can run Makefiles , automatically provide shims (i.e.: forwarder scripts) for the binaries, extend $PATH to expose the binaries, and more. In general, Zinit has many hooks which allow surprising things, however their content often evolves to a gradually better and better one and it's hard to keep track of the current version of them. So a solution appeared: why not publish a package at GitHub with the plugin configurations (i.e.: ice-mod lists) stored in a file? Introductory Example # This way, instead of the following command used to install fzf : zinit lucid as=program pick=\"$ZPFX/bin/(fzf|fzf-tmux)\" \\ atclone=\"cp shell/completion.zsh _fzf_completion; \\ cp bin/(fzf|fzf-tmux) $ZPFX/bin\" \\ make=\"PREFIX=$ZPFX install\" for \\ junegunn/fzf you only need: zinit pack for fzf to get the complete setup of the fuzzy finder, including: the completion, the additional executable-script fzf-tmux . The installation is real, package-manager -like, because you don't need to invoke Zinit anymore once installed to use fzf (that's because fzf is just a binary program and not e.g.: a shell function). You can also update the package with zinit update fzf \u2013 it'll cause the project to refresh and rebuild, like with a \"normal\" package manager such as apt-get . However, it'll actually be more like to emerge from Gentoo, because the installation will be from the source\u2026 unless\u2026 the user will pick up a binary installation by profile-argument specified in the pack'' ice :) Pros Of Using Zinit Package For Regular Software Installations # Using Zinit to install software where one could use a regular package manager has several advantages: Pro: The Zinit packages typically use the URLs to the official and latest distributions of the software (like e.g.: the ecs-cli package, which uses the URL: https://amazon-ecs-cli.s3.amazonaws.com/ecs-cli-linux-amd64-latest when installing on Linux). Pro: You can influence the installation easily by specifying Zinit ice-mods, e.g.: zinit pack=bgn atclone=\"cp fzy.1 $ZPFX/man/man1\" for fzy to install also the man page for the fzy fuzzy finder (this omission in the package will be fixed soon). Pro: The installation is much more flexible than a normal package manager. Example available degrees of freedom: to install from Git or from release-tarball, or from binary-release file, to install via shims or via extending $PATH , or by copying to $ZPFX/bin , to download files and apply patches to the source by using the Patch-Dl annex features. Pro: The installations are located in the user home directory, which doesn't require root access. Also, for Gems and Node modules, they are installed in their plugin directory, which can have advantages (e.g.: isolation allowing e.g: easy removal by rm -rf \u2026 ). Con: You're somewhat \"on your own\", with no support from any package maintainer. Thus, summing up 1. with 4., it might be nice/convenient to, for example, have the latest ECS CLI binary installed in the home directory, without using root access and always the latest, and \u2013 summing up with 2. and 3. \u2013 to, for example, have always the latest README downloaded by an additional ice: dl'https://raw.githubusercontent.com/aws/amazon-ecs-cli/master/README.md' (and then to have the README converted into a man page by the remark Markdown processor or other via an atclone'' ice, as the tool doesn't have any official man page). The Z-Shell Organization # The home for the packages is Z-Shell GitHub organization. You can find the available packages here , which as of 2021-11-11 include: any-node - Special package \u2013 it is designed for easy installing of any Node modules inside the plugin directory. any-gem \u2013 Special package \u2013 it is designed for easy installing of any Ruby Gems locally inside the plugin directory. apr \u2013 Provides apache/apr library by compiling and installing it to the $ZPFX/bin . fzf - Fuzzy finder via Makefile installation of the junegunn/fzf binary under $ZPFX/bin . fzy \u2013 Fuzzy finder via Makefile-installation of the jhawthorn/fzy binary under $ZPFX/bin . pyenv \u2013 Provides pyenv/pyenv ** version manager command by extending $PATH to make it point into the bin subdirectory of the plugin. remark - Provides the CLI command for remarkjs/remark with two plugins: Man, HTML doctoc \u2013 Provides the thlorenz/doctoc CLI command. ls_colors \u2013 Provides the trapd00r/LS_COLORS and setups a zsh-completion system to use the definitions with: GNU 'ls', ogham/exa ' dircolors-material \u2013 The package provides the zpm-zsh/dircolors-material definitions and also setups zsh-completion system to use the definitions with: GNU 'ls', ' ogham/exa ' asciidoctor \u2013 Provides the CLI command for asciidoctor **. zsh-system-completions \u2013 A package that brings stock Zsh completions under the control of Zinit. ecs-cli \u2013 Provides the command for Amazon ecs-cli ** by copying it to $ZPFX/bin . subversion \u2013 Provides the apache/subversion ** revision control system by compiling and installing it to the $ZPFX/bin . github-issues \u2013 Zinit invocations that'll install z-shell/zsh-github-issues. github-issues-srv - The package is the puller-thread service for the z-shell/zsh-github-issues plugin. It runs the background service that downloads the new issues from GitHub. firefox-dev - Provides the CLI commands firefox-bin and firefox by extending the $PATH/bin . zsh - Builds and installs the newest zsh-users/zsh . Adding Your Own Package # Contact the author to have the repository at z-shell organization. Populate the package.json \u2013 I suggest grabbing the one for fzf or doctoc and doing a few substitutions like doctoc \u2192 your-project and then simply filling the default profile in the zinit-ices object \u2013 it's obvious how to do this. The project name in the package.json should start with zsh- . The prefix will be skipped when specifying it with Zinit. Commit and push. That's all!","title":"Zinit Packages"},{"location":"Zinit-Packages/#zinit_packages","text":"","title":"Zinit Packages"},{"location":"Zinit-Packages/#introduction","text":"Zinit can install from so-called packages \u2013 GitHub repositories holding a package.json file with the Zinit meta-data in them. This way you don't have to (but still can) specify ices, which might be handy when the ice-mod list is long and complex.","title":"Introduction"},{"location":"Zinit-Packages/#motivation","text":"The motivation for adding such functionality was: Zinit is a flexible plugin manager, however, users often feel overwhelmed by its configuration. It has multiple package-manager -like features, such as: it can run Makefiles , automatically provide shims (i.e.: forwarder scripts) for the binaries, extend $PATH to expose the binaries, and more. In general, Zinit has many hooks which allow surprising things, however their content often evolves to a gradually better and better one and it's hard to keep track of the current version of them. So a solution appeared: why not publish a package at GitHub with the plugin configurations (i.e.: ice-mod lists) stored in a file?","title":"Motivation"},{"location":"Zinit-Packages/#introductory_example","text":"This way, instead of the following command used to install fzf : zinit lucid as=program pick=\"$ZPFX/bin/(fzf|fzf-tmux)\" \\ atclone=\"cp shell/completion.zsh _fzf_completion; \\ cp bin/(fzf|fzf-tmux) $ZPFX/bin\" \\ make=\"PREFIX=$ZPFX install\" for \\ junegunn/fzf you only need: zinit pack for fzf to get the complete setup of the fuzzy finder, including: the completion, the additional executable-script fzf-tmux . The installation is real, package-manager -like, because you don't need to invoke Zinit anymore once installed to use fzf (that's because fzf is just a binary program and not e.g.: a shell function). You can also update the package with zinit update fzf \u2013 it'll cause the project to refresh and rebuild, like with a \"normal\" package manager such as apt-get . However, it'll actually be more like to emerge from Gentoo, because the installation will be from the source\u2026 unless\u2026 the user will pick up a binary installation by profile-argument specified in the pack'' ice :)","title":"Introductory Example"},{"location":"Zinit-Packages/#pros_of_using_zinit_package_for_regular_software_installations","text":"Using Zinit to install software where one could use a regular package manager has several advantages: Pro: The Zinit packages typically use the URLs to the official and latest distributions of the software (like e.g.: the ecs-cli package, which uses the URL: https://amazon-ecs-cli.s3.amazonaws.com/ecs-cli-linux-amd64-latest when installing on Linux). Pro: You can influence the installation easily by specifying Zinit ice-mods, e.g.: zinit pack=bgn atclone=\"cp fzy.1 $ZPFX/man/man1\" for fzy to install also the man page for the fzy fuzzy finder (this omission in the package will be fixed soon). Pro: The installation is much more flexible than a normal package manager. Example available degrees of freedom: to install from Git or from release-tarball, or from binary-release file, to install via shims or via extending $PATH , or by copying to $ZPFX/bin , to download files and apply patches to the source by using the Patch-Dl annex features. Pro: The installations are located in the user home directory, which doesn't require root access. Also, for Gems and Node modules, they are installed in their plugin directory, which can have advantages (e.g.: isolation allowing e.g: easy removal by rm -rf \u2026 ). Con: You're somewhat \"on your own\", with no support from any package maintainer. Thus, summing up 1. with 4., it might be nice/convenient to, for example, have the latest ECS CLI binary installed in the home directory, without using root access and always the latest, and \u2013 summing up with 2. and 3. \u2013 to, for example, have always the latest README downloaded by an additional ice: dl'https://raw.githubusercontent.com/aws/amazon-ecs-cli/master/README.md' (and then to have the README converted into a man page by the remark Markdown processor or other via an atclone'' ice, as the tool doesn't have any official man page).","title":"Pros Of Using Zinit Package For Regular Software Installations"},{"location":"Zinit-Packages/#the_z-shell_organization","text":"The home for the packages is Z-Shell GitHub organization. You can find the available packages here , which as of 2021-11-11 include: any-node - Special package \u2013 it is designed for easy installing of any Node modules inside the plugin directory. any-gem \u2013 Special package \u2013 it is designed for easy installing of any Ruby Gems locally inside the plugin directory. apr \u2013 Provides apache/apr library by compiling and installing it to the $ZPFX/bin . fzf - Fuzzy finder via Makefile installation of the junegunn/fzf binary under $ZPFX/bin . fzy \u2013 Fuzzy finder via Makefile-installation of the jhawthorn/fzy binary under $ZPFX/bin . pyenv \u2013 Provides pyenv/pyenv ** version manager command by extending $PATH to make it point into the bin subdirectory of the plugin. remark - Provides the CLI command for remarkjs/remark with two plugins: Man, HTML doctoc \u2013 Provides the thlorenz/doctoc CLI command. ls_colors \u2013 Provides the trapd00r/LS_COLORS and setups a zsh-completion system to use the definitions with: GNU 'ls', ogham/exa ' dircolors-material \u2013 The package provides the zpm-zsh/dircolors-material definitions and also setups zsh-completion system to use the definitions with: GNU 'ls', ' ogham/exa ' asciidoctor \u2013 Provides the CLI command for asciidoctor **. zsh-system-completions \u2013 A package that brings stock Zsh completions under the control of Zinit. ecs-cli \u2013 Provides the command for Amazon ecs-cli ** by copying it to $ZPFX/bin . subversion \u2013 Provides the apache/subversion ** revision control system by compiling and installing it to the $ZPFX/bin . github-issues \u2013 Zinit invocations that'll install z-shell/zsh-github-issues. github-issues-srv - The package is the puller-thread service for the z-shell/zsh-github-issues plugin. It runs the background service that downloads the new issues from GitHub. firefox-dev - Provides the CLI commands firefox-bin and firefox by extending the $PATH/bin . zsh - Builds and installs the newest zsh-users/zsh .","title":"The Z-Shell Organization"},{"location":"Zinit-Packages/#adding_your_own_package","text":"Contact the author to have the repository at z-shell organization. Populate the package.json \u2013 I suggest grabbing the one for fzf or doctoc and doing a few substitutions like doctoc \u2192 your-project and then simply filling the default profile in the zinit-ices object \u2013 it's obvious how to do this. The project name in the package.json should start with zsh- . The prefix will be skipped when specifying it with Zinit. Commit and push. That's all!","title":"Adding Your Own Package"},{"location":"Zplugin-Packages/","text":"Zinit Packages # Introduction # Zinit can install from so-called packages \u2013 GitHub repositories holding a package.json file with the Zinit meta-data in them. This way you don't have to (but still can) specify ices, which might be handy when the ice-mod list is long and complex. Motivation # The motivation for adding such functionality was: Zinit is a very flexible plugin manager however users often feel overwhelmed by its configuration. It has many package-manager -like features, such as: it can run Makefiles , automatically provide shims (i.e.: forwarder scripts) for the binaries, extend $PATH to expose the binaries, and more. In general, Zinit has many hooks which allow surprising and beautiful things, however their content often evolves to a gradually better and better one and it's hard to keep track of the current version of them. So a solution came up : why not publish a package at GitHub with the plugin configurations (i.e.: ice-mods) stored in an NPM package-resembling package.json file? Introductory Example # This way, instead of the following command used to install fzf : zinit lucid as=program pick=\"$ZPFX/bin/(fzf|fzf-tmux)\" \\ atclone=\"cp shell/completion.zsh _fzf_completion; \\ cp bin/(fzf|fzf-tmux) $ZPFX/bin\" \\ make=\"PREFIX=$ZPFX install\" for \\ junegunn/fzf you only need: zinit pack for fzf to get the complete setup of the fuzzy finder, including: the completion, the additional executable-script fzf-tmux . The installation is real, package-manager -like, because you don't need to invoke Zinit anymore once installed to use fzf (that's because fzf is just a binary program and not e.g.: a shell function). You can also update the package with zinit update fzf \u2013 it'll cause the project to refresh and rebuild, like with a \"normal\" package manager such as apt-get . However, it'll actually be more like to emerge from Gentoo, because the installation will be from the source\u2026 unless\u2026 you'll pick a binary installation :) So Zinit is like apt-get and emerge in one! Pros Of Using Zinit Package For Regular Software Installations # Using Zinit to install software where one could use a regular package manager has several advantages: Pro: The Zinit packages typically use the URLs to the official and latest distributions of the software (like e.g.: the ecs-cli package, which uses the URL: https://amazon-ecs-cli.s3.amazonaws.com/ecs-cli-linux-amd64-latest when installing on Linux). Pro: You can influence the installation easily by specifying Zinit ice-mods, e.g.: zinit pack=bgn atclone=\"cp fzy.1 $ZPFX/man/man1\" for fzy to install also the man page for the fzy fuzzy finder (this omission in the package will be fixed soon). Pro: The installation is much more flexible than a normal package manager. Example available degrees of freedom: to install from Git or from release-tarball, or from binary-release file, to install via shims or via extending $PATH , or by copying to $ZPFX/bin , to download files and apply patches to the source by using the Patch-Dl annex features. Pro: The installations are located in the user home directory, which doesn't require root access. Also, for Gems and Node modules, they are installed in their plugin directory, which can have advantages (e.g.: isolation allowing e.g: easy removal by rm -rf \u2026 ). Con: You're somewhat \"on your own\", with no support from any package maintainer. Thus, summing up 1. with 4., it might be nice/convenient to, for example, have the latest ECS CLI binary installed in the home directory, without using root access and always the latest, and \u2013 summing up with 2. and 3. \u2013 to, for example, have always the latest README downloaded by an additional ice: dl'https://raw.githubusercontent.com/aws/amazon-ecs-cli/master/README.md' (and then to have the README converted into a man page by the remark Markdown processor or other via an atclone'' ice, as the tool doesn't have any official man page). The Zsh-Packages Organization # The home for the packages is Zsh-Packages GitHub organization. You can find the available packages there, which as of 2019-12-11 include: asciidoctor \u2013 the AsciiDoc converter, installed as a Gem locally in the plugin directory with use of the Bin-Gem-Node annex, doctoc \u2013 the TOC (table of contents) generator for Markdown documents, installed as a Node package locally in the plugin directory with use of the Bin-Gem-Node annex, ecs-cli \u2013 the Amazon ECS command line tool, downloaded directly from the URL (or from the URL for OS X \u2013 automatically selected), firefox-dev \u2013 Firefox Developer Edition, downloaded from the URL (or from the URL for OS X; the OS X installation only downloads the dmg image, so it is'nt yet complete), fzf \u2013 the fuzzy-finder, installed from source (from a tarball or Git) or from the GitHub-releases binary, ls_colors \u2013 the trapd00r/LS_COLORS color definitions for GNU ls , ogham/exa and Zshell's completion. Adding Your Own Package # Contact me to have the repository at Zsh-Packages organization. Populate the package.json \u2013 I suggest grabbing the one for fzf or doctoc and doing a few substitutions like doctoc \u2192 your-project and then simply filling the default profile in the zinit-ices object \u2013 it's obvious how to do this. The project name in the package.json should start with zsh- . The prefix will be skipped when specifying it with Zinit. Commit and push. That's all!","title":"Zinit Packages"},{"location":"Zplugin-Packages/#zinit_packages","text":"","title":"Zinit Packages"},{"location":"Zplugin-Packages/#introduction","text":"Zinit can install from so-called packages \u2013 GitHub repositories holding a package.json file with the Zinit meta-data in them. This way you don't have to (but still can) specify ices, which might be handy when the ice-mod list is long and complex.","title":"Introduction"},{"location":"Zplugin-Packages/#motivation","text":"The motivation for adding such functionality was: Zinit is a very flexible plugin manager however users often feel overwhelmed by its configuration. It has many package-manager -like features, such as: it can run Makefiles , automatically provide shims (i.e.: forwarder scripts) for the binaries, extend $PATH to expose the binaries, and more. In general, Zinit has many hooks which allow surprising and beautiful things, however their content often evolves to a gradually better and better one and it's hard to keep track of the current version of them. So a solution came up : why not publish a package at GitHub with the plugin configurations (i.e.: ice-mods) stored in an NPM package-resembling package.json file?","title":"Motivation"},{"location":"Zplugin-Packages/#introductory_example","text":"This way, instead of the following command used to install fzf : zinit lucid as=program pick=\"$ZPFX/bin/(fzf|fzf-tmux)\" \\ atclone=\"cp shell/completion.zsh _fzf_completion; \\ cp bin/(fzf|fzf-tmux) $ZPFX/bin\" \\ make=\"PREFIX=$ZPFX install\" for \\ junegunn/fzf you only need: zinit pack for fzf to get the complete setup of the fuzzy finder, including: the completion, the additional executable-script fzf-tmux . The installation is real, package-manager -like, because you don't need to invoke Zinit anymore once installed to use fzf (that's because fzf is just a binary program and not e.g.: a shell function). You can also update the package with zinit update fzf \u2013 it'll cause the project to refresh and rebuild, like with a \"normal\" package manager such as apt-get . However, it'll actually be more like to emerge from Gentoo, because the installation will be from the source\u2026 unless\u2026 you'll pick a binary installation :) So Zinit is like apt-get and emerge in one!","title":"Introductory Example"},{"location":"Zplugin-Packages/#pros_of_using_zinit_package_for_regular_software_installations","text":"Using Zinit to install software where one could use a regular package manager has several advantages: Pro: The Zinit packages typically use the URLs to the official and latest distributions of the software (like e.g.: the ecs-cli package, which uses the URL: https://amazon-ecs-cli.s3.amazonaws.com/ecs-cli-linux-amd64-latest when installing on Linux). Pro: You can influence the installation easily by specifying Zinit ice-mods, e.g.: zinit pack=bgn atclone=\"cp fzy.1 $ZPFX/man/man1\" for fzy to install also the man page for the fzy fuzzy finder (this omission in the package will be fixed soon). Pro: The installation is much more flexible than a normal package manager. Example available degrees of freedom: to install from Git or from release-tarball, or from binary-release file, to install via shims or via extending $PATH , or by copying to $ZPFX/bin , to download files and apply patches to the source by using the Patch-Dl annex features. Pro: The installations are located in the user home directory, which doesn't require root access. Also, for Gems and Node modules, they are installed in their plugin directory, which can have advantages (e.g.: isolation allowing e.g: easy removal by rm -rf \u2026 ). Con: You're somewhat \"on your own\", with no support from any package maintainer. Thus, summing up 1. with 4., it might be nice/convenient to, for example, have the latest ECS CLI binary installed in the home directory, without using root access and always the latest, and \u2013 summing up with 2. and 3. \u2013 to, for example, have always the latest README downloaded by an additional ice: dl'https://raw.githubusercontent.com/aws/amazon-ecs-cli/master/README.md' (and then to have the README converted into a man page by the remark Markdown processor or other via an atclone'' ice, as the tool doesn't have any official man page).","title":"Pros Of Using Zinit Package For Regular Software Installations"},{"location":"Zplugin-Packages/#the_zsh-packages_organization","text":"The home for the packages is Zsh-Packages GitHub organization. You can find the available packages there, which as of 2019-12-11 include: asciidoctor \u2013 the AsciiDoc converter, installed as a Gem locally in the plugin directory with use of the Bin-Gem-Node annex, doctoc \u2013 the TOC (table of contents) generator for Markdown documents, installed as a Node package locally in the plugin directory with use of the Bin-Gem-Node annex, ecs-cli \u2013 the Amazon ECS command line tool, downloaded directly from the URL (or from the URL for OS X \u2013 automatically selected), firefox-dev \u2013 Firefox Developer Edition, downloaded from the URL (or from the URL for OS X; the OS X installation only downloads the dmg image, so it is'nt yet complete), fzf \u2013 the fuzzy-finder, installed from source (from a tarball or Git) or from the GitHub-releases binary, ls_colors \u2013 the trapd00r/LS_COLORS color definitions for GNU ls , ogham/exa and Zshell's completion.","title":"The Zsh-Packages Organization"},{"location":"Zplugin-Packages/#adding_your_own_package","text":"Contact me to have the repository at Zsh-Packages organization. Populate the package.json \u2013 I suggest grabbing the one for fzf or doctoc and doing a few substitutions like doctoc \u2192 your-project and then simply filling the default profile in the zinit-ices object \u2013 it's obvious how to do this. The project name in the package.json should start with zsh- . The prefix will be skipped when specifying it with Zinit. Commit and push. That's all!","title":"Adding Your Own Package"},{"location":"atload-and-other-at-ices/","text":"The atload Ice (and other at\u2026 ices) # Introduction # There are four code-receiving ices: atclone , atpull , atinit , atload . Their role is to receive a portion of Zsh code and execute it in certain moments of the plugin life-cycle . The atclone executes it: after cloning the associated plugin or snippet to the disk. The atpull is similar, but works: after updating the associated plugin or snippet. Next, atinit works similar, but is being activated: before loading of the associated plugin or snippet. Last, atload is being activated: after loading of the associated plugin or snippet. For convenience, you can use each of the ices multiple times in single zinit ice \u2026 invocation \u2013 all the passed commands will be executed in the given order. The atpull ice recognizes a special value: %atclone (so the code looks i.e.: atpull'%atclone' ). It causes the contents of the atclone ice to be copied into the contents of the atpull ice. This is handy when the same tasks have to be performed on clone and on update of plugin or snippet, like e.g.: in the Direnv example . Exclamation mark -preceded atload # The wrap-track ice allows to track and unload plugins that defer their initialization into a function run later after sourcing the plugin's script \u2013 when the function is called, the plugin is then being fully initialized. However, if the function is being called from the atload ice, then there is a simpler method than the wrap-track ice \u2013 an exclamation mark -preceded atload contents. The exclamation mark causes the effects of the execution of the code passed to atload ice to be recorded. Example # For example, in the following invocation: zinit ice id-as'test' atload'!PATH+=:~/share' zinit load z-shell/null the $PATH is being changed within atload ice. Zinit's tracking records $PATH changes and withdraws them on plugin unload, and also shows information loading: $ zplg report test Report for test plugin ---------------------- Source (reporting enabled) PATH elements added: /home/sg/share As it can be seen, the atload code is being correctly tracked and can be unloaded & viewed. Below is the result of using the unload subcommand to unload the test plugin: $ zinit unload test --- Unloading plugin: test --- Removing PATH element /home/sg/share Unregistering plugin test Plugin report saved to $LASTREPORT Practical example # The same example as in the Tracking precmd-based Plugins article, but using the exclamation mark -preceded atload instead of wrap-track : # Load when MYPROMPT == 4 zinit ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'!source ~/.p10k.zsh; _p9k_precmd' zinit load romkatv/powerlevel10k Summary # The creation of the four additional Zle-widgets will be recorded (see the article on wrap-track for more information) \u2013 the effect will be exactly the same as with the wrap-track ice. The widgets will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Tracking precmd-based Plugins (atload-and-other-at-ices)"},{"location":"atload-and-other-at-ices/#the_atload_ice_and_other_at_ices","text":"","title":"The atload Ice (and other at\u2026 ices)"},{"location":"atload-and-other-at-ices/#introduction","text":"There are four code-receiving ices: atclone , atpull , atinit , atload . Their role is to receive a portion of Zsh code and execute it in certain moments of the plugin life-cycle . The atclone executes it: after cloning the associated plugin or snippet to the disk. The atpull is similar, but works: after updating the associated plugin or snippet. Next, atinit works similar, but is being activated: before loading of the associated plugin or snippet. Last, atload is being activated: after loading of the associated plugin or snippet. For convenience, you can use each of the ices multiple times in single zinit ice \u2026 invocation \u2013 all the passed commands will be executed in the given order. The atpull ice recognizes a special value: %atclone (so the code looks i.e.: atpull'%atclone' ). It causes the contents of the atclone ice to be copied into the contents of the atpull ice. This is handy when the same tasks have to be performed on clone and on update of plugin or snippet, like e.g.: in the Direnv example .","title":"Introduction"},{"location":"atload-and-other-at-ices/#exclamation_mark-preceded_atload","text":"The wrap-track ice allows to track and unload plugins that defer their initialization into a function run later after sourcing the plugin's script \u2013 when the function is called, the plugin is then being fully initialized. However, if the function is being called from the atload ice, then there is a simpler method than the wrap-track ice \u2013 an exclamation mark -preceded atload contents. The exclamation mark causes the effects of the execution of the code passed to atload ice to be recorded.","title":"Exclamation mark-preceded atload"},{"location":"atload-and-other-at-ices/#example","text":"For example, in the following invocation: zinit ice id-as'test' atload'!PATH+=:~/share' zinit load z-shell/null the $PATH is being changed within atload ice. Zinit's tracking records $PATH changes and withdraws them on plugin unload, and also shows information loading: $ zplg report test Report for test plugin ---------------------- Source (reporting enabled) PATH elements added: /home/sg/share As it can be seen, the atload code is being correctly tracked and can be unloaded & viewed. Below is the result of using the unload subcommand to unload the test plugin: $ zinit unload test --- Unloading plugin: test --- Removing PATH element /home/sg/share Unregistering plugin test Plugin report saved to $LASTREPORT","title":"Example"},{"location":"atload-and-other-at-ices/#practical_example","text":"The same example as in the Tracking precmd-based Plugins article, but using the exclamation mark -preceded atload instead of wrap-track : # Load when MYPROMPT == 4 zinit ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'!source ~/.p10k.zsh; _p9k_precmd' zinit load romkatv/powerlevel10k","title":"Practical example"},{"location":"atload-and-other-at-ices/#summary","text":"The creation of the four additional Zle-widgets will be recorded (see the article on wrap-track for more information) \u2013 the effect will be exactly the same as with the wrap-track ice. The widgets will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Summary"},{"location":"crasis/","text":"Crasis \u2013 semigraphical interface to Zinit # Zsh exposes its parser via (z) substitution flag. Parsing .zshrc is totally possible. This way Crasis lets you edit your Zinit commands located in .zshrc . All in pure Zshell code. No more commenting-out a line with a text editor to disable plugin, cluttering .zshrc , now you can just press a button . Crasis uses pure-Zshell ZUI library to create ncurses interface. Installation & Basic Use # Install Zinit and add following commands to .zshrc : zinit light z-shell/zui zinit light z-shell/zinit-crasis To use, invoke crasis [optional zshrc path] or press Ctrl-o-k . Global variables CRASIS_THEME and CRASIS_LAYOUT can be used to override configuration file crasis.conf (located in plugin's tree), i.e.: CRASIS_THEME=\"zdharma-256\" CRASIS_LAYOUT=\"contract\" crasis 256 -color themes require Zsh 5.3 or later. Key Bindings # Key(s) Description < , > or { , } Horizontal scroll (i.e. left or right) Ctrl-L Redraw of whole display Ctrl-U Half page up Ctrl-D Half page down Ctrl-P Previous line, centered Ctrl-N Next line, centered [ , ] Jump to next and previous section (e.g. next plugin or snippet) g , G Jump to beginning and end of whole interface / Show incremental search F1 Jump to result (in incremental search) and back Esc Exit incremental search, clearing query Ctrl-W Delete whole word (in incremental search) Ctrl-K Delete whole line (in incremental search) Up and down Resize text field when editing it (e.g. to make the text fit in) Screenshots # Code Documentation # Crasis is a ZUI application. ZUI is a pure-Zshell library where user generates simple text with hyperlinks, which is then turned into active document with buttons. Check out Crasis code documentation: Asciidoc , PDF .","title":"Crasis"},{"location":"crasis/#crasis_semigraphical_interface_to_zinit","text":"Zsh exposes its parser via (z) substitution flag. Parsing .zshrc is totally possible. This way Crasis lets you edit your Zinit commands located in .zshrc . All in pure Zshell code. No more commenting-out a line with a text editor to disable plugin, cluttering .zshrc , now you can just press a button . Crasis uses pure-Zshell ZUI library to create ncurses interface.","title":"Crasis \u2013 semigraphical interface to Zinit"},{"location":"crasis/#installation_basic_use","text":"Install Zinit and add following commands to .zshrc : zinit light z-shell/zui zinit light z-shell/zinit-crasis To use, invoke crasis [optional zshrc path] or press Ctrl-o-k . Global variables CRASIS_THEME and CRASIS_LAYOUT can be used to override configuration file crasis.conf (located in plugin's tree), i.e.: CRASIS_THEME=\"zdharma-256\" CRASIS_LAYOUT=\"contract\" crasis 256 -color themes require Zsh 5.3 or later.","title":"Installation &amp; Basic Use"},{"location":"crasis/#key_bindings","text":"Key(s) Description < , > or { , } Horizontal scroll (i.e. left or right) Ctrl-L Redraw of whole display Ctrl-U Half page up Ctrl-D Half page down Ctrl-P Previous line, centered Ctrl-N Next line, centered [ , ] Jump to next and previous section (e.g. next plugin or snippet) g , G Jump to beginning and end of whole interface / Show incremental search F1 Jump to result (in incremental search) and back Esc Exit incremental search, clearing query Ctrl-W Delete whole word (in incremental search) Ctrl-K Delete whole line (in incremental search) Up and down Resize text field when editing it (e.g. to make the text fit in)","title":"Key Bindings"},{"location":"crasis/#screenshots","text":"","title":"Screenshots"},{"location":"crasis/#code_documentation","text":"Crasis is a ZUI application. ZUI is a pure-Zshell library where user generates simple text with hyperlinks, which is then turned into active document with buttons. Check out Crasis code documentation: Asciidoc , PDF .","title":"Code Documentation"},{"location":"declare-zsh/","text":"declare-zsh # declare-zsh is a parser for zinit commands in .zshrc . It allows to perform the following actions on .zshrc from the command-line : enable and disable selected plugins and snippets, add plugins and snippets, delete plugins and snippets. In other words, by issuing a declzsh command the user deploys a task of: Reading and parsing of the ~/.zshrc . Making changes (like removal of a plugin, i.e. of zinit load {removed-plugin} command together with the possible associated zinit ice \u2026 command) and then\u2026 Writing the result back to the zshrc (by default, the result is stored to ~/.zshrc_gen file for safety, but the author wants to emhasize very strongly, that breaking something within the parsed zshrc is nearly impossible and the tool can be safely used with option -o ~/.zshrc which points declzsh to the original zshrc as the destination, output file). Examples & Screenshots # Example disabling of a plugin via the toggle option -TT \u2013 this works because the commands preceded by : are ignored by the shell: Example addition of a plugin via the option -AA \u2013 in order to also set up ice modifiers enclose them in a preceding square-bracket block, i.e. declzsh -AA '[ wait\"1\" lucid ] z-shell/null' : Example deletion of a plugin via the purge option -PP \u2013 the argument is treated as pattern, pass * to delete all plugins and snippets!: Usage # Multiple actions, i.e. multiple options like -AA , -PP , -DD , etc. are possible in a single declzsh run.","title":"declare-zsh"},{"location":"declare-zsh/#declare-zsh","text":"declare-zsh is a parser for zinit commands in .zshrc . It allows to perform the following actions on .zshrc from the command-line : enable and disable selected plugins and snippets, add plugins and snippets, delete plugins and snippets. In other words, by issuing a declzsh command the user deploys a task of: Reading and parsing of the ~/.zshrc . Making changes (like removal of a plugin, i.e. of zinit load {removed-plugin} command together with the possible associated zinit ice \u2026 command) and then\u2026 Writing the result back to the zshrc (by default, the result is stored to ~/.zshrc_gen file for safety, but the author wants to emhasize very strongly, that breaking something within the parsed zshrc is nearly impossible and the tool can be safely used with option -o ~/.zshrc which points declzsh to the original zshrc as the destination, output file).","title":"declare-zsh"},{"location":"declare-zsh/#examples_screenshots","text":"Example disabling of a plugin via the toggle option -TT \u2013 this works because the commands preceded by : are ignored by the shell: Example addition of a plugin via the option -AA \u2013 in order to also set up ice modifiers enclose them in a preceding square-bracket block, i.e. declzsh -AA '[ wait\"1\" lucid ] z-shell/null' : Example deletion of a plugin via the purge option -PP \u2013 the argument is treated as pattern, pass * to delete all plugins and snippets!:","title":"Examples &amp; Screenshots"},{"location":"declare-zsh/#usage","text":"Multiple actions, i.e. multiple options like -AA , -PP , -DD , etc. are possible in a single declzsh run.","title":"Usage"},{"location":"extract-Ice/","text":"The Automatic Archive-Extraction Ice-Tool # Zinit has a swiss-knife tool for unpacking all kinds of archives \u2013 the extract'' ice. It works in two modes \u2013 automatic mode and fixed mode. Automatic Mode # It is active if the ice is empty (or contains only flags \u2013 more on them later). It works as follows: At first, a recursive search for files of known file extensions located not deeper than in a sub-directory is being performed. All such found files are then extracted. The directory-level limit is to skip extraction of some helper archive files, which are typically located somewhere deeper in the directory tree. IF no such files will be found, then a recursive search for files of known archive types will be performed. This is basically done by running the file Unix command on each file in the plugin or snippet directory and then grepping the output for strings like Zip , bzip2 , etc. All such discovered files are then extracted. The directory-level requirement is imposed also during this stage - files located deeper in the tree than in a sub-directory are omitted. If no archive files will be discovered then no action is being performed and also no warning message is being printed. Fixed Mode # It is active when a filename is being passed as the extract 's argument, e.g.: zinit extract=archive.zip for z-shell/null . Multiple files can be specified \u2013 separated by spaces. In this mode all and only the specified files are being extracted. Filenames With Spaces # The filenames with spaces in them are supported by a trick \u2013 to correctly pass such a filename to extract use the non-breaking space in place of the in-filename original spaces. The non-breaking space is easy to type by pressing right Alt and the Space. Flags # The value of the ice can begin with a two special characters: Exclamation mark ( ! ), i.e.: extract='!\u2026' \u2013 it'll cause the files to be moved one directory-level up upon unpacking, Dash ( - ), i.e.: extract'-\u2026' \u2013 it'll prevent removal of the archive after unpacking. This flag is useful to allow comparing timestamps with the server in case of snippet-downloaded file \u2013 it will prevent unnecessary downloads during zinit update , as the timestamp of the archive file on the disk will be first compared with the HTTP last-modification time header. The flags can be combined in any order, e.g.: extract'!-' . ziextract Function # Sometimes a more uncommon unpacking operation is needed. In such case you can directly use the function that implements the ice \u2013 it is called ziextract . It recognizes the following options: --auto \u2013 runs the automatic extraction. --move \u2013 performs the one-directory-level-up move of the files after unpacking. --norm - prevents the archive file removal. And also one option specific only to the function: --nobkp , which prevents clearing of the plugin's dir before the extraction \u2013 normally all the files except the archive are being moved into ._backup directory and after that the extraction is performed. extract ice also skips creating the backup if more than one archive is found or given as the argument. Supported File Formats # Zip, RAR, tar.gz, tar.bz2, tar.xz, tar.7z, tar, gz, bz2, xz, 7z, OS X dmg images .","title":"extract Ice"},{"location":"extract-Ice/#the_automatic_archive-extraction_ice-tool","text":"Zinit has a swiss-knife tool for unpacking all kinds of archives \u2013 the extract'' ice. It works in two modes \u2013 automatic mode and fixed mode.","title":"The Automatic Archive-Extraction Ice-Tool"},{"location":"extract-Ice/#automatic_mode","text":"It is active if the ice is empty (or contains only flags \u2013 more on them later). It works as follows: At first, a recursive search for files of known file extensions located not deeper than in a sub-directory is being performed. All such found files are then extracted. The directory-level limit is to skip extraction of some helper archive files, which are typically located somewhere deeper in the directory tree. IF no such files will be found, then a recursive search for files of known archive types will be performed. This is basically done by running the file Unix command on each file in the plugin or snippet directory and then grepping the output for strings like Zip , bzip2 , etc. All such discovered files are then extracted. The directory-level requirement is imposed also during this stage - files located deeper in the tree than in a sub-directory are omitted. If no archive files will be discovered then no action is being performed and also no warning message is being printed.","title":"Automatic Mode"},{"location":"extract-Ice/#fixed_mode","text":"It is active when a filename is being passed as the extract 's argument, e.g.: zinit extract=archive.zip for z-shell/null . Multiple files can be specified \u2013 separated by spaces. In this mode all and only the specified files are being extracted.","title":"Fixed Mode"},{"location":"extract-Ice/#filenames_with_spaces","text":"The filenames with spaces in them are supported by a trick \u2013 to correctly pass such a filename to extract use the non-breaking space in place of the in-filename original spaces. The non-breaking space is easy to type by pressing right Alt and the Space.","title":"Filenames With Spaces"},{"location":"extract-Ice/#flags","text":"The value of the ice can begin with a two special characters: Exclamation mark ( ! ), i.e.: extract='!\u2026' \u2013 it'll cause the files to be moved one directory-level up upon unpacking, Dash ( - ), i.e.: extract'-\u2026' \u2013 it'll prevent removal of the archive after unpacking. This flag is useful to allow comparing timestamps with the server in case of snippet-downloaded file \u2013 it will prevent unnecessary downloads during zinit update , as the timestamp of the archive file on the disk will be first compared with the HTTP last-modification time header. The flags can be combined in any order, e.g.: extract'!-' .","title":"Flags"},{"location":"extract-Ice/#ziextract_function","text":"Sometimes a more uncommon unpacking operation is needed. In such case you can directly use the function that implements the ice \u2013 it is called ziextract . It recognizes the following options: --auto \u2013 runs the automatic extraction. --move \u2013 performs the one-directory-level-up move of the files after unpacking. --norm - prevents the archive file removal. And also one option specific only to the function: --nobkp , which prevents clearing of the plugin's dir before the extraction \u2013 normally all the files except the archive are being moved into ._backup directory and after that the extraction is performed. extract ice also skips creating the backup if more than one archive is found or given as the argument.","title":"ziextract Function"},{"location":"extract-Ice/#supported_file_formats","text":"Zip, RAR, tar.gz, tar.bz2, tar.xz, tar.7z, tar, gz, bz2, xz, 7z, OS X dmg images .","title":"Supported File Formats"},{"location":"fsh-auto-themes/","text":"fsh-auto-themes # Introduction # In-short, fsh-auto-themes is a plugin that implements Zshell per-directory themes for z-shell/fast-syntax-highlighting , i.e.: for a plugin that applies colors to the commands you type in the shell, (see a screenshot ). With fsh-auto-themes you'll be able to switch the FSH theme at the moment of entering a particular directory. Operation # This plugin activates after changing current directory in the shell session. It then searches for .fsh-theme file in that new directory or in any upper directory. Example .fsh-theme file contents: q-jmnemonic First line : a name of a theme or a path to a theme. The path can use the shorthands supported by fast-theme , e.g.: XDG:x-paragon will point to the file ~/.config/fsh/x-paragon.ini (unless the $XDG_CONFIG_HOME is being set to different directory than ~/.config ). See fast-theme --help for more information and other shorthands. Second line : a name or a path of an overlay (an overlay is a theme-like file that overwrites every theme's settings; you can use it to impose your own customizations over any theme). The plugin will switch current theme to the one in the file and also apply the overlay found in the file. One of the lines can be empty. If .fsh-theme will not be found, the default theme (the one currently set with the fast-theme tool) will be restored. Example # Example operation of the plugin: Installation # Example z-shell/zinit invocation: zinit ice from\"<USERNAME>@github.com\" zinit light z-shell/fsh-auto-themes With Turbo Mode : zinit ice wait'1' lucid from\"<USERNAME>@github.com\" zinit light z-shell/fsh-auto-themes","title":"fsh-auto-themes"},{"location":"fsh-auto-themes/#fsh-auto-themes","text":"","title":"fsh-auto-themes"},{"location":"fsh-auto-themes/#introduction","text":"In-short, fsh-auto-themes is a plugin that implements Zshell per-directory themes for z-shell/fast-syntax-highlighting , i.e.: for a plugin that applies colors to the commands you type in the shell, (see a screenshot ). With fsh-auto-themes you'll be able to switch the FSH theme at the moment of entering a particular directory.","title":"Introduction"},{"location":"fsh-auto-themes/#operation","text":"This plugin activates after changing current directory in the shell session. It then searches for .fsh-theme file in that new directory or in any upper directory. Example .fsh-theme file contents: q-jmnemonic First line : a name of a theme or a path to a theme. The path can use the shorthands supported by fast-theme , e.g.: XDG:x-paragon will point to the file ~/.config/fsh/x-paragon.ini (unless the $XDG_CONFIG_HOME is being set to different directory than ~/.config ). See fast-theme --help for more information and other shorthands. Second line : a name or a path of an overlay (an overlay is a theme-like file that overwrites every theme's settings; you can use it to impose your own customizations over any theme). The plugin will switch current theme to the one in the file and also apply the overlay found in the file. One of the lines can be empty. If .fsh-theme will not be found, the default theme (the one currently set with the fast-theme tool) will be restored.","title":"Operation"},{"location":"fsh-auto-themes/#example","text":"Example operation of the plugin:","title":"Example"},{"location":"fsh-auto-themes/#installation","text":"Example z-shell/zinit invocation: zinit ice from\"<USERNAME>@github.com\" zinit light z-shell/fsh-auto-themes With Turbo Mode : zinit ice wait'1' lucid from\"<USERNAME>@github.com\" zinit light z-shell/fsh-auto-themes","title":"Installation"},{"location":"id-as/","text":"Nickname a plugin or snippet # Introduction # Zinit supports loading a plugin or snippet with a nickname. Set the nickname through the id-as ice-mod. For example, one could try to load docker/compose from GitHub binary releases: zinit ice as\"program\" from\"gh-r\" mv\"docker-c* -> docker-compose\" zinit light \"docker/compose\" This registers plugin under the ID docker/compose . Now suppose the user would want to also load a completion from the project's GitHub repository (not the binary release catalog) which is also available under the GitHub url-path \u2026/docker/compose . The two IDs, both being \"docker/compose\", will collide. The solution to this problem \u2013 the id-as (to be read as: identify-as ) ice to which this document is devoted: by using the id-as ice the user can resolve the conflict by loading the completion under a kind of a nickname , for example under \" dc-complete \", by issuing the following commands: zinit ice as\"completion\" id-as\"dc-complete\" zinit load docker/compose The plugin (of the type completion ) is now seen under ID dc-complete : ~ zinit list | grep -i dc-complete dc-complete Issuing zinit report dc-complete also works, so as other Zinit commands: ~ zinit report dc-complete Plugin report for dc-complete ------------------------------- Completions: _docker-compose [enabled] This can be also used to nickname snippets. For example, you can use this to create handy IDs in place of long urls: zinit ice as\"program\" id-as\"git-unique\" zinit snippet https://github.com/Osse/git-scripts/blob/master/git-unique The commands zinit update git-unique , zinit delete git-unique and other will work normally and e.g. zinit times will show the nickname -ID git-unique instead of the long URL. id-as'auto' # There's a special value to the id-as'' ice \u2013 auto . It causes the nickname to be automatically set to the last component of the plugin name or snippet URL. For example: zinit ice as\"program\" id-as\"auto\" zinit snippet https://github.com/Osse/git-scripts/blob/master/git-unique will work the same as before, i.e.: like if the ice used was id-as'git-unique' . Example with a plugin: # Will work as if id-as'zsh-autopair' was passed zinit ice wait lucid id-as\"auto\" zinit load hlissner/zsh-autopair Empty id-as'' # An empty id-as'' will work the same as id-as'auto' , i.e.: # Will work as if id-as'zsh-autopair' was passed zinit ice wait lucid id-as zinit load hlissner/zsh-autopair","title":"Nickname a Plugin or Snippet"},{"location":"id-as/#nickname_a_plugin_or_snippet","text":"","title":"Nickname a plugin or snippet"},{"location":"id-as/#introduction","text":"Zinit supports loading a plugin or snippet with a nickname. Set the nickname through the id-as ice-mod. For example, one could try to load docker/compose from GitHub binary releases: zinit ice as\"program\" from\"gh-r\" mv\"docker-c* -> docker-compose\" zinit light \"docker/compose\" This registers plugin under the ID docker/compose . Now suppose the user would want to also load a completion from the project's GitHub repository (not the binary release catalog) which is also available under the GitHub url-path \u2026/docker/compose . The two IDs, both being \"docker/compose\", will collide. The solution to this problem \u2013 the id-as (to be read as: identify-as ) ice to which this document is devoted: by using the id-as ice the user can resolve the conflict by loading the completion under a kind of a nickname , for example under \" dc-complete \", by issuing the following commands: zinit ice as\"completion\" id-as\"dc-complete\" zinit load docker/compose The plugin (of the type completion ) is now seen under ID dc-complete : ~ zinit list | grep -i dc-complete dc-complete Issuing zinit report dc-complete also works, so as other Zinit commands: ~ zinit report dc-complete Plugin report for dc-complete ------------------------------- Completions: _docker-compose [enabled] This can be also used to nickname snippets. For example, you can use this to create handy IDs in place of long urls: zinit ice as\"program\" id-as\"git-unique\" zinit snippet https://github.com/Osse/git-scripts/blob/master/git-unique The commands zinit update git-unique , zinit delete git-unique and other will work normally and e.g. zinit times will show the nickname -ID git-unique instead of the long URL.","title":"Introduction"},{"location":"id-as/#id-asauto","text":"There's a special value to the id-as'' ice \u2013 auto . It causes the nickname to be automatically set to the last component of the plugin name or snippet URL. For example: zinit ice as\"program\" id-as\"auto\" zinit snippet https://github.com/Osse/git-scripts/blob/master/git-unique will work the same as before, i.e.: like if the ice used was id-as'git-unique' . Example with a plugin: # Will work as if id-as'zsh-autopair' was passed zinit ice wait lucid id-as\"auto\" zinit load hlissner/zsh-autopair","title":"id-as'auto'"},{"location":"id-as/#empty_id-as","text":"An empty id-as'' will work the same as id-as'auto' , i.e.: # Will work as if id-as'zsh-autopair' was passed zinit ice wait lucid id-as zinit load hlissner/zsh-autopair","title":"Empty id-as''"},{"location":"preinstalling-plugins/","text":"Pre-installing Plugins # If you create a Docker image that uses Zinit, or want to install Turbo-loaded plugins before the shell starts interactively, you can invoke the zplugin-scheduler function in such a way, that it: installs plugins without waiting for the prompt (i.e. it's script friendly), installs all plugins instantly, without respecting the wait'' argument. To accomplish this, use burst argument and call -zplg-scheduler function. Example Dockerfile entry: RUN zsh -i -c -- '-zplg-scheduler burst || true' An example Dockerfile can be found here .","title":"Pre-installing Plugins"},{"location":"preinstalling-plugins/#pre-installing_plugins","text":"If you create a Docker image that uses Zinit, or want to install Turbo-loaded plugins before the shell starts interactively, you can invoke the zplugin-scheduler function in such a way, that it: installs plugins without waiting for the prompt (i.e. it's script friendly), installs all plugins instantly, without respecting the wait'' argument. To accomplish this, use burst argument and call -zplg-scheduler function. Example Dockerfile entry: RUN zsh -i -c -- '-zplg-scheduler burst || true' An example Dockerfile can be found here .","title":"Pre-installing Plugins"},{"location":"wrap-track/","text":"The wrap-track Ice # The wrap-track ice-mod allows to extend the tracking (i.e. gathering of report and unload data) of a plugin beyond the moment of sourcing it's main file(s). It works by wrapping the given functions with a tracking-enabling and disabling snippet of code. This is useful especially with prompts, as they very often do their initialization in the first call to their precmd hook function. For example, romkatv/powerlevel10k works this way. The ice takes a list of function names, with the elements separated by ; : zinit ice wrap-track\"func1;func2;\u2026\" \u2026 \u2026 Example # Therefore, to e.g. load and unload the example powerlevel10k prompt in the fashion of Multiple prompts article, the precmd function of the plugin \u2013 called _p9k_precmd (to get the name of the function do echo $precmd_functions after loading a theme) \u2013 should be passed to wrap-track'' ice, like so: # Load when MYPROMPT == 4 zinit ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'source ~/.p10k.zsh; _p9k_precmd' wrap-track'_p9k_precmd' zinit load romkatv/powerlevel10k This way the actions done during the first call to _p9k_precmd() will be normally recorded, which can be viewed in the report of the romkatv/powerlevel10k theme: ~ zplg report romkatv/powerlevel10k: Report for romkatv/powerlevel10k plugin --------------------------------------- Source powerlevel10k.zsh-theme (reporting enabled) Autoload is-at-least with options -U -z (\u2026) Note: === Starting to track function: _p9k_precmd === Zle -N p9k-orig-zle-line-finish _zsh_highlight_widget_zle-line-finish Note: a new widget created via zle -N: p9k-orig-zle-line-finish Zle -N -- zle-line-finish _p9k_wrapper__p9k_zle_line_finish Autoload vcs_info with options -U -z Zstyle :vcs_info:* check-for-changes true (\u2026) Zstyle :vcs_info:* get-revision false Autoload add-zsh-hook with options -U -z Zle -F 22_gitstatus_process_response_POWERLEVEL9K Autoload_gitstatus_cleanup_15877_0_16212 Zle -N -- zle-line-pre-redraw _p9k_wrapper__p9k_zle_line_pre_redraw Note: a new widget created via zle -N: zle-line-pre-redraw Zle -N -- zle-keymap-select _p9k_wrapper__p9k_zle_keymap_select Note: === Ended tracking function:_p9k_precmd === Functions created: +vi-git-aheadbehind +vi-git-remotebranch (\u2026) Summary # As it can be seen, creation of four additional Zle-widgets has been recorded (the Zle -N \u2026 lines). They will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Tracking precmd-based Plugins (wrap-track)"},{"location":"wrap-track/#the_wrap-track_ice","text":"The wrap-track ice-mod allows to extend the tracking (i.e. gathering of report and unload data) of a plugin beyond the moment of sourcing it's main file(s). It works by wrapping the given functions with a tracking-enabling and disabling snippet of code. This is useful especially with prompts, as they very often do their initialization in the first call to their precmd hook function. For example, romkatv/powerlevel10k works this way. The ice takes a list of function names, with the elements separated by ; : zinit ice wrap-track\"func1;func2;\u2026\" \u2026 \u2026","title":"The wrap-track Ice"},{"location":"wrap-track/#example","text":"Therefore, to e.g. load and unload the example powerlevel10k prompt in the fashion of Multiple prompts article, the precmd function of the plugin \u2013 called _p9k_precmd (to get the name of the function do echo $precmd_functions after loading a theme) \u2013 should be passed to wrap-track'' ice, like so: # Load when MYPROMPT == 4 zinit ice load'![[ $MYPROMPT = 4 ]]' unload'![[ $MYPROMPT != 4 ]]' \\ atload'source ~/.p10k.zsh; _p9k_precmd' wrap-track'_p9k_precmd' zinit load romkatv/powerlevel10k This way the actions done during the first call to _p9k_precmd() will be normally recorded, which can be viewed in the report of the romkatv/powerlevel10k theme: ~ zplg report romkatv/powerlevel10k: Report for romkatv/powerlevel10k plugin --------------------------------------- Source powerlevel10k.zsh-theme (reporting enabled) Autoload is-at-least with options -U -z (\u2026) Note: === Starting to track function: _p9k_precmd === Zle -N p9k-orig-zle-line-finish _zsh_highlight_widget_zle-line-finish Note: a new widget created via zle -N: p9k-orig-zle-line-finish Zle -N -- zle-line-finish _p9k_wrapper__p9k_zle_line_finish Autoload vcs_info with options -U -z Zstyle :vcs_info:* check-for-changes true (\u2026) Zstyle :vcs_info:* get-revision false Autoload add-zsh-hook with options -U -z Zle -F 22_gitstatus_process_response_POWERLEVEL9K Autoload_gitstatus_cleanup_15877_0_16212 Zle -N -- zle-line-pre-redraw _p9k_wrapper__p9k_zle_line_pre_redraw Note: a new widget created via zle -N: zle-line-pre-redraw Zle -N -- zle-keymap-select _p9k_wrapper__p9k_zle_keymap_select Note: === Ended tracking function:_p9k_precmd === Functions created: +vi-git-aheadbehind +vi-git-remotebranch (\u2026)","title":"Example"},{"location":"wrap-track/#summary","text":"As it can be seen, creation of four additional Zle-widgets has been recorded (the Zle -N \u2026 lines). They will be properly deleted/restored on the plugin unload with MYPROMPT=3 (for example) and the shell state will be clean, ready to load a new prompt.","title":"Summary"},{"location":"z-a-bin-gem-node/","text":"z-a-bin-gem-node # Introduction # A Zsh-Zinit annex (i.e. an extension) that provides functionality, which allows to: Run programs and scripts without adding anything to $PATH , Install and run Ruby gems and Node modules from within a local directory with \\$GEM_HOME and \\$NODE_PATH automatically set, Run programs, scripts and functions with automatic cd into the plugin or snippet directory, plus also with automatic standard output & standard error redirecting. Source scripts through an automatically created function with the above $GEM_HOME , $NODE_PATH and cd features available, Create the so called shims known from rbenv \u2013 the same feature as the first item of this enumaration \u2013 of running a program without adding anything to $PATH with all of the above features, however through an automatic script created in $ZPFX/bin , not a function (the first item uses a function-based mechanism), Automatic updates of Ruby gems and Node modules during regular plugin and snippet updates with zinit update \u2026 . Installation # Simply load like a regular plugin, i.e.: zinit light z-shell/z-a-bin-gem-node After executing this command you can then use the dl'' and patch'' ice-mods. How it works \u2013 bird's-eye view # Below is a diagram explaining the major feature \u2013 exposing a binary program or script through a Zsh function of the same name: This way there is no need to add anything to $PATH \u2013 z-a-bin-gem-node will automatically create a function that will wrap the binary and provide it on the command line like if it was being placed in the $PATH . Also, like mentioned in the enumeration, the function can automatically export $GEM_HOME , $NODE_PATH shell variables and also automatically cd into the plugin or snippet directory right before executing the binary and then cd back to the original directory after the execution is finished. Also, like already mentioned, instead of the function an automatically created script \u2013 so called shim \u2013 can be used for the same purpose and with the same functionality. How it works, in detail # Suppose that you would want to install junegunn/fzf-bin plugin from GitHub Releases, which contains only single file \u2013 the fzf binary for the selected architecture. It is possible to do it in the standard way \u2013 by adding the plugin's directory to the $PATH : zinit ice as\"command\" from\"github-rel\" zinit load junegunn/fzf-bin After this command, the $PATH variable will contain e.g.: % print $PATH /home/sg/.zinit/plugins/junegunn---fzf-bin:/bin:/usr/bin:/usr/sbin:/sbin For many such programs loaded as plugins the PATH can become quite cluttered. I've had 26 entries before switching to z-a-bin-gem-node . To solve this, load with use of fbin'' ice provided and handled by z-a-bin-gem-node : zinit ice from\"gh-r\" fbin\"fzf\" zinit load junegunn/fzf-bin The $PATH will remain unchanged and an fzf function will be created: % which fzf fzf() { local bindir=\"/home/sg/.zinit/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" } Running the function will forward the call to the program accessed through an embedded path to it. Thus, no $PATH changes are needed! The Ice Modifiers Provided By The Annex # There are 7 ice-modifiers provided and handled by the annex. They are: fbin'' \u2013 creates functions for binaries and scripts, sbin'' \u2013 creates shims for binaries and scripts, gem'' \u2013 installs and updates gems + creates functions for gems' binaries, node'' \u2013 installs and updates node_modules + creates functions for binaries of the modules, fmod'' \u2013 creates wrapping functions for other functions, fsrc'' \u2013 creates functions that source given scripts, ferc'' \u2013 the same as fsrc'' , but using an alternate script-loading method. The ice-modifiers in detail: 1. fbin'[{g|n|c|N|E|O}:]{path-to-binary}[ -> {name-of-the-function}]; \u2026' # Creates a wrapper function of the name the same as the last segment of the path or as {name-of-the-function} . The optional preceding flags mean: g \u2013 set $GEM_HOME variable, n \u2013 set $NODE_PATH variable, c \u2013 cd to the plugin's directory before running the function and then cd back after it has been run, N \u2013 append &>/dev/null to the call of the binary, i.e. redirect both standard output and standard error to /dev/null , E \u2013 append 2>/dev/null to the call of the binary, i.e. redirect standard error to /dev/null , O \u2013 append >/dev/null to the call of the binary, i.e. redirect standard output to /dev/null . Example: % zinit ice from\"gh-r\" fbin\"g:fzf -> myfzf\" % zinit load junegunn/fzf-bin % which myfzf myfzf() { local bindir=\"/home/sg/.zinit/plugins/junegunn---fzf-bin\" local -x GEM_HOME=\"/home/sg/.zinit/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" } 2. gem'{gem-name}; \u2026' # gem'[{path-to-binary} <-] !{gem-name} [-> {name-of-the-function}]; \u2026' # Installs the gem of name {gem-name} with $GEM_HOME set to the plugin's or snippet's directory. In other words, the gem and its dependencies will be installed locally in that directory. In the second form it also creates a wrapper function identical to the one created with fbin'' ice. Example: % zinit ice gem'!asciidoctor' % zinit load z-shell/null % which asciidoctor asciidoctor() { local bindir=\"/home/sg/.zinit/plugins/z-shell---null/bin\" local -x GEM_HOME=\"/home/sg/.zinit/plugins/z-shell---null\" \"$bindir\"/\"asciidoctor\" \"$@\" } 3. node'{node-module}; \u2026' # node'[{path-to-binary} <-] !{node-module} [-> {name-of-the-function}]; \u2026' # Installs the node module of name {node-module} inside the plugin's or snippet's directory. In the second form it also creates a wrapper function identical to the one created with fbin'' ice. Example: % zinit delete z-shell/null Delete /home/sg/.zinit/plugins/z-shell---null? [yY/n\u2026] y Done (action executed, exit code: 0) % zinit ice node'remark <- !remark-cli -> remark; remark-man' % zinit load z-shell/null \u2026installation messages\u2026 % which remark remark () { local bindir=\"/home/sg/.zinit/plugins/z-shell---null/node_modules/.bin\" local -x NODE_PATH=\"/home/sg/.zinit/plugins/z-shell---null\"/node_modules \"$bindir\"/\"remark\" \"$@\" } In this case the name of the binary program provided by the node module is different from its name, hence the second form with the b <- a -> c syntax has been used. 4. fmod'[{g|n|c|N|E|O}:]{function-name}; \u2026' # fmod'[{g|n|c|N|E|O}:]{function-name} -> {wrapping-function-name}; \u2026' # It wraps given function with the ability to set $GEM_HOME , etc. \u2013 the meaning of the g , n and c flags is the same as in the fbin'' ice. Example: % myfun() { pwd; ls -1 } % zinit ice fmod'cgn:myfun' % zinit load z-shell/null % which myfun myfun () { local -x GEM_HOME=\"/home/sg/.zinit/plugins/z-shell---null\" local -x NODE_PATH=\"/home/sg/.zinit/plugins/z-shell---null\"/node_modules local oldpwd=\"/home/sg/.zinit/plugins/zinit---z-a-bin-gem-node\" () { setopt localoptions noautopushd builtin cd -q \"/home/sg/.zinit/plugins/z-shell---null\" } \"myfun--za-bgn-orig\" \"$@\" () { setopt localoptions noautopushd builtin cd -q \"$oldpwd\" } } % myfun /home/sg/.zinit/plugins/z-shell---null LICENSE README.md 5. sbin'[{g|n|c|N|E|O}:]{path-to-binary}[ -> {name-of-the-script}]; \u2026' # It creates the so called shim known from rbenv \u2013 a wrapper script that forwards the call to the actual binary. The script is created always under the same, standard and single $PATH entry: $ZPFX/bin (which is ~/.zinit/polaris/bin by default). The flags have the same meaning as with fbin'' ice. Example: % zinit delete junegunn/fzf-bin Delete /home/sg/.zinit/plugins/junegunn---fzf-bin? [yY/n\u2026] y Done (action executed, exit code: 0) % zinit ice from\"gh-r\" sbin\"fzf\" % zinit load junegunn/fzf-bin \u2026installation messages\u2026 % cat $ZPFX/bin/fzf #!/usr/bin/env zsh function fzf { local bindir=\"/home/sg/.zinit/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" } fzf \"$@\" 6. fsrc'[{g|n|c|N|E|O}:]{path-to-script}[ -> {name-of-the-function}]; \u2026' # 7. ferc'[{g|n|c|N|E|O}:]{path-to-script}[ -> {name-of-the-function}]; \u2026' # Creates a wrapper function that at each invocation sources the given file. The second ice, ferc'' works the same with the single difference that it uses eval \"$(<{path-to-script})\" instead of source \"{path-to-script}\" to load the script. Example: % zinit ice fsrc\"myscript -> myfunc\" ferc\"myscript\" % zinit load z-shell/null % which myfunc myfunc () { local bindir=\"/home/sg/.zinit/plugins/z-shell---null\" () { source \"$bindir\"/\"myscript\" } \"$@\" } % which myscript myscript () { local bindir=\"/home/sg/.zinit/snippets/OMZ::plugins--git/git.plugin.zsh\" () { eval \"$(<\"$bindir\"/\"myscript\")\" } \"$@\" }","title":"z-a-bin-gem-node"},{"location":"z-a-bin-gem-node/#z-a-bin-gem-node","text":"","title":"z-a-bin-gem-node"},{"location":"z-a-bin-gem-node/#introduction","text":"A Zsh-Zinit annex (i.e. an extension) that provides functionality, which allows to: Run programs and scripts without adding anything to $PATH , Install and run Ruby gems and Node modules from within a local directory with \\$GEM_HOME and \\$NODE_PATH automatically set, Run programs, scripts and functions with automatic cd into the plugin or snippet directory, plus also with automatic standard output & standard error redirecting. Source scripts through an automatically created function with the above $GEM_HOME , $NODE_PATH and cd features available, Create the so called shims known from rbenv \u2013 the same feature as the first item of this enumaration \u2013 of running a program without adding anything to $PATH with all of the above features, however through an automatic script created in $ZPFX/bin , not a function (the first item uses a function-based mechanism), Automatic updates of Ruby gems and Node modules during regular plugin and snippet updates with zinit update \u2026 .","title":"Introduction"},{"location":"z-a-bin-gem-node/#installation","text":"Simply load like a regular plugin, i.e.: zinit light z-shell/z-a-bin-gem-node After executing this command you can then use the dl'' and patch'' ice-mods.","title":"Installation"},{"location":"z-a-bin-gem-node/#how_it_works_birds-eye_view","text":"Below is a diagram explaining the major feature \u2013 exposing a binary program or script through a Zsh function of the same name: This way there is no need to add anything to $PATH \u2013 z-a-bin-gem-node will automatically create a function that will wrap the binary and provide it on the command line like if it was being placed in the $PATH . Also, like mentioned in the enumeration, the function can automatically export $GEM_HOME , $NODE_PATH shell variables and also automatically cd into the plugin or snippet directory right before executing the binary and then cd back to the original directory after the execution is finished. Also, like already mentioned, instead of the function an automatically created script \u2013 so called shim \u2013 can be used for the same purpose and with the same functionality.","title":"How it works \u2013 bird's-eye view"},{"location":"z-a-bin-gem-node/#how_it_works_in_detail","text":"Suppose that you would want to install junegunn/fzf-bin plugin from GitHub Releases, which contains only single file \u2013 the fzf binary for the selected architecture. It is possible to do it in the standard way \u2013 by adding the plugin's directory to the $PATH : zinit ice as\"command\" from\"github-rel\" zinit load junegunn/fzf-bin After this command, the $PATH variable will contain e.g.: % print $PATH /home/sg/.zinit/plugins/junegunn---fzf-bin:/bin:/usr/bin:/usr/sbin:/sbin For many such programs loaded as plugins the PATH can become quite cluttered. I've had 26 entries before switching to z-a-bin-gem-node . To solve this, load with use of fbin'' ice provided and handled by z-a-bin-gem-node : zinit ice from\"gh-r\" fbin\"fzf\" zinit load junegunn/fzf-bin The $PATH will remain unchanged and an fzf function will be created: % which fzf fzf() { local bindir=\"/home/sg/.zinit/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" } Running the function will forward the call to the program accessed through an embedded path to it. Thus, no $PATH changes are needed!","title":"How it works, in detail"},{"location":"z-a-bin-gem-node/#the_ice_modifiers_provided_by_the_annex","text":"There are 7 ice-modifiers provided and handled by the annex. They are: fbin'' \u2013 creates functions for binaries and scripts, sbin'' \u2013 creates shims for binaries and scripts, gem'' \u2013 installs and updates gems + creates functions for gems' binaries, node'' \u2013 installs and updates node_modules + creates functions for binaries of the modules, fmod'' \u2013 creates wrapping functions for other functions, fsrc'' \u2013 creates functions that source given scripts, ferc'' \u2013 the same as fsrc'' , but using an alternate script-loading method. The ice-modifiers in detail:","title":"The Ice Modifiers Provided By The Annex"},{"location":"z-a-bin-gem-node/#1_fbingncneopath-to-binary_-_name-of-the-function","text":"Creates a wrapper function of the name the same as the last segment of the path or as {name-of-the-function} . The optional preceding flags mean: g \u2013 set $GEM_HOME variable, n \u2013 set $NODE_PATH variable, c \u2013 cd to the plugin's directory before running the function and then cd back after it has been run, N \u2013 append &>/dev/null to the call of the binary, i.e. redirect both standard output and standard error to /dev/null , E \u2013 append 2>/dev/null to the call of the binary, i.e. redirect standard error to /dev/null , O \u2013 append >/dev/null to the call of the binary, i.e. redirect standard output to /dev/null . Example: % zinit ice from\"gh-r\" fbin\"g:fzf -> myfzf\" % zinit load junegunn/fzf-bin % which myfzf myfzf() { local bindir=\"/home/sg/.zinit/plugins/junegunn---fzf-bin\" local -x GEM_HOME=\"/home/sg/.zinit/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" }","title":"1. fbin'[{g|n|c|N|E|O}:]{path-to-binary}[ -&gt; {name-of-the-function}]; \u2026'"},{"location":"z-a-bin-gem-node/#2_gemgem-name","text":"","title":"2. gem'{gem-name}; \u2026'"},{"location":"z-a-bin-gem-node/#gempath-to-binary_-_gem-name_-_name-of-the-function","text":"Installs the gem of name {gem-name} with $GEM_HOME set to the plugin's or snippet's directory. In other words, the gem and its dependencies will be installed locally in that directory. In the second form it also creates a wrapper function identical to the one created with fbin'' ice. Example: % zinit ice gem'!asciidoctor' % zinit load z-shell/null % which asciidoctor asciidoctor() { local bindir=\"/home/sg/.zinit/plugins/z-shell---null/bin\" local -x GEM_HOME=\"/home/sg/.zinit/plugins/z-shell---null\" \"$bindir\"/\"asciidoctor\" \"$@\" }","title":"gem'[{path-to-binary} &lt;-] !{gem-name} [-&gt; {name-of-the-function}]; \u2026'"},{"location":"z-a-bin-gem-node/#3_nodenode-module","text":"","title":"3. node'{node-module}; \u2026'"},{"location":"z-a-bin-gem-node/#nodepath-to-binary_-_node-module_-_name-of-the-function","text":"Installs the node module of name {node-module} inside the plugin's or snippet's directory. In the second form it also creates a wrapper function identical to the one created with fbin'' ice. Example: % zinit delete z-shell/null Delete /home/sg/.zinit/plugins/z-shell---null? [yY/n\u2026] y Done (action executed, exit code: 0) % zinit ice node'remark <- !remark-cli -> remark; remark-man' % zinit load z-shell/null \u2026installation messages\u2026 % which remark remark () { local bindir=\"/home/sg/.zinit/plugins/z-shell---null/node_modules/.bin\" local -x NODE_PATH=\"/home/sg/.zinit/plugins/z-shell---null\"/node_modules \"$bindir\"/\"remark\" \"$@\" } In this case the name of the binary program provided by the node module is different from its name, hence the second form with the b <- a -> c syntax has been used.","title":"node'[{path-to-binary} &lt;-] !{node-module} [-&gt; {name-of-the-function}]; \u2026'"},{"location":"z-a-bin-gem-node/#4_fmodgncneofunction-name","text":"","title":"4. fmod'[{g|n|c|N|E|O}:]{function-name}; \u2026'"},{"location":"z-a-bin-gem-node/#fmodgncneofunction-name_-_wrapping-function-name","text":"It wraps given function with the ability to set $GEM_HOME , etc. \u2013 the meaning of the g , n and c flags is the same as in the fbin'' ice. Example: % myfun() { pwd; ls -1 } % zinit ice fmod'cgn:myfun' % zinit load z-shell/null % which myfun myfun () { local -x GEM_HOME=\"/home/sg/.zinit/plugins/z-shell---null\" local -x NODE_PATH=\"/home/sg/.zinit/plugins/z-shell---null\"/node_modules local oldpwd=\"/home/sg/.zinit/plugins/zinit---z-a-bin-gem-node\" () { setopt localoptions noautopushd builtin cd -q \"/home/sg/.zinit/plugins/z-shell---null\" } \"myfun--za-bgn-orig\" \"$@\" () { setopt localoptions noautopushd builtin cd -q \"$oldpwd\" } } % myfun /home/sg/.zinit/plugins/z-shell---null LICENSE README.md","title":"fmod'[{g|n|c|N|E|O}:]{function-name} -&gt; {wrapping-function-name}; \u2026'"},{"location":"z-a-bin-gem-node/#5_sbingncneopath-to-binary_-_name-of-the-script","text":"It creates the so called shim known from rbenv \u2013 a wrapper script that forwards the call to the actual binary. The script is created always under the same, standard and single $PATH entry: $ZPFX/bin (which is ~/.zinit/polaris/bin by default). The flags have the same meaning as with fbin'' ice. Example: % zinit delete junegunn/fzf-bin Delete /home/sg/.zinit/plugins/junegunn---fzf-bin? [yY/n\u2026] y Done (action executed, exit code: 0) % zinit ice from\"gh-r\" sbin\"fzf\" % zinit load junegunn/fzf-bin \u2026installation messages\u2026 % cat $ZPFX/bin/fzf #!/usr/bin/env zsh function fzf { local bindir=\"/home/sg/.zinit/plugins/junegunn---fzf-bin\" \"$bindir\"/\"fzf\" \"$@\" } fzf \"$@\"","title":"5. sbin'[{g|n|c|N|E|O}:]{path-to-binary}[ -&gt; {name-of-the-script}]; \u2026'"},{"location":"z-a-bin-gem-node/#6_fsrcgncneopath-to-script_-_name-of-the-function","text":"","title":"6. fsrc'[{g|n|c|N|E|O}:]{path-to-script}[ -&gt; {name-of-the-function}]; \u2026'"},{"location":"z-a-bin-gem-node/#7_fercgncneopath-to-script_-_name-of-the-function","text":"Creates a wrapper function that at each invocation sources the given file. The second ice, ferc'' works the same with the single difference that it uses eval \"$(<{path-to-script})\" instead of source \"{path-to-script}\" to load the script. Example: % zinit ice fsrc\"myscript -> myfunc\" ferc\"myscript\" % zinit load z-shell/null % which myfunc myfunc () { local bindir=\"/home/sg/.zinit/plugins/z-shell---null\" () { source \"$bindir\"/\"myscript\" } \"$@\" } % which myscript myscript () { local bindir=\"/home/sg/.zinit/snippets/OMZ::plugins--git/git.plugin.zsh\" () { eval \"$(<\"$bindir\"/\"myscript\")\" } \"$@\" }","title":"7. ferc'[{g|n|c|N|E|O}:]{path-to-script}[ -&gt; {name-of-the-function}]; \u2026'"},{"location":"z-a-man/","text":"Introduction # A Zinit extension that automatically generates: man pages for all plugins and snippets (out of plugin README.md files by using ronn converter), code-documentation manpages (by using zshelldoc project). Man extension is being activated at clone of a plugin and also at update of it and it then generates the manpages. To view them there's a zman command: # View README.md manpage in the terminal zman z-a-man # View the code documentation (via the full plugin name, as demonstrated) zman -c z-shell/z-a-man Examples # Main manual (of the project): Code documentation for the plugin.zsh file (of the project): Installation # Simply load like any other plugin, i.e.: the following command will install the extension within Zinit: zinit light z-shell/z-a-man","title":"z-a-man"},{"location":"z-a-man/#introduction","text":"A Zinit extension that automatically generates: man pages for all plugins and snippets (out of plugin README.md files by using ronn converter), code-documentation manpages (by using zshelldoc project). Man extension is being activated at clone of a plugin and also at update of it and it then generates the manpages. To view them there's a zman command: # View README.md manpage in the terminal zman z-a-man # View the code documentation (via the full plugin name, as demonstrated) zman -c z-shell/z-a-man","title":"Introduction"},{"location":"z-a-man/#examples","text":"Main manual (of the project): Code documentation for the plugin.zsh file (of the project):","title":"Examples"},{"location":"z-a-man/#installation","text":"Simply load like any other plugin, i.e.: the following command will install the extension within Zinit: zinit light z-shell/z-a-man","title":"Installation"},{"location":"z-a-patch-dl/","text":"Introduction # A Zsh-Zinit extension (i.e. an annex ) that downloads files and applies patches. It adds two ice modifiers: zinit ice dl'{URL} [-> {optional-output-file-name}]; \u2026' \u2026 and zinit ice patch'{file-name-with-the-patch-to-apply}; \u2026' \u2026 The annex (i.e. Zinit extension) will download the given {URL} under the path {optional-output-file-name} (if no file name given, then it is taken from last segment of the URL) in case of the dl'' ice-mod, and apply a patch given by the {file-name-with-the-patch-to-apply} in case of the patch'' ice-mod. You can use this functionality to download and apply patches. For example, to install fbterm , two patches are being needed, one to fix the operation, the other one to fix the build: zinit ice \\ as\"command\" pick\"$ZPFX/bin/fbterm\" \\ dl\"https://bugs.archlinux.org/task/46860?getfile=13513 -> ins.patch\" \\ dl\"https://aur.archlinux.org/cgit/aur.git/plain/0001-Fix-build-with-gcc-6.patch?h=fbterm-git\" \\ patch\"ins.patch; 0001-Fix-build-with-gcc-6.patch\" \\ atclone\"./configure --prefix=$ZPFX\" \\ atpull\"%atclone\" \\ make\"install\" reset zinit load izmntuk/fbterm This command will result in: Installation # Simply load like a plugin, i.e. the following will add the annex to Zinit: zinit light z-shell/z-a-patch-dl After executing this command you can then use the dl'' and patch'' ice-mods.","title":"z-a-patch-dl"},{"location":"z-a-patch-dl/#introduction","text":"A Zsh-Zinit extension (i.e. an annex ) that downloads files and applies patches. It adds two ice modifiers: zinit ice dl'{URL} [-> {optional-output-file-name}]; \u2026' \u2026 and zinit ice patch'{file-name-with-the-patch-to-apply}; \u2026' \u2026 The annex (i.e. Zinit extension) will download the given {URL} under the path {optional-output-file-name} (if no file name given, then it is taken from last segment of the URL) in case of the dl'' ice-mod, and apply a patch given by the {file-name-with-the-patch-to-apply} in case of the patch'' ice-mod. You can use this functionality to download and apply patches. For example, to install fbterm , two patches are being needed, one to fix the operation, the other one to fix the build: zinit ice \\ as\"command\" pick\"$ZPFX/bin/fbterm\" \\ dl\"https://bugs.archlinux.org/task/46860?getfile=13513 -> ins.patch\" \\ dl\"https://aur.archlinux.org/cgit/aur.git/plain/0001-Fix-build-with-gcc-6.patch?h=fbterm-git\" \\ patch\"ins.patch; 0001-Fix-build-with-gcc-6.patch\" \\ atclone\"./configure --prefix=$ZPFX\" \\ atpull\"%atclone\" \\ make\"install\" reset zinit load izmntuk/fbterm This command will result in:","title":"Introduction"},{"location":"z-a-patch-dl/#installation","text":"Simply load like a plugin, i.e. the following will add the annex to Zinit: zinit light z-shell/z-a-patch-dl After executing this command you can then use the dl'' and patch'' ice-mods.","title":"Installation"},{"location":"z-a-submods/","text":"Introduction # An annex (i.e. an extension for Zinit \u2013 more information ) that allows Zinit to clone additional submodules when installing a plugin or snippet. The submodules are then automatically updated on the zinit update \u2026 command. This annex adds submods'' ice to Zinit which has the following syntax: submods'{user}/{plugin} -> {output directory}; \u2026' An example command utilizing the annex and its ice: # Load zsh-autosuggestions plugin via Prezto module: autosuggestions zinit ice svn submods'zsh-users/zsh-autosuggestions -> external' zinit snippet PZT::modules/autosuggestions Installation # Simply load as a plugin. The following command will install the annex within Zinit: zinit light z-shell/z-a-submods After executing this command you can then use the submods'' ice. The command should be placed in ~/.zshrc .","title":"z-a-submods"},{"location":"z-a-submods/#introduction","text":"An annex (i.e. an extension for Zinit \u2013 more information ) that allows Zinit to clone additional submodules when installing a plugin or snippet. The submodules are then automatically updated on the zinit update \u2026 command. This annex adds submods'' ice to Zinit which has the following syntax: submods'{user}/{plugin} -> {output directory}; \u2026' An example command utilizing the annex and its ice: # Load zsh-autosuggestions plugin via Prezto module: autosuggestions zinit ice svn submods'zsh-users/zsh-autosuggestions -> external' zinit snippet PZT::modules/autosuggestions","title":"Introduction"},{"location":"z-a-submods/#installation","text":"Simply load as a plugin. The following command will install the annex within Zinit: zinit light z-shell/z-a-submods After executing this command you can then use the submods'' ice. The command should be placed in ~/.zshrc .","title":"Installation"},{"location":"z-a-test/","text":"Introduction # Zinit extension that runs tests (via make test , for example) \u2013 if it finds any of them \u2013 after installing and updating a plugin or snippet. Simply load it as a plugin to make it active: zinit light z-shell/z-a-test Example activation in the default quiet mode: Example activation in non-quiet mode: Installation # Simply load as a plugin. This will install the extension within Zinit: zinit light z-shell/z-a-test","title":"z-a-test"},{"location":"z-a-test/#introduction","text":"Zinit extension that runs tests (via make test , for example) \u2013 if it finds any of them \u2013 after installing and updating a plugin or snippet. Simply load it as a plugin to make it active: zinit light z-shell/z-a-test Example activation in the default quiet mode: Example activation in non-quiet mode:","title":"Introduction"},{"location":"z-a-test/#installation","text":"Simply load as a plugin. This will install the extension within Zinit: zinit light z-shell/z-a-test","title":"Installation"},{"location":"zinit-autoload.zsh/","text":"zinit-autoload.zsh(1) # NAME # zinit-autoload.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # .zinit-any-to-uspl2 .zinit-at-eval .zinit-build-module .zinit-cd .zinit-cdisable .zinit-cenable .zinit-changes .zinit-check-comp-consistency .zinit-check-which-completions-are-enabled .zinit-check-which-completions-are-installed .zinit-clear-completions .zinit-clear-report-for .zinit-compiled .zinit-compile-uncompile-all .zinit-compinit .zinit-compute-ice .zinit-confirm .zinit-create .zinit-delete .zinit-diff-env-compute .zinit-diff-functions-compute .zinit-diff-options-compute .zinit-diff-parameter-compute .zinit-edit .zinit-exists-message .zinit-find-completions-of-plugin .zinit-format-env .zinit-format-functions .zinit-format-options .zinit-format-parameter .zinit-get-completion-owner .zinit-get-completion-owner-uspl2col .zinit-get-path .zinit-glance .zinit-help .zinit-list-bindkeys .zinit-list-compdef-replay .zinit-ls .zinit-module .zinit-prepare-readlink .zinit-recall .zinit-recently .zinit-restore-extendedglob .zinit-save-set-extendedglob .zinit-search-completions .zinit-self-update .zinit-show-all-reports .zinit-show-completions .zinit-show-debug-report .zinit-show-registered-plugins .zinit-show-report .zinit-show-times .zinit-show-zstatus .zinit-stress .zinit-uncompile-plugin .zinit-uninstall-completions .zinit-unload .zinit-update-or-status .zinit-update-or-status-all .zinit-update-or-status-snippet AUTOLOAD compinit DETAILS # Script Body # Has 5 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source .zinit-any-to-uspl2 # Converts given plugin-spec to format that's used in keys for hash tables. So basically, creates string \"user/plugin\" (this format is called: uspl2). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 2 line(s). Calls functions: .zinit-any-to-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-clear-report-for .zinit-exists-message .zinit-at-eval # Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-update-or-status .zinit-build-module # Performs ./configure && make on the module and displays information how to load the module in .zshrc. Has 27 line(s). Calls functions: .zinit-build-module `-- .zinit-module Uses feature(s): trap Called by: .zinit-module .zinit-cd # Jumps to plugin's directory (in Zinit's home directory). User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: .zinit-cd `-- .zinit-get-path |-- zinit-side.zsh/.zinit-exists-physically |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-cdisable # Enables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 30 line(s). Calls functions: .zinit-cdisable |-- .zinit-check-comp-consistency |-- .zinit-get-completion-owner-uspl2col | |-- .zinit-get-completion-owner | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- .zinit-prepare-readlink Called by: zinit.zsh/zinit .zinit-cenable # Disables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 31 line(s). Calls functions: .zinit-cenable |-- .zinit-check-comp-consistency |-- .zinit-get-completion-owner-uspl2col | |-- .zinit-get-completion-owner | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- .zinit-prepare-readlink Called by: zinit.zsh/zinit .zinit-changes # Shows `git log` of given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 9 line(s). Calls functions: .zinit-changes |-- zinit-side.zsh/.zinit-exists-physically-message `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-check-comp-consistency # Zinit creates symlink for each installed completion. This function checks whether given completion (i.e. file like \"_mkdir\") is indeed a symlink. Backup file is a completion that is disabled - has the leading \"_\" removed. $1 - path to completion within plugin's directory $2 - path to backup file within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: .zinit-cdisable .zinit-cenable .zinit-check-which-completions-are-enabled # For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is disabled - returns 0 or 1 on corresponding positions in reply. Uninstalled completions will be reported as \"0\" - i.e. disabled $1, ... - path to completion within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-check-which-completions-are-installed # For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is installed - returns 0 or 1 on corresponding positions in reply. $1, ... - path to completion within plugin's directory Has 12 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-clear-completions # Delete stray and improper completions. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 37 line(s). Calls functions: .zinit-clear-completions |-- .zinit-get-completion-owner |-- .zinit-prepare-readlink `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-clear-report-for # Clears all report data for given user/plugin. This is done by resetting all related global ZINIT_* hashes. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 23 line(s). Calls functions: .zinit-clear-report-for `-- .zinit-any-to-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-unload zinit.zsh/.zinit-clear-debug-report .zinit-compiled # Displays list of plugins that are compiled. User-action entry point. Has 26 line(s). Calls functions: .zinit-compiled |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit .zinit-compile-uncompile-all # Compiles or uncompiles all existing (on disk) plugins. User-action entry point. Has 23 line(s). Calls functions: .zinit-compile-uncompile-all |-- .zinit-uncompile-plugin | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit-install.zsh/.zinit-compile-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit .zinit-compinit # User-exposed `compinit' frontend which first ensures that all completions managed by Zinit are forgotten by Zshell. After that it runs normal `compinit', which should more easily detect Zinit's completions. No arguments. Has 23 line(s). Calls functions: .zinit-compinit |-- compinit `-- zinit-install.zsh/.zinit-forget-completion Uses feature(s): autoload , unfunction Called by: zinit.zsh/zinit .zinit-compute-ice # Computes ZINIT_ICE array (default, it can be specified via $3) from a) input ZINIT_ICE, b) static ice, c) saved ice, taking priorities into account. Also returns path to snippet directory and optional name of snippet file (only valid if ZINIT_ICE[svn] is not set). Can also pack resulting ices into ZINIT_SICE (see $2). $1 - URL (also plugin-spec) $2 - \"pack\" or \"nopack\" or \"pack-nf\" - packing means ZINIT_ICE wins with static ice; \"pack-nf\" means that disk-ices will be ignored (no-file?) $3 - name of output associative array, \"ZINIT_ICE\" is the default $4 - name of output string parameter, to hold path to directory (\"local_dir\") $5 - name of output string parameter, to hold filename (\"filename\") Has 98 line(s). Calls functions: .zinit-compute-ice |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-pack-ice Uses feature(s): wait Called by: .zinit-recall .zinit-update-or-status-snippet .zinit-update-or-status .zinit-confirm # Prints given question, waits for \"y\" key, evals given expression if \"y\" obtained $1 - question $2 - expression Has 5 line(s). Doesn't call other functions. Uses feature(s): eval , read Called by: .zinit-delete .zinit-create # Creates a plugin, also on Github (if not \"_local/name\" plugin). User-action entry point. $1 - (optional) plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 66 line(s). Calls functions: .zinit-create |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): vared Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-delete # Deletes plugin's or snippet's directory (in Zinit's home directory). User-action entry point. $1 - snippet URL or plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 54 line(s). Calls functions: .zinit-delete |-- .zinit-confirm |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-diff-env-compute # Computes ZINIT_PATH, ZINIT_FPATH that hold (f)path components added by plugin. Uses data gathered earlier by .zinit-diff-env(). $1 - user/plugin Has 30 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload .zinit-diff-functions-compute # Computes FUNCTIONS that holds new functions added by plugin. Uses data gathered earlier by .zinit-diff-functions(). $1 - user/plugin Has 19 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload .zinit-diff-options-compute # Computes OPTIONS that holds options changed by plugin. Uses data gathered earlier by .zinit-diff-options(). $1 - user/plugin Has 17 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload .zinit-diff-parameter-compute # Computes ZINIT_PARAMETERS_PRE, ZINIT_PARAMETERS_POST that hold parameters created or changed (their type) by plugin. Uses data gathered earlier by .zinit-diff-parameter(). $1 - user/plugin Has 28 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload .zinit-edit # Runs $EDITOR on source of given plugin. If the variable is not set then defaults to `vim'. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: .zinit-edit |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-exists-message # Checks if plugin is loaded. Testable. Also outputs error message if plugin is not loaded. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 7 line(s). Calls functions: .zinit-exists-message |-- .zinit-any-to-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: .zinit-show-report .zinit-unload .zinit-find-completions-of-plugin # Searches for completions owned by given plugin. Returns them in `reply' array. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 6 line(s). Calls functions: .zinit-find-completions-of-plugin `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-show-report .zinit-format-env # Creates one-column text about FPATH or PATH elements added when given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) $2 - if 1, then examine PATH, if 2, then examine FPATH Has 16 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-format-functions # Creates a one or two columns text with functions created by given plugin. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 36 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-format-options # Creates one-column text about options that changed when plugin \"$1\" was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 21 line(s). Calls functions: .zinit-format-options |-- .zinit-restore-extendedglob `-- .zinit-save-set-extendedglob Called by: .zinit-show-report .zinit-format-parameter # Creates one column text that lists global parameters that changed when the given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 34 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-get-completion-owner # Returns \"user---plugin\" string (uspl1 format) of plugin that owns given completion. Both :A and readlink will be used, then readlink's output if results differ. Readlink might not be available. :A will read the link \"twice\" and give the final repository directory, possibly without username in the uspl format; readlink will read the link \"once\" $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 22 line(s). Doesn't call other functions. Called by: .zinit-clear-completions .zinit-get-completion-owner-uspl2col .zinit-show-completions .zinit-get-completion-owner-uspl2col # For shortening of code - returns colorized plugin name that owns given completion. $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 2 line(s). Calls functions: .zinit-get-completion-owner-uspl2col |-- .zinit-get-completion-owner `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: .zinit-cdisable .zinit-cenable .zinit-get-path # Returns path of given ID-string, which may be a plugin-spec (like \"user/plugin\" or \"user\" \"plugin\"), an absolute path (\"%\" \"/home/...\" and also \"%SNIPPETS/...\" etc.), or a plugin nickname (i.e. id-as'' ice-mod), or a snippet nickname. Has 35 line(s). Calls functions: .zinit-get-path |-- zinit-side.zsh/.zinit-exists-physically |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-cd .zinit-uninstall-completions .zinit-glance # Shows colorized source code of plugin. Is able to use pygmentize, highlight, GNU source-highlight. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 39 line(s). Calls functions: .zinit-glance |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-help # Shows usage information. User-action entry point. Has 68 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit .zinit-list-bindkeys # Has 42 line(s). Calls functions: .zinit-list-bindkeys `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-list-compdef-replay # Shows recorded compdefs (called by plugins loaded earlier). Plugins often call `compdef' hoping for `compinit' being already ran. Zinit solves this by recording compdefs. User-action entry point. Has 5 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit .zinit-ls # Has 19 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit .zinit-module # Function that has sub-commands passed as long-options (with two dashes, --). It's an attempt to plugin only this one function into `zinit' function defined in zinit.zsh, to not make this file longer than it's needed. Has 24 line(s). Calls functions: .zinit-module `-- .zinit-build-module Called by: .zinit-build-module zinit.zsh/zinit .zinit-prepare-readlink # Prepares readlink command, used for establishing completion's owner. $REPLY = \":\" or \"readlink\" Has 4 line(s). Doesn't call other functions. Uses feature(s): type Called by: .zinit-cdisable .zinit-cenable .zinit-clear-completions .zinit-show-completions .zinit-recall # Has 37 line(s). Calls functions: .zinit-recall `-- .zinit-compute-ice |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-pack-ice Uses feature(s): wait Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-recently # Shows plugins that obtained commits in specified past time. User-action entry point. $1 - time spec, e.g. \"1 week\" Has 26 line(s). Calls functions: .zinit-recently `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-restore-extendedglob # Restores extendedglob-option from state saved earlier. Has 1 line(s). Doesn't call other functions. Called by: .zinit-format-options .zinit-show-registered-plugins .zinit-unload .zinit-save-set-extendedglob # Enables extendedglob-option first saving if it was already enabled, for restoration of this state later. Has 2 line(s). Doesn't call other functions. Called by: .zinit-format-options .zinit-show-registered-plugins .zinit-unload .zinit-search-completions # While .zinit-show-completions() shows what completions are installed, this functions searches through all plugin dirs showing what's available in general (for installation). User-action entry point. Has 43 line(s). Calls functions: .zinit-search-completions `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-self-update # Updates Zinit code (does a git pull). User-action entry point. Has 23 line(s). Doesn't call other functions. Uses feature(s): zcompile Called by: zinit.zsh/zinit .zinit-show-all-reports # Displays reports of all loaded plugins. User-action entry point. Has 5 line(s). Calls functions: .zinit-show-all-reports `-- .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit .zinit-show-completions # Display installed (enabled and disabled), completions. Detect stray and improper ones. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 72 line(s). Calls functions: .zinit-show-completions |-- .zinit-get-completion-owner |-- .zinit-prepare-readlink `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-show-debug-report # Displays dtrace report (data recorded in interactive session). User-action entry point. Has 1 line(s). Calls functions: .zinit-show-debug-report `-- .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit .zinit-show-registered-plugins # Lists loaded plugins (subcommands list, lodaded). User-action entry point. Has 21 line(s). Calls functions: .zinit-show-registered-plugins |-- .zinit-restore-extendedglob |-- .zinit-save-set-extendedglob `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-show-report # Displays report of the plugin given. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 71 line(s). Calls functions: .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-show-all-reports .zinit-show-debug-report zinit.zsh/zinit .zinit-show-times # Shows loading times of all loaded plugins. User-action entry point. Has 42 line(s). Calls functions: .zinit-show-times `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-show-zstatus # Shows Zinit status, i.e. number of loaded plugins, of available completions, etc. User-action entry point. Has 41 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit .zinit-stress # Compiles plugin with various options on and off to see how well the code is written. The options are: NO_SHORT_LOOPS, IGNORE_BRACES, IGNORE_CLOSE_BRACES, SH_GLOB, CSH_JUNKIE_QUOTES, NO_MULTI_FUNC_DEF. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 35 line(s). Calls functions: .zinit-stress |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): zcompile Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-uncompile-plugin # Uncompiles given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 22 line(s). Calls functions: .zinit-uncompile-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-compile-uncompile-all zinit.zsh/zinit .zinit-uninstall-completions # Removes all completions of given plugin from Zshell (i.e. from FPATH). The FPATH is typically `~/.zinit/completions/'. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 41 line(s). Calls functions: .zinit-uninstall-completions |-- .zinit-get-path | |-- zinit-side.zsh/.zinit-exists-physically | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | `-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit-install.zsh/.zinit-forget-completion Called by: zinit.zsh/zinit .zinit-unload # 0. Call the Zsh Plugin's Standard *_plugin_unload function 1. Delete bindkeys (...) 2. Delete Zstyles 3. Restore options 4. Remove aliases 5. Restore Zle state 6. Unfunction functions (created by plugin) 7. Clean-up FPATH and PATH 8. Delete created variables 9. Forget the plugin User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 347 line(s). Calls functions: .zinit-unload |-- .zinit-clear-report-for | `-- .zinit-any-to-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-restore-extendedglob |-- .zinit-save-set-extendedglob |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit.zsh/.zinit-clear-debug-report `-- zinit.zsh/.zinit-unregister-plugin Uses feature(s): alias , bindkey , unalias , unfunction , zle , zstyle Called by: zinit.zsh/.zinit-debug-unload zinit.zsh/.zinit-run-task zinit.zsh/zinit .zinit-update-or-status # Updates (git pull) or does `git status' for given plugin. User-action entry point. $1 - \"status\" for status, other for update $2 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $3 - plugin (only when $1 - i.e. user - given) Has 212 line(s). Calls functions: .zinit-update-or-status |-- .zinit-at-eval |-- .zinit-compute-ice | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | |-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit.zsh/.zinit-pack-ice |-- .zinit-update-or-status-snippet | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | `-- zinit.zsh/.zinit-load-snippet |-- zinit-install.zsh/.zinit-get-latest-gh-r-version |-- zinit-install.zsh/.zinit-setup-plugin-dir |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-store-ices |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): kill , read , source , wait Called by: .zinit-update-or-status-all zinit.zsh/zinit .zinit-update-or-status-all # Updates (git pull) or does `git status` for all existing plugins. This includes also plugins that are not loaded into Zsh (but exist on disk). Also updates (i.e. redownloads) snippets. User-action entry point. Has 63 line(s). Calls functions: .zinit-update-or-status-all |-- .zinit-update-or-status | |-- .zinit-at-eval | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | |-- .zinit-update-or-status-snippet | | |-- .zinit-compute-ice | | | |-- zinit-side.zsh/.zinit-exists-physically-message | | | |-- zinit-side.zsh/.zinit-shands-exp | | | |-- zinit-side.zsh/.zinit-two-paths | | | |-- zinit.zsh/.zinit-any-to-user-plugin | | | `-- zinit.zsh/.zinit-pack-ice | | `-- zinit.zsh/.zinit-load-snippet | |-- zinit-install.zsh/.zinit-get-latest-gh-r-version | |-- zinit-install.zsh/.zinit-setup-plugin-dir | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-store-ices | |-- zinit-side.zsh/.zinit-two-paths | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-update-or-status-snippet | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | `-- zinit.zsh/.zinit-load-snippet |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit .zinit-update-or-status-snippet # Implements update or status operation for snippet given by URL. $1 - \"status\" or \"update\" $2 - snippet URL Has 19 line(s). Calls functions: .zinit-update-or-status-snippet |-- .zinit-compute-ice | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | |-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit.zsh/.zinit-pack-ice `-- zinit.zsh/.zinit-load-snippet Called by: .zinit-update-or-status-all .zinit-update-or-status compinit # Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: .zinit-compinit","title":"zinit-autoload.zsh"},{"location":"zinit-autoload.zsh/#zinit-autoloadzsh1","text":"","title":"zinit-autoload.zsh(1)"},{"location":"zinit-autoload.zsh/#name","text":"zinit-autoload.zsh - a shell script","title":"NAME"},{"location":"zinit-autoload.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zinit-autoload.zsh/#functions","text":".zinit-any-to-uspl2 .zinit-at-eval .zinit-build-module .zinit-cd .zinit-cdisable .zinit-cenable .zinit-changes .zinit-check-comp-consistency .zinit-check-which-completions-are-enabled .zinit-check-which-completions-are-installed .zinit-clear-completions .zinit-clear-report-for .zinit-compiled .zinit-compile-uncompile-all .zinit-compinit .zinit-compute-ice .zinit-confirm .zinit-create .zinit-delete .zinit-diff-env-compute .zinit-diff-functions-compute .zinit-diff-options-compute .zinit-diff-parameter-compute .zinit-edit .zinit-exists-message .zinit-find-completions-of-plugin .zinit-format-env .zinit-format-functions .zinit-format-options .zinit-format-parameter .zinit-get-completion-owner .zinit-get-completion-owner-uspl2col .zinit-get-path .zinit-glance .zinit-help .zinit-list-bindkeys .zinit-list-compdef-replay .zinit-ls .zinit-module .zinit-prepare-readlink .zinit-recall .zinit-recently .zinit-restore-extendedglob .zinit-save-set-extendedglob .zinit-search-completions .zinit-self-update .zinit-show-all-reports .zinit-show-completions .zinit-show-debug-report .zinit-show-registered-plugins .zinit-show-report .zinit-show-times .zinit-show-zstatus .zinit-stress .zinit-uncompile-plugin .zinit-uninstall-completions .zinit-unload .zinit-update-or-status .zinit-update-or-status-all .zinit-update-or-status-snippet AUTOLOAD compinit","title":"FUNCTIONS"},{"location":"zinit-autoload.zsh/#details","text":"","title":"DETAILS"},{"location":"zinit-autoload.zsh/#script_body","text":"Has 5 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source","title":"Script Body"},{"location":"zinit-autoload.zsh/#zinit-any-to-uspl2","text":"Converts given plugin-spec to format that's used in keys for hash tables. So basically, creates string \"user/plugin\" (this format is called: uspl2). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 2 line(s). Calls functions: .zinit-any-to-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-clear-report-for .zinit-exists-message","title":".zinit-any-to-uspl2"},{"location":"zinit-autoload.zsh/#zinit-at-eval","text":"Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-update-or-status","title":".zinit-at-eval"},{"location":"zinit-autoload.zsh/#zinit-build-module","text":"Performs ./configure && make on the module and displays information how to load the module in .zshrc. Has 27 line(s). Calls functions: .zinit-build-module `-- .zinit-module Uses feature(s): trap Called by: .zinit-module","title":".zinit-build-module"},{"location":"zinit-autoload.zsh/#zinit-cd","text":"Jumps to plugin's directory (in Zinit's home directory). User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: .zinit-cd `-- .zinit-get-path |-- zinit-side.zsh/.zinit-exists-physically |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-cd"},{"location":"zinit-autoload.zsh/#zinit-cdisable","text":"Enables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 30 line(s). Calls functions: .zinit-cdisable |-- .zinit-check-comp-consistency |-- .zinit-get-completion-owner-uspl2col | |-- .zinit-get-completion-owner | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- .zinit-prepare-readlink Called by: zinit.zsh/zinit","title":".zinit-cdisable"},{"location":"zinit-autoload.zsh/#zinit-cenable","text":"Disables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 31 line(s). Calls functions: .zinit-cenable |-- .zinit-check-comp-consistency |-- .zinit-get-completion-owner-uspl2col | |-- .zinit-get-completion-owner | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- .zinit-prepare-readlink Called by: zinit.zsh/zinit","title":".zinit-cenable"},{"location":"zinit-autoload.zsh/#zinit-changes","text":"Shows `git log` of given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 9 line(s). Calls functions: .zinit-changes |-- zinit-side.zsh/.zinit-exists-physically-message `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-changes"},{"location":"zinit-autoload.zsh/#zinit-check-comp-consistency","text":"Zinit creates symlink for each installed completion. This function checks whether given completion (i.e. file like \"_mkdir\") is indeed a symlink. Backup file is a completion that is disabled - has the leading \"_\" removed. $1 - path to completion within plugin's directory $2 - path to backup file within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: .zinit-cdisable .zinit-cenable","title":".zinit-check-comp-consistency"},{"location":"zinit-autoload.zsh/#zinit-check-which-completions-are-enabled","text":"For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is disabled - returns 0 or 1 on corresponding positions in reply. Uninstalled completions will be reported as \"0\" - i.e. disabled $1, ... - path to completion within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: .zinit-show-report","title":".zinit-check-which-completions-are-enabled"},{"location":"zinit-autoload.zsh/#zinit-check-which-completions-are-installed","text":"For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is installed - returns 0 or 1 on corresponding positions in reply. $1, ... - path to completion within plugin's directory Has 12 line(s). Doesn't call other functions. Called by: .zinit-show-report","title":".zinit-check-which-completions-are-installed"},{"location":"zinit-autoload.zsh/#zinit-clear-completions","text":"Delete stray and improper completions. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 37 line(s). Calls functions: .zinit-clear-completions |-- .zinit-get-completion-owner |-- .zinit-prepare-readlink `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-clear-completions"},{"location":"zinit-autoload.zsh/#zinit-clear-report-for","text":"Clears all report data for given user/plugin. This is done by resetting all related global ZINIT_* hashes. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 23 line(s). Calls functions: .zinit-clear-report-for `-- .zinit-any-to-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-unload zinit.zsh/.zinit-clear-debug-report","title":".zinit-clear-report-for"},{"location":"zinit-autoload.zsh/#zinit-compiled","text":"Displays list of plugins that are compiled. User-action entry point. Has 26 line(s). Calls functions: .zinit-compiled |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit","title":".zinit-compiled"},{"location":"zinit-autoload.zsh/#zinit-compile-uncompile-all","text":"Compiles or uncompiles all existing (on disk) plugins. User-action entry point. Has 23 line(s). Calls functions: .zinit-compile-uncompile-all |-- .zinit-uncompile-plugin | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit-install.zsh/.zinit-compile-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit","title":".zinit-compile-uncompile-all"},{"location":"zinit-autoload.zsh/#zinit-compinit","text":"User-exposed `compinit' frontend which first ensures that all completions managed by Zinit are forgotten by Zshell. After that it runs normal `compinit', which should more easily detect Zinit's completions. No arguments. Has 23 line(s). Calls functions: .zinit-compinit |-- compinit `-- zinit-install.zsh/.zinit-forget-completion Uses feature(s): autoload , unfunction Called by: zinit.zsh/zinit","title":".zinit-compinit"},{"location":"zinit-autoload.zsh/#zinit-compute-ice","text":"Computes ZINIT_ICE array (default, it can be specified via $3) from a) input ZINIT_ICE, b) static ice, c) saved ice, taking priorities into account. Also returns path to snippet directory and optional name of snippet file (only valid if ZINIT_ICE[svn] is not set). Can also pack resulting ices into ZINIT_SICE (see $2). $1 - URL (also plugin-spec) $2 - \"pack\" or \"nopack\" or \"pack-nf\" - packing means ZINIT_ICE wins with static ice; \"pack-nf\" means that disk-ices will be ignored (no-file?) $3 - name of output associative array, \"ZINIT_ICE\" is the default $4 - name of output string parameter, to hold path to directory (\"local_dir\") $5 - name of output string parameter, to hold filename (\"filename\") Has 98 line(s). Calls functions: .zinit-compute-ice |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-pack-ice Uses feature(s): wait Called by: .zinit-recall .zinit-update-or-status-snippet .zinit-update-or-status","title":".zinit-compute-ice"},{"location":"zinit-autoload.zsh/#zinit-confirm","text":"Prints given question, waits for \"y\" key, evals given expression if \"y\" obtained $1 - question $2 - expression Has 5 line(s). Doesn't call other functions. Uses feature(s): eval , read Called by: .zinit-delete","title":".zinit-confirm"},{"location":"zinit-autoload.zsh/#zinit-create","text":"Creates a plugin, also on Github (if not \"_local/name\" plugin). User-action entry point. $1 - (optional) plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 66 line(s). Calls functions: .zinit-create |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): vared Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-create"},{"location":"zinit-autoload.zsh/#zinit-delete","text":"Deletes plugin's or snippet's directory (in Zinit's home directory). User-action entry point. $1 - snippet URL or plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 54 line(s). Calls functions: .zinit-delete |-- .zinit-confirm |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-delete"},{"location":"zinit-autoload.zsh/#zinit-diff-env-compute","text":"Computes ZINIT_PATH, ZINIT_FPATH that hold (f)path components added by plugin. Uses data gathered earlier by .zinit-diff-env(). $1 - user/plugin Has 30 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload","title":".zinit-diff-env-compute"},{"location":"zinit-autoload.zsh/#zinit-diff-functions-compute","text":"Computes FUNCTIONS that holds new functions added by plugin. Uses data gathered earlier by .zinit-diff-functions(). $1 - user/plugin Has 19 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload","title":".zinit-diff-functions-compute"},{"location":"zinit-autoload.zsh/#zinit-diff-options-compute","text":"Computes OPTIONS that holds options changed by plugin. Uses data gathered earlier by .zinit-diff-options(). $1 - user/plugin Has 17 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload","title":".zinit-diff-options-compute"},{"location":"zinit-autoload.zsh/#zinit-diff-parameter-compute","text":"Computes ZINIT_PARAMETERS_PRE, ZINIT_PARAMETERS_POST that hold parameters created or changed (their type) by plugin. Uses data gathered earlier by .zinit-diff-parameter(). $1 - user/plugin Has 28 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload","title":".zinit-diff-parameter-compute"},{"location":"zinit-autoload.zsh/#zinit-edit","text":"Runs $EDITOR on source of given plugin. If the variable is not set then defaults to `vim'. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: .zinit-edit |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-edit"},{"location":"zinit-autoload.zsh/#zinit-exists-message","text":"Checks if plugin is loaded. Testable. Also outputs error message if plugin is not loaded. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 7 line(s). Calls functions: .zinit-exists-message |-- .zinit-any-to-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: .zinit-show-report .zinit-unload","title":".zinit-exists-message"},{"location":"zinit-autoload.zsh/#zinit-find-completions-of-plugin","text":"Searches for completions owned by given plugin. Returns them in `reply' array. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 6 line(s). Calls functions: .zinit-find-completions-of-plugin `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-show-report","title":".zinit-find-completions-of-plugin"},{"location":"zinit-autoload.zsh/#zinit-format-env","text":"Creates one-column text about FPATH or PATH elements added when given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) $2 - if 1, then examine PATH, if 2, then examine FPATH Has 16 line(s). Doesn't call other functions. Called by: .zinit-show-report","title":".zinit-format-env"},{"location":"zinit-autoload.zsh/#zinit-format-functions","text":"Creates a one or two columns text with functions created by given plugin. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 36 line(s). Doesn't call other functions. Called by: .zinit-show-report","title":".zinit-format-functions"},{"location":"zinit-autoload.zsh/#zinit-format-options","text":"Creates one-column text about options that changed when plugin \"$1\" was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 21 line(s). Calls functions: .zinit-format-options |-- .zinit-restore-extendedglob `-- .zinit-save-set-extendedglob Called by: .zinit-show-report","title":".zinit-format-options"},{"location":"zinit-autoload.zsh/#zinit-format-parameter","text":"Creates one column text that lists global parameters that changed when the given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 34 line(s). Doesn't call other functions. Called by: .zinit-show-report","title":".zinit-format-parameter"},{"location":"zinit-autoload.zsh/#zinit-get-completion-owner","text":"Returns \"user---plugin\" string (uspl1 format) of plugin that owns given completion. Both :A and readlink will be used, then readlink's output if results differ. Readlink might not be available. :A will read the link \"twice\" and give the final repository directory, possibly without username in the uspl format; readlink will read the link \"once\" $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 22 line(s). Doesn't call other functions. Called by: .zinit-clear-completions .zinit-get-completion-owner-uspl2col .zinit-show-completions","title":".zinit-get-completion-owner"},{"location":"zinit-autoload.zsh/#zinit-get-completion-owner-uspl2col","text":"For shortening of code - returns colorized plugin name that owns given completion. $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 2 line(s). Calls functions: .zinit-get-completion-owner-uspl2col |-- .zinit-get-completion-owner `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: .zinit-cdisable .zinit-cenable","title":".zinit-get-completion-owner-uspl2col"},{"location":"zinit-autoload.zsh/#zinit-get-path","text":"Returns path of given ID-string, which may be a plugin-spec (like \"user/plugin\" or \"user\" \"plugin\"), an absolute path (\"%\" \"/home/...\" and also \"%SNIPPETS/...\" etc.), or a plugin nickname (i.e. id-as'' ice-mod), or a snippet nickname. Has 35 line(s). Calls functions: .zinit-get-path |-- zinit-side.zsh/.zinit-exists-physically |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-cd .zinit-uninstall-completions","title":".zinit-get-path"},{"location":"zinit-autoload.zsh/#zinit-glance","text":"Shows colorized source code of plugin. Is able to use pygmentize, highlight, GNU source-highlight. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 39 line(s). Calls functions: .zinit-glance |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-glance"},{"location":"zinit-autoload.zsh/#zinit-help","text":"Shows usage information. User-action entry point. Has 68 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit","title":".zinit-help"},{"location":"zinit-autoload.zsh/#zinit-list-bindkeys","text":"Has 42 line(s). Calls functions: .zinit-list-bindkeys `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-list-bindkeys"},{"location":"zinit-autoload.zsh/#zinit-list-compdef-replay","text":"Shows recorded compdefs (called by plugins loaded earlier). Plugins often call `compdef' hoping for `compinit' being already ran. Zinit solves this by recording compdefs. User-action entry point. Has 5 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit","title":".zinit-list-compdef-replay"},{"location":"zinit-autoload.zsh/#zinit-ls","text":"Has 19 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit","title":".zinit-ls"},{"location":"zinit-autoload.zsh/#zinit-module","text":"Function that has sub-commands passed as long-options (with two dashes, --). It's an attempt to plugin only this one function into `zinit' function defined in zinit.zsh, to not make this file longer than it's needed. Has 24 line(s). Calls functions: .zinit-module `-- .zinit-build-module Called by: .zinit-build-module zinit.zsh/zinit","title":".zinit-module"},{"location":"zinit-autoload.zsh/#zinit-prepare-readlink","text":"Prepares readlink command, used for establishing completion's owner. $REPLY = \":\" or \"readlink\" Has 4 line(s). Doesn't call other functions. Uses feature(s): type Called by: .zinit-cdisable .zinit-cenable .zinit-clear-completions .zinit-show-completions","title":".zinit-prepare-readlink"},{"location":"zinit-autoload.zsh/#zinit-recall","text":"Has 37 line(s). Calls functions: .zinit-recall `-- .zinit-compute-ice |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-pack-ice Uses feature(s): wait Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-recall"},{"location":"zinit-autoload.zsh/#zinit-recently","text":"Shows plugins that obtained commits in specified past time. User-action entry point. $1 - time spec, e.g. \"1 week\" Has 26 line(s). Calls functions: .zinit-recently `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-recently"},{"location":"zinit-autoload.zsh/#zinit-restore-extendedglob","text":"Restores extendedglob-option from state saved earlier. Has 1 line(s). Doesn't call other functions. Called by: .zinit-format-options .zinit-show-registered-plugins .zinit-unload","title":".zinit-restore-extendedglob"},{"location":"zinit-autoload.zsh/#zinit-save-set-extendedglob","text":"Enables extendedglob-option first saving if it was already enabled, for restoration of this state later. Has 2 line(s). Doesn't call other functions. Called by: .zinit-format-options .zinit-show-registered-plugins .zinit-unload","title":".zinit-save-set-extendedglob"},{"location":"zinit-autoload.zsh/#zinit-search-completions","text":"While .zinit-show-completions() shows what completions are installed, this functions searches through all plugin dirs showing what's available in general (for installation). User-action entry point. Has 43 line(s). Calls functions: .zinit-search-completions `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-search-completions"},{"location":"zinit-autoload.zsh/#zinit-self-update","text":"Updates Zinit code (does a git pull). User-action entry point. Has 23 line(s). Doesn't call other functions. Uses feature(s): zcompile Called by: zinit.zsh/zinit","title":".zinit-self-update"},{"location":"zinit-autoload.zsh/#zinit-show-all-reports","text":"Displays reports of all loaded plugins. User-action entry point. Has 5 line(s). Calls functions: .zinit-show-all-reports `-- .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit","title":".zinit-show-all-reports"},{"location":"zinit-autoload.zsh/#zinit-show-completions","text":"Display installed (enabled and disabled), completions. Detect stray and improper ones. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 72 line(s). Calls functions: .zinit-show-completions |-- .zinit-get-completion-owner |-- .zinit-prepare-readlink `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-show-completions"},{"location":"zinit-autoload.zsh/#zinit-show-debug-report","text":"Displays dtrace report (data recorded in interactive session). User-action entry point. Has 1 line(s). Calls functions: .zinit-show-debug-report `-- .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit","title":".zinit-show-debug-report"},{"location":"zinit-autoload.zsh/#zinit-show-registered-plugins","text":"Lists loaded plugins (subcommands list, lodaded). User-action entry point. Has 21 line(s). Calls functions: .zinit-show-registered-plugins |-- .zinit-restore-extendedglob |-- .zinit-save-set-extendedglob `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-show-registered-plugins"},{"location":"zinit-autoload.zsh/#zinit-show-report","text":"Displays report of the plugin given. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 71 line(s). Calls functions: .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-show-all-reports .zinit-show-debug-report zinit.zsh/zinit","title":".zinit-show-report"},{"location":"zinit-autoload.zsh/#zinit-show-times","text":"Shows loading times of all loaded plugins. User-action entry point. Has 42 line(s). Calls functions: .zinit-show-times `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-show-times"},{"location":"zinit-autoload.zsh/#zinit-show-zstatus","text":"Shows Zinit status, i.e. number of loaded plugins, of available completions, etc. User-action entry point. Has 41 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit","title":".zinit-show-zstatus"},{"location":"zinit-autoload.zsh/#zinit-stress","text":"Compiles plugin with various options on and off to see how well the code is written. The options are: NO_SHORT_LOOPS, IGNORE_BRACES, IGNORE_CLOSE_BRACES, SH_GLOB, CSH_JUNKIE_QUOTES, NO_MULTI_FUNC_DEF. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 35 line(s). Calls functions: .zinit-stress |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): zcompile Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-stress"},{"location":"zinit-autoload.zsh/#zinit-uncompile-plugin","text":"Uncompiles given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 22 line(s). Calls functions: .zinit-uncompile-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-compile-uncompile-all zinit.zsh/zinit","title":".zinit-uncompile-plugin"},{"location":"zinit-autoload.zsh/#zinit-uninstall-completions","text":"Removes all completions of given plugin from Zshell (i.e. from FPATH). The FPATH is typically `~/.zinit/completions/'. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 41 line(s). Calls functions: .zinit-uninstall-completions |-- .zinit-get-path | |-- zinit-side.zsh/.zinit-exists-physically | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | `-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit-install.zsh/.zinit-forget-completion Called by: zinit.zsh/zinit","title":".zinit-uninstall-completions"},{"location":"zinit-autoload.zsh/#zinit-unload","text":"0. Call the Zsh Plugin's Standard *_plugin_unload function 1. Delete bindkeys (...) 2. Delete Zstyles 3. Restore options 4. Remove aliases 5. Restore Zle state 6. Unfunction functions (created by plugin) 7. Clean-up FPATH and PATH 8. Delete created variables 9. Forget the plugin User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 347 line(s). Calls functions: .zinit-unload |-- .zinit-clear-report-for | `-- .zinit-any-to-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-restore-extendedglob |-- .zinit-save-set-extendedglob |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit.zsh/.zinit-clear-debug-report `-- zinit.zsh/.zinit-unregister-plugin Uses feature(s): alias , bindkey , unalias , unfunction , zle , zstyle Called by: zinit.zsh/.zinit-debug-unload zinit.zsh/.zinit-run-task zinit.zsh/zinit","title":".zinit-unload"},{"location":"zinit-autoload.zsh/#zinit-update-or-status","text":"Updates (git pull) or does `git status' for given plugin. User-action entry point. $1 - \"status\" for status, other for update $2 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $3 - plugin (only when $1 - i.e. user - given) Has 212 line(s). Calls functions: .zinit-update-or-status |-- .zinit-at-eval |-- .zinit-compute-ice | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | |-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit.zsh/.zinit-pack-ice |-- .zinit-update-or-status-snippet | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | `-- zinit.zsh/.zinit-load-snippet |-- zinit-install.zsh/.zinit-get-latest-gh-r-version |-- zinit-install.zsh/.zinit-setup-plugin-dir |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-store-ices |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): kill , read , source , wait Called by: .zinit-update-or-status-all zinit.zsh/zinit","title":".zinit-update-or-status"},{"location":"zinit-autoload.zsh/#zinit-update-or-status-all","text":"Updates (git pull) or does `git status` for all existing plugins. This includes also plugins that are not loaded into Zsh (but exist on disk). Also updates (i.e. redownloads) snippets. User-action entry point. Has 63 line(s). Calls functions: .zinit-update-or-status-all |-- .zinit-update-or-status | |-- .zinit-at-eval | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | |-- .zinit-update-or-status-snippet | | |-- .zinit-compute-ice | | | |-- zinit-side.zsh/.zinit-exists-physically-message | | | |-- zinit-side.zsh/.zinit-shands-exp | | | |-- zinit-side.zsh/.zinit-two-paths | | | |-- zinit.zsh/.zinit-any-to-user-plugin | | | `-- zinit.zsh/.zinit-pack-ice | | `-- zinit.zsh/.zinit-load-snippet | |-- zinit-install.zsh/.zinit-get-latest-gh-r-version | |-- zinit-install.zsh/.zinit-setup-plugin-dir | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-store-ices | |-- zinit-side.zsh/.zinit-two-paths | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-update-or-status-snippet | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | `-- zinit.zsh/.zinit-load-snippet |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit","title":".zinit-update-or-status-all"},{"location":"zinit-autoload.zsh/#zinit-update-or-status-snippet","text":"Implements update or status operation for snippet given by URL. $1 - \"status\" or \"update\" $2 - snippet URL Has 19 line(s). Calls functions: .zinit-update-or-status-snippet |-- .zinit-compute-ice | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | |-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit.zsh/.zinit-pack-ice `-- zinit.zsh/.zinit-load-snippet Called by: .zinit-update-or-status-all .zinit-update-or-status","title":".zinit-update-or-status-snippet"},{"location":"zinit-autoload.zsh/#compinit","text":"Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: .zinit-compinit","title":"compinit"},{"location":"zinit-install.zsh/","text":"zinit-install.zsh(1) # NAME # zinit-install.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # .zinit-at-eval .zinit-compile-plugin .zinit-download-file-stdout .zinit-download-snippet .zinit-forget-completion .zinit-get-latest-gh-r-version .zinit-handle-binary-file .zinit-install-completions .zinit-mirror-using-svn .zinit-setup-plugin-dir DETAILS # Script Body # Has 3 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source .zinit-at-eval # Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-download-snippet .zinit-compile-plugin # Compiles given plugin (its main source file, and also an additional \"....zsh\" file if it exists). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 50 line(s). Calls functions: .zinit-compile-plugin |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): eval , zcompile Called by: .zinit-setup-plugin-dir zinit-autoload.zsh/.zinit-compile-uncompile-all zinit.zsh/zinit .zinit-download-file-stdout # Downloads file to stdout. Supports following backend commands: curl, wget, lftp, lynx. Used by snippet loading. Has 32 line(s). Calls functions: .zinit-download-file-stdout Uses feature(s): type Called by: .zinit-download-snippet .zinit-setup-plugin-dir .zinit-download-snippet # Downloads snippet \u2013 either a file \u2013 with curl, wget, lftp or lynx, or a directory, with Subversion \u2013 when svn-ICE is active. Github supports Subversion protocol and allows to clone subdirectories. This is used to provide a layer of support for Oh-My-Zsh and Prezto. Has 233 line(s). Calls functions: .zinit-download-snippet |-- .zinit-at-eval |-- .zinit-download-file-stdout |-- .zinit-install-completions | |-- .zinit-forget-completion | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-mirror-using-svn `-- zinit-side.zsh/.zinit-store-ices Uses feature(s): eval , zcompile Called by: zinit.zsh/.zinit-load-snippet .zinit-forget-completion # Implements alternation of Zsh state so that already initialized completion stops being visible to Zsh. $1 - completion function name, e.g. \"_cp\"; can also be \"cp\" Has 15 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-install-completions zinit-autoload.zsh/.zinit-compinit zinit-autoload.zsh/.zinit-uninstall-completions zinit.zsh/zinit .zinit-get-latest-gh-r-version # Gets version string of latest release of given Github package. Connects to Github releases page. Has 14 line(s). Calls functions: .zinit-get-latest-gh-r-version `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit-autoload.zsh/.zinit-update-or-status .zinit-handle-binary-file # If the file is an archive, it is extracted by this function. Next stage is scanning of files with the common utility `file', to detect executables. They are given +x mode. There are also messages to the user on performed actions. $1 - url $2 - file Has 66 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-setup-plugin-dir .zinit-install-completions # Installs all completions of given plugin. After that they are visible to `compinit'. Visible completions can be selectively disabled and enabled. User can access completion data with `clist' or `completions' subcommand. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $3 - if 1, then reinstall, otherwise only install completions that aren't there Has 34 line(s). Calls functions: .zinit-install-completions |-- .zinit-forget-completion |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically-message `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-download-snippet .zinit-setup-plugin-dir zinit.zsh/zinit .zinit-mirror-using-svn # Used to clone subdirectories from Github. If in update mode (see $2), then invokes `svn update', in normal mode invokes `svn checkout --non-interactive -q <URL>'. In test mode only compares remote and local revision and outputs true if update is needed. $1 - URL $2 - mode, \"\" - normal, \"-u\" - update, \"-t\" - test $3 - subdirectory (not path) with working copy, needed for -t and -u Has 27 line(s). Doesn't call other functions. Called by: .zinit-download-snippet .zinit-setup-plugin-dir # Clones given plugin into PLUGIN_DIR. Supports multiple sites (respecting `from' and `proto' ice modifiers). Invokes compilation of plugin's main file. $1 - user $2 - plugin Has 182 line(s). Calls functions: .zinit-setup-plugin-dir |-- .zinit-compile-plugin | |-- zinit-side.zsh/.zinit-first | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-download-file-stdout |-- .zinit-handle-binary-file |-- .zinit-install-completions | |-- .zinit-forget-completion | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | `-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit-side.zsh/.zinit-store-ices Uses feature(s): eval Called by: zinit-autoload.zsh/.zinit-update-or-status zinit.zsh/.zinit-load","title":"zinit-install.zsh"},{"location":"zinit-install.zsh/#zinit-installzsh1","text":"","title":"zinit-install.zsh(1)"},{"location":"zinit-install.zsh/#name","text":"zinit-install.zsh - a shell script","title":"NAME"},{"location":"zinit-install.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zinit-install.zsh/#functions","text":".zinit-at-eval .zinit-compile-plugin .zinit-download-file-stdout .zinit-download-snippet .zinit-forget-completion .zinit-get-latest-gh-r-version .zinit-handle-binary-file .zinit-install-completions .zinit-mirror-using-svn .zinit-setup-plugin-dir","title":"FUNCTIONS"},{"location":"zinit-install.zsh/#details","text":"","title":"DETAILS"},{"location":"zinit-install.zsh/#script_body","text":"Has 3 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source","title":"Script Body"},{"location":"zinit-install.zsh/#zinit-at-eval","text":"Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-download-snippet","title":".zinit-at-eval"},{"location":"zinit-install.zsh/#zinit-compile-plugin","text":"Compiles given plugin (its main source file, and also an additional \"....zsh\" file if it exists). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 50 line(s). Calls functions: .zinit-compile-plugin |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): eval , zcompile Called by: .zinit-setup-plugin-dir zinit-autoload.zsh/.zinit-compile-uncompile-all zinit.zsh/zinit","title":".zinit-compile-plugin"},{"location":"zinit-install.zsh/#zinit-download-file-stdout","text":"Downloads file to stdout. Supports following backend commands: curl, wget, lftp, lynx. Used by snippet loading. Has 32 line(s). Calls functions: .zinit-download-file-stdout Uses feature(s): type Called by: .zinit-download-snippet .zinit-setup-plugin-dir","title":".zinit-download-file-stdout"},{"location":"zinit-install.zsh/#zinit-download-snippet","text":"Downloads snippet \u2013 either a file \u2013 with curl, wget, lftp or lynx, or a directory, with Subversion \u2013 when svn-ICE is active. Github supports Subversion protocol and allows to clone subdirectories. This is used to provide a layer of support for Oh-My-Zsh and Prezto. Has 233 line(s). Calls functions: .zinit-download-snippet |-- .zinit-at-eval |-- .zinit-download-file-stdout |-- .zinit-install-completions | |-- .zinit-forget-completion | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-mirror-using-svn `-- zinit-side.zsh/.zinit-store-ices Uses feature(s): eval , zcompile Called by: zinit.zsh/.zinit-load-snippet","title":".zinit-download-snippet"},{"location":"zinit-install.zsh/#zinit-forget-completion","text":"Implements alternation of Zsh state so that already initialized completion stops being visible to Zsh. $1 - completion function name, e.g. \"_cp\"; can also be \"cp\" Has 15 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-install-completions zinit-autoload.zsh/.zinit-compinit zinit-autoload.zsh/.zinit-uninstall-completions zinit.zsh/zinit","title":".zinit-forget-completion"},{"location":"zinit-install.zsh/#zinit-get-latest-gh-r-version","text":"Gets version string of latest release of given Github package. Connects to Github releases page. Has 14 line(s). Calls functions: .zinit-get-latest-gh-r-version `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit-autoload.zsh/.zinit-update-or-status","title":".zinit-get-latest-gh-r-version"},{"location":"zinit-install.zsh/#zinit-handle-binary-file","text":"If the file is an archive, it is extracted by this function. Next stage is scanning of files with the common utility `file', to detect executables. They are given +x mode. There are also messages to the user on performed actions. $1 - url $2 - file Has 66 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-setup-plugin-dir","title":".zinit-handle-binary-file"},{"location":"zinit-install.zsh/#zinit-install-completions","text":"Installs all completions of given plugin. After that they are visible to `compinit'. Visible completions can be selectively disabled and enabled. User can access completion data with `clist' or `completions' subcommand. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $3 - if 1, then reinstall, otherwise only install completions that aren't there Has 34 line(s). Calls functions: .zinit-install-completions |-- .zinit-forget-completion |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically-message `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-download-snippet .zinit-setup-plugin-dir zinit.zsh/zinit","title":".zinit-install-completions"},{"location":"zinit-install.zsh/#zinit-mirror-using-svn","text":"Used to clone subdirectories from Github. If in update mode (see $2), then invokes `svn update', in normal mode invokes `svn checkout --non-interactive -q <URL>'. In test mode only compares remote and local revision and outputs true if update is needed. $1 - URL $2 - mode, \"\" - normal, \"-u\" - update, \"-t\" - test $3 - subdirectory (not path) with working copy, needed for -t and -u Has 27 line(s). Doesn't call other functions. Called by: .zinit-download-snippet","title":".zinit-mirror-using-svn"},{"location":"zinit-install.zsh/#zinit-setup-plugin-dir","text":"Clones given plugin into PLUGIN_DIR. Supports multiple sites (respecting `from' and `proto' ice modifiers). Invokes compilation of plugin's main file. $1 - user $2 - plugin Has 182 line(s). Calls functions: .zinit-setup-plugin-dir |-- .zinit-compile-plugin | |-- zinit-side.zsh/.zinit-first | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-download-file-stdout |-- .zinit-handle-binary-file |-- .zinit-install-completions | |-- .zinit-forget-completion | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | `-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit-side.zsh/.zinit-store-ices Uses feature(s): eval Called by: zinit-autoload.zsh/.zinit-update-or-status zinit.zsh/.zinit-load","title":".zinit-setup-plugin-dir"},{"location":"zinit-side.zsh/","text":"zinit-side.zsh(1) # NAME # zinit-side.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # .zinit-any-colorify-as-uspl2 .zinit-exists-physically .zinit-exists-physically-message .zinit-first .zinit-get-plg-dir .zinit-shands-exp .zinit-store-ices .zinit-two-paths DETAILS # Script Body # Has 1 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). .zinit-any-colorify-as-uspl2 # Returns ANSI-colorified \"user/plugin\" string, from any supported plugin spec (user---plugin, user/plugin, user plugin, plugin). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $REPLY = ANSI-colorified \"user/plugin\" string Has 11 line(s). Calls functions: .zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-exists-physically-message zinit-autoload.zsh/.zinit-clear-completions zinit-autoload.zsh/.zinit-compiled zinit-autoload.zsh/.zinit-compile-uncompile-all zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-exists-message zinit-autoload.zsh/.zinit-get-completion-owner-uspl2col zinit-autoload.zsh/.zinit-list-bindkeys zinit-autoload.zsh/.zinit-recently zinit-autoload.zsh/.zinit-search-completions zinit-autoload.zsh/.zinit-show-completions zinit-autoload.zsh/.zinit-show-registered-plugins zinit-autoload.zsh/.zinit-show-times zinit-autoload.zsh/.zinit-uncompile-plugin zinit-autoload.zsh/.zinit-unload zinit-autoload.zsh/.zinit-update-or-status-all zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-install-completions zinit-install.zsh/.zinit-setup-plugin-dir .zinit-exists-physically # Checks if directory of given plugin exists in PLUGIN_DIR. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 10 line(s). Calls functions: .zinit-exists-physically |-- .zinit-shands-exp `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-exists-physically-message zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-get-path .zinit-exists-physically-message # Checks if directory of given plugin exists in PLUGIN_DIR, and outputs error message if it doesn't. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 11 line(s). Calls functions: .zinit-exists-physically-message |-- .zinit-any-colorify-as-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-exists-physically | |-- .zinit-shands-exp | `-- zinit.zsh/.zinit-any-to-user-plugin `-- .zinit-shands-exp Called by: zinit-autoload.zsh/.zinit-changes zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-stress zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-install-completions .zinit-first # Finds the main file of plugin. There are multiple file name formats, they are ordered in order starting from more correct ones, and matched. .zinit-load-plugin() has similar code parts and doesn't call .zinit-first() \u2013 for performance. Obscure matching is done in .zinit-find-other-matches, here and in .zinit-load(). Obscure = non-standard main-file naming convention. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 17 line(s). Calls functions: .zinit-first |-- .zinit-get-plg-dir |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-find-other-matches Called by: zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-stress zinit-install.zsh/.zinit-compile-plugin .zinit-get-plg-dir # Has 9 line(s). Doesn't call other functions. Called by: .zinit-first .zinit-shands-exp # Does expansion of currently little unstandarized shorthands like \"%SNIPPETS\", \"%HOME\", \"OMZ::\", \"PZT::\". Has 3 line(s). Doesn't call other functions. Called by: .zinit-exists-physically-message .zinit-exists-physically zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-get-path .zinit-store-ices # Saves ice mods in given hash onto disk. $1 - directory where to create / delete files $2 - name of hash that holds values $3 - additional keys of hash to store, space separated $4 - additional keys of hash to store, empty-meaningful ices, space separated Has 30 line(s). Doesn't call other functions. Uses feature(s): wait Called by: zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-download-snippet zinit-install.zsh/.zinit-setup-plugin-dir .zinit-two-paths # Obtains a snippet URL without specification if it is an SVN URL (points to directory) or regular URL (points to file), returns 2 possible paths for further examination Has 19 line(s). Doesn't call other functions. Called by: zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-get-path zinit-autoload.zsh/.zinit-update-or-status","title":"zinit-side.zsh"},{"location":"zinit-side.zsh/#zinit-sidezsh1","text":"","title":"zinit-side.zsh(1)"},{"location":"zinit-side.zsh/#name","text":"zinit-side.zsh - a shell script","title":"NAME"},{"location":"zinit-side.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zinit-side.zsh/#functions","text":".zinit-any-colorify-as-uspl2 .zinit-exists-physically .zinit-exists-physically-message .zinit-first .zinit-get-plg-dir .zinit-shands-exp .zinit-store-ices .zinit-two-paths","title":"FUNCTIONS"},{"location":"zinit-side.zsh/#details","text":"","title":"DETAILS"},{"location":"zinit-side.zsh/#script_body","text":"Has 1 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.).","title":"Script Body"},{"location":"zinit-side.zsh/#zinit-any-colorify-as-uspl2","text":"Returns ANSI-colorified \"user/plugin\" string, from any supported plugin spec (user---plugin, user/plugin, user plugin, plugin). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $REPLY = ANSI-colorified \"user/plugin\" string Has 11 line(s). Calls functions: .zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-exists-physically-message zinit-autoload.zsh/.zinit-clear-completions zinit-autoload.zsh/.zinit-compiled zinit-autoload.zsh/.zinit-compile-uncompile-all zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-exists-message zinit-autoload.zsh/.zinit-get-completion-owner-uspl2col zinit-autoload.zsh/.zinit-list-bindkeys zinit-autoload.zsh/.zinit-recently zinit-autoload.zsh/.zinit-search-completions zinit-autoload.zsh/.zinit-show-completions zinit-autoload.zsh/.zinit-show-registered-plugins zinit-autoload.zsh/.zinit-show-times zinit-autoload.zsh/.zinit-uncompile-plugin zinit-autoload.zsh/.zinit-unload zinit-autoload.zsh/.zinit-update-or-status-all zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-install-completions zinit-install.zsh/.zinit-setup-plugin-dir","title":".zinit-any-colorify-as-uspl2"},{"location":"zinit-side.zsh/#zinit-exists-physically","text":"Checks if directory of given plugin exists in PLUGIN_DIR. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 10 line(s). Calls functions: .zinit-exists-physically |-- .zinit-shands-exp `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-exists-physically-message zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-get-path","title":".zinit-exists-physically"},{"location":"zinit-side.zsh/#zinit-exists-physically-message","text":"Checks if directory of given plugin exists in PLUGIN_DIR, and outputs error message if it doesn't. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 11 line(s). Calls functions: .zinit-exists-physically-message |-- .zinit-any-colorify-as-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-exists-physically | |-- .zinit-shands-exp | `-- zinit.zsh/.zinit-any-to-user-plugin `-- .zinit-shands-exp Called by: zinit-autoload.zsh/.zinit-changes zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-stress zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-install-completions","title":".zinit-exists-physically-message"},{"location":"zinit-side.zsh/#zinit-first","text":"Finds the main file of plugin. There are multiple file name formats, they are ordered in order starting from more correct ones, and matched. .zinit-load-plugin() has similar code parts and doesn't call .zinit-first() \u2013 for performance. Obscure matching is done in .zinit-find-other-matches, here and in .zinit-load(). Obscure = non-standard main-file naming convention. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 17 line(s). Calls functions: .zinit-first |-- .zinit-get-plg-dir |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-find-other-matches Called by: zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-stress zinit-install.zsh/.zinit-compile-plugin","title":".zinit-first"},{"location":"zinit-side.zsh/#zinit-get-plg-dir","text":"Has 9 line(s). Doesn't call other functions. Called by: .zinit-first","title":".zinit-get-plg-dir"},{"location":"zinit-side.zsh/#zinit-shands-exp","text":"Does expansion of currently little unstandarized shorthands like \"%SNIPPETS\", \"%HOME\", \"OMZ::\", \"PZT::\". Has 3 line(s). Doesn't call other functions. Called by: .zinit-exists-physically-message .zinit-exists-physically zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-get-path","title":".zinit-shands-exp"},{"location":"zinit-side.zsh/#zinit-store-ices","text":"Saves ice mods in given hash onto disk. $1 - directory where to create / delete files $2 - name of hash that holds values $3 - additional keys of hash to store, space separated $4 - additional keys of hash to store, empty-meaningful ices, space separated Has 30 line(s). Doesn't call other functions. Uses feature(s): wait Called by: zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-download-snippet zinit-install.zsh/.zinit-setup-plugin-dir","title":".zinit-store-ices"},{"location":"zinit-side.zsh/#zinit-two-paths","text":"Obtains a snippet URL without specification if it is an SVN URL (points to directory) or regular URL (points to file), returns 2 possible paths for further examination Has 19 line(s). Doesn't call other functions. Called by: zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-get-path zinit-autoload.zsh/.zinit-update-or-status","title":".zinit-two-paths"},{"location":"zinit.zsh/","text":"zinit.zsh(1) # NAME # zinit.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # pmodload zpcdclear zpcdreplay zpcompdef zpcompinit .zinit-add-report .zinit-any-to-user-plugin .zinit-clear-debug-report .zinit-compdef-clear .zinit-compdef-replay .zinit-debug-start .zinit-debug-stop .zinit-debug-unload .zinit-deploy-message .zinit-diff .zinit-diff-env .zinit-diff-functions .zinit-diff-options .zinit-diff-parameter .zinit-find-other-matches .zinit-ice .zinit-load .zinit-load-plugin .zinit-load-snippet .zinit-pack-ice .zinit-prepare-home .zinit-register-plugin @zplg-register-z-plugin :zinit-reload-and-run .zinit-run-task .zinit-service :zinit-shadow-alias :zinit-shadow-autoload :zinit-shadow-bindkey :zinit-shadow-compdef .zinit-shadow-off .zinit-shadow-on :zinit-shadow-zle :zinit-shadow-zstyle .zinit-submit-turbo .zinit-unregister-plugin .zinit-wrap-track-functions zinit -zinit_scheduler_add_sh AUTOLOAD add-zsh-hook AUTOLOAD compinit AUTOLOAD is-at-least PRECMD-HOOK @zinit-scheduler DETAILS # Script Body # Has 117 line(s). Calls functions: Script-Body |-- add-zsh-hook |-- is-at-least `-- .zinit-prepare-home Uses feature(s): alias , autoload , export , zmodload , zstyle Exports (environment): ZPFX pmodload # Compatibility with Prezto. Calls can be recursive. Has 9 line(s). Calls functions: pmodload `-- .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcdclear # A wrapper for `zinit cdclear -q' which can be called from hook ices like the atinit'', atload'', etc. ices. Has 1 line(s). Calls functions: zpcdclear `-- .zinit-compdef-clear Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcdreplay # A function that can be invoked from within `atinit', `atload', etc. ice-mod. It works like `zinit cdreplay', which cannot be invoked from such hook ices. Has 1 line(s). Calls functions: zpcdreplay `-- .zinit-compdef-replay Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcompdef # Stores compdef for a replay with `zpcdreplay' (turbo mode) or with `zinit cdreplay' (normal mode). An utility functton of an undefined use case. Has 1 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcompinit # A function that can be invoked from within `atinit', `atload', etc. ice-mod. It runs `autoload compinit; compinit' and respects ZINIT[ZCOMPDUMP_PATH] and ZINIT[COMPINIT_OPTS]. Has 1 line(s). Calls functions: zpcompinit `-- compinit Uses feature(s): autoload Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-add-report # Adds a report line for given plugin. $1 - uspl2, i.e. user/plugin $2, ... - the text Has 2 line(s). Doesn't call other functions. Called by: .zinit-load-plugin :zinit-shadow-alias :zinit-shadow-autoload :zinit-shadow-bindkey :zinit-shadow-compdef :zinit-shadow-zle :zinit-shadow-zstyle .zinit-any-to-user-plugin # Allows elastic plugin-spec across the code. $1 - plugin spec (2 formats: user/plugin, user plugin) $2 - plugin (only when $1 - i.e. user - given) Returns user and plugin in $reply Has 23 line(s). Doesn't call other functions. Called by: .zinit-load .zinit-unregister-plugin zinit-autoload.zsh/.zinit-any-to-uspl2 zinit-autoload.zsh/.zinit-changes zinit-autoload.zsh/.zinit-compiled zinit-autoload.zsh/.zinit-compile-uncompile-all zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-find-completions-of-plugin zinit-autoload.zsh/.zinit-get-path zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-show-report zinit-autoload.zsh/.zinit-stress zinit-autoload.zsh/.zinit-uncompile-plugin zinit-autoload.zsh/.zinit-unload zinit-autoload.zsh/.zinit-update-or-status-all zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-compile-plugin zinit-install.zsh/.zinit-get-latest-gh-r-version zinit-install.zsh/.zinit-install-completions zinit-side.zsh/.zinit-any-colorify-as-uspl2 zinit-side.zsh/.zinit-exists-physically zinit-side.zsh/.zinit-first .zinit-clear-debug-report # Forgets dtrace repport gathered up to this moment. Has 1 line(s). Calls functions: .zinit-clear-debug-report `-- zinit-autoload.zsh/.zinit-clear-report-for Called by: zinit zinit-autoload.zsh/.zinit-unload .zinit-compdef-clear # Implements user-exposed functionality to clear gathered compdefs. Has 3 line(s). Doesn't call other functions. Called by: zpcdclear zinit .zinit-compdef-replay # Runs gathered compdef calls. This allows to run `compinit' after loading plugins. Has 16 line(s). Doesn't call other functions. Called by: zpcdreplay zinit .zinit-debug-start # Starts Dtrace, i.e. session tracking for changes in Zsh state. Has 9 line(s). Calls functions: .zinit-debug-start |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter `-- .zinit-shadow-on Called by: zinit .zinit-debug-stop # Stops Dtrace, i.e. session tracking for changes in Zsh state. Has 3 line(s). Calls functions: .zinit-debug-stop |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter `-- .zinit-shadow-off Called by: zinit .zinit-debug-unload # Reverts changes detected by dtrace run. Has 5 line(s). Calls functions: .zinit-debug-unload `-- zinit-autoload.zsh/.zinit-unload Called by: zinit .zinit-deploy-message # Deploys a sub-prompt message to be displayed OR a `zle .reset-prompt' call to be invoked Has 12 line(s). Doesn't call other functions. Uses feature(s): read , zle Called by: .zinit-load-snippet .zinit-load .zinit-diff # Performs diff actions of all types Has 4 line(s). Calls functions: .zinit-diff |-- .zinit-diff-env |-- .zinit-diff-functions |-- .zinit-diff-options `-- .zinit-diff-parameter Called by: .zinit-debug-start .zinit-debug-stop .zinit-load-plugin .zinit-diff-env # Implements detection of change in PATH and FPATH. $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 18 line(s). Doesn't call other functions. Called by: .zinit-diff .zinit-load-plugin .zinit-diff-functions # Implements detection of newly created functions. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 8 line(s). Doesn't call other functions. Called by: .zinit-diff .zinit-diff-options # Implements detection of change in option state. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 7 line(s). Doesn't call other functions. Called by: .zinit-diff .zinit-diff-parameter # Implements detection of change in any parameter's existence and type. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 9 line(s). Doesn't call other functions. Called by: .zinit-diff .zinit-find-other-matches # Plugin's main source file is in general `name.plugin.zsh'. However, there can be different conventions, if that file is not found, then this functions examines other conventions in order of most expected sanity. Has 14 line(s). Doesn't call other functions. Called by: .zinit-load-plugin zinit-side.zsh/.zinit-first .zinit-ice # Parses ICE specification (`zplg ice' subcommand), puts the result into ZINIT_ICE global hash. The ice-spec is valid for next command only (i.e. it \"melts\"), but it can then stick to plugin and activate e.g. at update. Has 8 line(s). Doesn't call other functions. Called by: zinit Environment variables used: ZPFX .zinit-load # Implements the exposed-to-user action of loading a plugin. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin name, if the third format is used Has 42 line(s). Calls functions: .zinit-load |-- .zinit-any-to-user-plugin |-- .zinit-deploy-message |-- .zinit-load-plugin | |-- .zinit-add-report | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | |-- .zinit-diff-env | |-- .zinit-find-other-matches | |-- .zinit-shadow-off | |-- .zinit-shadow-on | `-- .zinit-wrap-track-functions |-- .zinit-pack-ice |-- .zinit-register-plugin `-- zinit-install.zsh/.zinit-setup-plugin-dir Uses feature(s): eval , source , zle Called by: .zinit-run-task .zinit-service zinit .zinit-load-plugin # Lower-level function for loading a plugin. $1 - user $2 - plugin $3 - mode (light or load) Has 96 line(s). Calls functions: .zinit-load-plugin |-- .zinit-add-report |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter |-- .zinit-diff-env |-- .zinit-find-other-matches |-- .zinit-shadow-off |-- .zinit-shadow-on `-- .zinit-wrap-track-functions Uses feature(s): eval , source , zle Called by: .zinit-load .zinit-load-snippet # Implements the exposed-to-user action of loading a snippet. $1 - url (can be local, absolute path) Has 180 line(s). Calls functions: .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): autoload , eval , source , unfunction , zparseopts , zstyle Called by: pmodload .zinit-run-task .zinit-service zinit zinit-autoload.zsh/.zinit-update-or-status-snippet .zinit-pack-ice # Remembers all ice-mods, assigns them to concrete plugin. Ice spec is in general forgotten for second-next command (that's why it's called \"ice\" - it melts), however they glue to the object (plugin or snippet) mentioned in the next command \u2013 for later use with e.g. `zinit update ...' Has 3 line(s). Doesn't call other functions. Called by: .zinit-load-snippet .zinit-load zinit-autoload.zsh/.zinit-compute-ice .zinit-prepare-home # Creates all directories needed by Zinit, first checks if they already exist. Has 28 line(s). Doesn't call other functions. Called by: Script-Body Environment variables used: ZPFX .zinit-register-plugin # Adds the plugin to ZINIT_REGISTERED_PLUGINS array and to the zsh_loaded_plugins array (managed according to the plugin standard: http://zdharma.org/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html) Has 23 line(s). Doesn't call other functions. Called by: .zinit-load @zplg-register-z-plugin # Registers the z-plugin inside Zinit \u2013 i.e. an Zinit extension Has 4 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-reload-and-run # Marks given function ($3) for autoloading, and executes it triggering the load. $1 is the fpath dedicated to the function, $2 are autoload options. This function replaces \"autoload -X\", because using that on older Zsh versions causes problems with traps. So basically one creates function stub that calls :zinit-reload-and-run() instead of \"autoload -X\". $1 - FPATH dedicated to function $2 - autoload options $3 - function name (one that needs autoloading) Author: Bart Schaefer Has 7 line(s). Doesn't call other functions. Uses feature(s): autoload , unfunction Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-run-task # A backend, worker function of .zinit-scheduler. It obtains the tasks index and a few of its properties (like the type: plugin, snippet, service plugin, service snippet) and executes it first checking for additional conditions (like non-numeric wait'' ice). $1 - the pass number, either 1st or 2nd pass $2 - the time assigned to the task $3 - type: plugin, snippet, service plugin, service snippet $4 - task's index in the ZINIT[WAIT_ICE_...] fields $5 - mode: load or light $6 - the plugin-spec or snippet URL or alias name (from id-as'') Has 41 line(s). Calls functions: .zinit-run-task |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet `-- zinit-autoload.zsh/.zinit-unload Uses feature(s): eval , source , zle , zpty Called by: @zinit-scheduler @zinit-scheduler # Searches for timeout tasks, executes them. There's an array of tasks waiting for execution, this scheduler manages them, detects which ones should be run at current moment, decides to remove (or not) them from the array after execution. $1 - if \"following\", then it is non-first (second and more) invocation of the scheduler; this results in chain of `sched' invocations that results in repetitive @zinit-scheduler activity if \"burst\", then all tasks are marked timeout and executed one by one; this is handy if e.g. a docker image starts up and needs to install all turbo-mode plugins without any hesitation (delay), i.e. \"burst\" allows to run package installations from script, not from prompt Has 62 line(s). Is a precmd hook . Calls functions: @zinit-scheduler |-- add-zsh-hook `-- .zinit-run-task |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet `-- zinit-autoload.zsh/.zinit-unload Uses feature(s): sched , zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-service # Handles given service, i.e. obtains lock, runs it, or waits if no lock $1 - type \"p\" or \"s\" (plugin or snippet) $2 - mode - for plugin (light or load) $3 - id - URL or plugin ID or alias name (from id-as'') Has 30 line(s). Calls functions: .zinit-service |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir `-- .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): kill , read Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-shadow-alias # Function defined to hijack plugin's calls to `alias' builtin. The hijacking is to gather report data (which is used in unload). Has 34 line(s). Calls functions: :zinit-shadow-alias `-- .zinit-add-report Uses feature(s): alias , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-shadow-autoload # Function defined to hijack plugin's calls to `autoload' builtin. The hijacking is not only to gather report data, but also to run custom `autoload' function, that doesn't need FPATH. Has 48 line(s). Calls functions: :zinit-shadow-autoload `-- .zinit-add-report Uses feature(s): autoload , eval , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-shadow-bindkey # Function defined to hijack plugin's calls to `bindkey' builtin. The hijacking is to gather report data (which is used in unload). Has 104 line(s). Calls functions: :zinit-shadow-bindkey |-- is-at-least `-- .zinit-add-report Uses feature(s): bindkey , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-shadow-compdef # Function defined to hijack plugin's calls to `compdef' function. The hijacking is not only for reporting, but also to save compdef calls so that `compinit' can be called after loading plugins. Has 4 line(s). Calls functions: :zinit-shadow-compdef `-- .zinit-add-report Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-shadow-off # Turn off shadowing completely for a given mode (\"load\", \"light\", \"light-b\" (i.e. the `trackbinds' mode) or \"compdef\"). Has 18 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-debug-stop .zinit-load-plugin .zinit-shadow-on # Turn on shadowing of builtins and functions according to passed mode (\"load\", \"light\", \"light-b\" or \"compdef\"). The shadowing is to gather report data, and to hijack `autoload', `bindkey' and `compdef' calls. Has 25 line(s). Doesn't call other functions. Called by: .zinit-debug-start .zinit-load-plugin :zinit-shadow-zle # Function defined to hijack plugin's calls to `zle' builtin. The hijacking is to gather report data (which is used in unload). Has 38 line(s). Calls functions: :zinit-shadow-zle `-- .zinit-add-report Uses feature(s): zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-shadow-zstyle # Function defined to hijack plugin's calls to `zstyle' builtin. The hijacking is to gather report data (which is used in unload). Has 21 line(s). Calls functions: :zinit-shadow-zstyle `-- .zinit-add-report Uses feature(s): zparseopts , zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-submit-turbo # If `zinit load`, `zinit light` or `zinit snippet` will be preceded with `wait', `load', `unload' or `on-update-of`/`subscribe' ice-mods then the plugin or snipped is to be loaded in turbo-mode, and this function adds it to internal data structures, so that @zinit-scheduler can run (load, unload) this as a task. Has 14 line(s). Doesn't call other functions. Called by: zinit .zinit-unregister-plugin # Removes the plugin from ZINIT_REGISTERED_PLUGINS array and from the zsh_loaded_plugins array (managed according to the plugin standard) Has 5 line(s). Calls functions: .zinit-unregister-plugin `-- .zinit-any-to-user-plugin Called by: zinit-autoload.zsh/.zinit-unload .zinit-wrap-track-functions # Has 19 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-load-plugin .zinit-load-snippet zinit # Main function directly exposed to user, obtains subcommand and its arguments, has completion. Has 290 line(s). Calls functions: zinit |-- compinit |-- .zinit-clear-debug-report | `-- zinit-autoload.zsh/.zinit-clear-report-for |-- .zinit-compdef-clear |-- .zinit-compdef-replay |-- .zinit-debug-start | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | `-- .zinit-shadow-on |-- .zinit-debug-stop | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | `-- .zinit-shadow-off |-- .zinit-debug-unload | `-- zinit-autoload.zsh/.zinit-unload |-- .zinit-ice |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet |-- .zinit-submit-turbo |-- zinit-autoload.zsh/.zinit-cdisable |-- zinit-autoload.zsh/.zinit-cenable |-- zinit-autoload.zsh/.zinit-clear-completions |-- zinit-autoload.zsh/.zinit-compiled |-- zinit-autoload.zsh/.zinit-compile-uncompile-all |-- zinit-autoload.zsh/.zinit-compinit |-- zinit-autoload.zsh/.zinit-help |-- zinit-autoload.zsh/.zinit-list-bindkeys |-- zinit-autoload.zsh/.zinit-list-compdef-replay |-- zinit-autoload.zsh/.zinit-ls |-- zinit-autoload.zsh/.zinit-module |-- zinit-autoload.zsh/.zinit-recently |-- zinit-autoload.zsh/.zinit-search-completions |-- zinit-autoload.zsh/.zinit-self-update |-- zinit-autoload.zsh/.zinit-show-all-reports |-- zinit-autoload.zsh/.zinit-show-completions |-- zinit-autoload.zsh/.zinit-show-debug-report |-- zinit-autoload.zsh/.zinit-show-registered-plugins |-- zinit-autoload.zsh/.zinit-show-report |-- zinit-autoload.zsh/.zinit-show-times |-- zinit-autoload.zsh/.zinit-show-zstatus |-- zinit-autoload.zsh/.zinit-uncompile-plugin |-- zinit-autoload.zsh/.zinit-uninstall-completions |-- zinit-autoload.zsh/.zinit-unload |-- zinit-autoload.zsh/.zinit-update-or-status |-- zinit-autoload.zsh/.zinit-update-or-status-all |-- zinit-install.zsh/.zinit-compile-plugin |-- zinit-install.zsh/.zinit-forget-completion `-- zinit-install.zsh/.zinit-install-completions Uses feature(s): autoload , eval , source Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zinit_scheduler_add_sh # Copies task into ZINIT_RUN array, called when a task timeouts. A small function ran from pattern in /-substitution as a math function. Has 7 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). add-zsh-hook # Has 93 line(s). Doesn't call other functions. Uses feature(s): autoload , getopts Called by: Script-Body @zinit-scheduler compinit # Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: zpcompinit zinit is-at-least # Has 56 line(s). Doesn't call other functions. Called by: Script-Body :zinit-shadow-bindkey","title":"zinit.zsh"},{"location":"zinit.zsh/#zinitzsh1","text":"","title":"zinit.zsh(1)"},{"location":"zinit.zsh/#name","text":"zinit.zsh - a shell script","title":"NAME"},{"location":"zinit.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zinit.zsh/#functions","text":"pmodload zpcdclear zpcdreplay zpcompdef zpcompinit .zinit-add-report .zinit-any-to-user-plugin .zinit-clear-debug-report .zinit-compdef-clear .zinit-compdef-replay .zinit-debug-start .zinit-debug-stop .zinit-debug-unload .zinit-deploy-message .zinit-diff .zinit-diff-env .zinit-diff-functions .zinit-diff-options .zinit-diff-parameter .zinit-find-other-matches .zinit-ice .zinit-load .zinit-load-plugin .zinit-load-snippet .zinit-pack-ice .zinit-prepare-home .zinit-register-plugin @zplg-register-z-plugin :zinit-reload-and-run .zinit-run-task .zinit-service :zinit-shadow-alias :zinit-shadow-autoload :zinit-shadow-bindkey :zinit-shadow-compdef .zinit-shadow-off .zinit-shadow-on :zinit-shadow-zle :zinit-shadow-zstyle .zinit-submit-turbo .zinit-unregister-plugin .zinit-wrap-track-functions zinit -zinit_scheduler_add_sh AUTOLOAD add-zsh-hook AUTOLOAD compinit AUTOLOAD is-at-least PRECMD-HOOK @zinit-scheduler","title":"FUNCTIONS"},{"location":"zinit.zsh/#details","text":"","title":"DETAILS"},{"location":"zinit.zsh/#script_body","text":"Has 117 line(s). Calls functions: Script-Body |-- add-zsh-hook |-- is-at-least `-- .zinit-prepare-home Uses feature(s): alias , autoload , export , zmodload , zstyle Exports (environment): ZPFX","title":"Script Body"},{"location":"zinit.zsh/#pmodload","text":"Compatibility with Prezto. Calls can be recursive. Has 9 line(s). Calls functions: pmodload `-- .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"pmodload"},{"location":"zinit.zsh/#zpcdclear","text":"A wrapper for `zinit cdclear -q' which can be called from hook ices like the atinit'', atload'', etc. ices. Has 1 line(s). Calls functions: zpcdclear `-- .zinit-compdef-clear Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcdclear"},{"location":"zinit.zsh/#zpcdreplay","text":"A function that can be invoked from within `atinit', `atload', etc. ice-mod. It works like `zinit cdreplay', which cannot be invoked from such hook ices. Has 1 line(s). Calls functions: zpcdreplay `-- .zinit-compdef-replay Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcdreplay"},{"location":"zinit.zsh/#zpcompdef","text":"Stores compdef for a replay with `zpcdreplay' (turbo mode) or with `zinit cdreplay' (normal mode). An utility functton of an undefined use case. Has 1 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcompdef"},{"location":"zinit.zsh/#zpcompinit","text":"A function that can be invoked from within `atinit', `atload', etc. ice-mod. It runs `autoload compinit; compinit' and respects ZINIT[ZCOMPDUMP_PATH] and ZINIT[COMPINIT_OPTS]. Has 1 line(s). Calls functions: zpcompinit `-- compinit Uses feature(s): autoload Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcompinit"},{"location":"zinit.zsh/#zinit-add-report","text":"Adds a report line for given plugin. $1 - uspl2, i.e. user/plugin $2, ... - the text Has 2 line(s). Doesn't call other functions. Called by: .zinit-load-plugin :zinit-shadow-alias :zinit-shadow-autoload :zinit-shadow-bindkey :zinit-shadow-compdef :zinit-shadow-zle :zinit-shadow-zstyle","title":".zinit-add-report"},{"location":"zinit.zsh/#zinit-any-to-user-plugin","text":"Allows elastic plugin-spec across the code. $1 - plugin spec (2 formats: user/plugin, user plugin) $2 - plugin (only when $1 - i.e. user - given) Returns user and plugin in $reply Has 23 line(s). Doesn't call other functions. Called by: .zinit-load .zinit-unregister-plugin zinit-autoload.zsh/.zinit-any-to-uspl2 zinit-autoload.zsh/.zinit-changes zinit-autoload.zsh/.zinit-compiled zinit-autoload.zsh/.zinit-compile-uncompile-all zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-find-completions-of-plugin zinit-autoload.zsh/.zinit-get-path zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-show-report zinit-autoload.zsh/.zinit-stress zinit-autoload.zsh/.zinit-uncompile-plugin zinit-autoload.zsh/.zinit-unload zinit-autoload.zsh/.zinit-update-or-status-all zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-compile-plugin zinit-install.zsh/.zinit-get-latest-gh-r-version zinit-install.zsh/.zinit-install-completions zinit-side.zsh/.zinit-any-colorify-as-uspl2 zinit-side.zsh/.zinit-exists-physically zinit-side.zsh/.zinit-first","title":".zinit-any-to-user-plugin"},{"location":"zinit.zsh/#zinit-clear-debug-report","text":"Forgets dtrace repport gathered up to this moment. Has 1 line(s). Calls functions: .zinit-clear-debug-report `-- zinit-autoload.zsh/.zinit-clear-report-for Called by: zinit zinit-autoload.zsh/.zinit-unload","title":".zinit-clear-debug-report"},{"location":"zinit.zsh/#zinit-compdef-clear","text":"Implements user-exposed functionality to clear gathered compdefs. Has 3 line(s). Doesn't call other functions. Called by: zpcdclear zinit","title":".zinit-compdef-clear"},{"location":"zinit.zsh/#zinit-compdef-replay","text":"Runs gathered compdef calls. This allows to run `compinit' after loading plugins. Has 16 line(s). Doesn't call other functions. Called by: zpcdreplay zinit","title":".zinit-compdef-replay"},{"location":"zinit.zsh/#zinit-debug-start","text":"Starts Dtrace, i.e. session tracking for changes in Zsh state. Has 9 line(s). Calls functions: .zinit-debug-start |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter `-- .zinit-shadow-on Called by: zinit","title":".zinit-debug-start"},{"location":"zinit.zsh/#zinit-debug-stop","text":"Stops Dtrace, i.e. session tracking for changes in Zsh state. Has 3 line(s). Calls functions: .zinit-debug-stop |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter `-- .zinit-shadow-off Called by: zinit","title":".zinit-debug-stop"},{"location":"zinit.zsh/#zinit-debug-unload","text":"Reverts changes detected by dtrace run. Has 5 line(s). Calls functions: .zinit-debug-unload `-- zinit-autoload.zsh/.zinit-unload Called by: zinit","title":".zinit-debug-unload"},{"location":"zinit.zsh/#zinit-deploy-message","text":"Deploys a sub-prompt message to be displayed OR a `zle .reset-prompt' call to be invoked Has 12 line(s). Doesn't call other functions. Uses feature(s): read , zle Called by: .zinit-load-snippet .zinit-load","title":".zinit-deploy-message"},{"location":"zinit.zsh/#zinit-diff","text":"Performs diff actions of all types Has 4 line(s). Calls functions: .zinit-diff |-- .zinit-diff-env |-- .zinit-diff-functions |-- .zinit-diff-options `-- .zinit-diff-parameter Called by: .zinit-debug-start .zinit-debug-stop .zinit-load-plugin","title":".zinit-diff"},{"location":"zinit.zsh/#zinit-diff-env","text":"Implements detection of change in PATH and FPATH. $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 18 line(s). Doesn't call other functions. Called by: .zinit-diff .zinit-load-plugin","title":".zinit-diff-env"},{"location":"zinit.zsh/#zinit-diff-functions","text":"Implements detection of newly created functions. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 8 line(s). Doesn't call other functions. Called by: .zinit-diff","title":".zinit-diff-functions"},{"location":"zinit.zsh/#zinit-diff-options","text":"Implements detection of change in option state. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 7 line(s). Doesn't call other functions. Called by: .zinit-diff","title":".zinit-diff-options"},{"location":"zinit.zsh/#zinit-diff-parameter","text":"Implements detection of change in any parameter's existence and type. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 9 line(s). Doesn't call other functions. Called by: .zinit-diff","title":".zinit-diff-parameter"},{"location":"zinit.zsh/#zinit-find-other-matches","text":"Plugin's main source file is in general `name.plugin.zsh'. However, there can be different conventions, if that file is not found, then this functions examines other conventions in order of most expected sanity. Has 14 line(s). Doesn't call other functions. Called by: .zinit-load-plugin zinit-side.zsh/.zinit-first","title":".zinit-find-other-matches"},{"location":"zinit.zsh/#zinit-ice","text":"Parses ICE specification (`zplg ice' subcommand), puts the result into ZINIT_ICE global hash. The ice-spec is valid for next command only (i.e. it \"melts\"), but it can then stick to plugin and activate e.g. at update. Has 8 line(s). Doesn't call other functions. Called by: zinit Environment variables used: ZPFX","title":".zinit-ice"},{"location":"zinit.zsh/#zinit-load","text":"Implements the exposed-to-user action of loading a plugin. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin name, if the third format is used Has 42 line(s). Calls functions: .zinit-load |-- .zinit-any-to-user-plugin |-- .zinit-deploy-message |-- .zinit-load-plugin | |-- .zinit-add-report | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | |-- .zinit-diff-env | |-- .zinit-find-other-matches | |-- .zinit-shadow-off | |-- .zinit-shadow-on | `-- .zinit-wrap-track-functions |-- .zinit-pack-ice |-- .zinit-register-plugin `-- zinit-install.zsh/.zinit-setup-plugin-dir Uses feature(s): eval , source , zle Called by: .zinit-run-task .zinit-service zinit","title":".zinit-load"},{"location":"zinit.zsh/#zinit-load-plugin","text":"Lower-level function for loading a plugin. $1 - user $2 - plugin $3 - mode (light or load) Has 96 line(s). Calls functions: .zinit-load-plugin |-- .zinit-add-report |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter |-- .zinit-diff-env |-- .zinit-find-other-matches |-- .zinit-shadow-off |-- .zinit-shadow-on `-- .zinit-wrap-track-functions Uses feature(s): eval , source , zle Called by: .zinit-load","title":".zinit-load-plugin"},{"location":"zinit.zsh/#zinit-load-snippet","text":"Implements the exposed-to-user action of loading a snippet. $1 - url (can be local, absolute path) Has 180 line(s). Calls functions: .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): autoload , eval , source , unfunction , zparseopts , zstyle Called by: pmodload .zinit-run-task .zinit-service zinit zinit-autoload.zsh/.zinit-update-or-status-snippet","title":".zinit-load-snippet"},{"location":"zinit.zsh/#zinit-pack-ice","text":"Remembers all ice-mods, assigns them to concrete plugin. Ice spec is in general forgotten for second-next command (that's why it's called \"ice\" - it melts), however they glue to the object (plugin or snippet) mentioned in the next command \u2013 for later use with e.g. `zinit update ...' Has 3 line(s). Doesn't call other functions. Called by: .zinit-load-snippet .zinit-load zinit-autoload.zsh/.zinit-compute-ice","title":".zinit-pack-ice"},{"location":"zinit.zsh/#zinit-prepare-home","text":"Creates all directories needed by Zinit, first checks if they already exist. Has 28 line(s). Doesn't call other functions. Called by: Script-Body Environment variables used: ZPFX","title":".zinit-prepare-home"},{"location":"zinit.zsh/#zinit-register-plugin","text":"Adds the plugin to ZINIT_REGISTERED_PLUGINS array and to the zsh_loaded_plugins array (managed according to the plugin standard: http://zdharma.org/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html) Has 23 line(s). Doesn't call other functions. Called by: .zinit-load","title":".zinit-register-plugin"},{"location":"zinit.zsh/#zplg-register-z-plugin","text":"Registers the z-plugin inside Zinit \u2013 i.e. an Zinit extension Has 4 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"@zplg-register-z-plugin"},{"location":"zinit.zsh/#zinit-reload-and-run","text":"Marks given function ($3) for autoloading, and executes it triggering the load. $1 is the fpath dedicated to the function, $2 are autoload options. This function replaces \"autoload -X\", because using that on older Zsh versions causes problems with traps. So basically one creates function stub that calls :zinit-reload-and-run() instead of \"autoload -X\". $1 - FPATH dedicated to function $2 - autoload options $3 - function name (one that needs autoloading) Author: Bart Schaefer Has 7 line(s). Doesn't call other functions. Uses feature(s): autoload , unfunction Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-reload-and-run"},{"location":"zinit.zsh/#zinit-run-task","text":"A backend, worker function of .zinit-scheduler. It obtains the tasks index and a few of its properties (like the type: plugin, snippet, service plugin, service snippet) and executes it first checking for additional conditions (like non-numeric wait'' ice). $1 - the pass number, either 1st or 2nd pass $2 - the time assigned to the task $3 - type: plugin, snippet, service plugin, service snippet $4 - task's index in the ZINIT[WAIT_ICE_...] fields $5 - mode: load or light $6 - the plugin-spec or snippet URL or alias name (from id-as'') Has 41 line(s). Calls functions: .zinit-run-task |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet `-- zinit-autoload.zsh/.zinit-unload Uses feature(s): eval , source , zle , zpty Called by: @zinit-scheduler","title":".zinit-run-task"},{"location":"zinit.zsh/#zinit-scheduler","text":"Searches for timeout tasks, executes them. There's an array of tasks waiting for execution, this scheduler manages them, detects which ones should be run at current moment, decides to remove (or not) them from the array after execution. $1 - if \"following\", then it is non-first (second and more) invocation of the scheduler; this results in chain of `sched' invocations that results in repetitive @zinit-scheduler activity if \"burst\", then all tasks are marked timeout and executed one by one; this is handy if e.g. a docker image starts up and needs to install all turbo-mode plugins without any hesitation (delay), i.e. \"burst\" allows to run package installations from script, not from prompt Has 62 line(s). Is a precmd hook . Calls functions: @zinit-scheduler |-- add-zsh-hook `-- .zinit-run-task |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet `-- zinit-autoload.zsh/.zinit-unload Uses feature(s): sched , zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"@zinit-scheduler"},{"location":"zinit.zsh/#zinit-service","text":"Handles given service, i.e. obtains lock, runs it, or waits if no lock $1 - type \"p\" or \"s\" (plugin or snippet) $2 - mode - for plugin (light or load) $3 - id - URL or plugin ID or alias name (from id-as'') Has 30 line(s). Calls functions: .zinit-service |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir `-- .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): kill , read Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-service"},{"location":"zinit.zsh/#zinit-shadow-alias","text":"Function defined to hijack plugin's calls to `alias' builtin. The hijacking is to gather report data (which is used in unload). Has 34 line(s). Calls functions: :zinit-shadow-alias `-- .zinit-add-report Uses feature(s): alias , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-alias"},{"location":"zinit.zsh/#zinit-shadow-autoload","text":"Function defined to hijack plugin's calls to `autoload' builtin. The hijacking is not only to gather report data, but also to run custom `autoload' function, that doesn't need FPATH. Has 48 line(s). Calls functions: :zinit-shadow-autoload `-- .zinit-add-report Uses feature(s): autoload , eval , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-autoload"},{"location":"zinit.zsh/#zinit-shadow-bindkey","text":"Function defined to hijack plugin's calls to `bindkey' builtin. The hijacking is to gather report data (which is used in unload). Has 104 line(s). Calls functions: :zinit-shadow-bindkey |-- is-at-least `-- .zinit-add-report Uses feature(s): bindkey , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-bindkey"},{"location":"zinit.zsh/#zinit-shadow-compdef","text":"Function defined to hijack plugin's calls to `compdef' function. The hijacking is not only for reporting, but also to save compdef calls so that `compinit' can be called after loading plugins. Has 4 line(s). Calls functions: :zinit-shadow-compdef `-- .zinit-add-report Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-compdef"},{"location":"zinit.zsh/#zinit-shadow-off","text":"Turn off shadowing completely for a given mode (\"load\", \"light\", \"light-b\" (i.e. the `trackbinds' mode) or \"compdef\"). Has 18 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-debug-stop .zinit-load-plugin","title":".zinit-shadow-off"},{"location":"zinit.zsh/#zinit-shadow-on","text":"Turn on shadowing of builtins and functions according to passed mode (\"load\", \"light\", \"light-b\" or \"compdef\"). The shadowing is to gather report data, and to hijack `autoload', `bindkey' and `compdef' calls. Has 25 line(s). Doesn't call other functions. Called by: .zinit-debug-start .zinit-load-plugin","title":".zinit-shadow-on"},{"location":"zinit.zsh/#zinit-shadow-zle","text":"Function defined to hijack plugin's calls to `zle' builtin. The hijacking is to gather report data (which is used in unload). Has 38 line(s). Calls functions: :zinit-shadow-zle `-- .zinit-add-report Uses feature(s): zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-zle"},{"location":"zinit.zsh/#zinit-shadow-zstyle","text":"Function defined to hijack plugin's calls to `zstyle' builtin. The hijacking is to gather report data (which is used in unload). Has 21 line(s). Calls functions: :zinit-shadow-zstyle `-- .zinit-add-report Uses feature(s): zparseopts , zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-zstyle"},{"location":"zinit.zsh/#zinit-submit-turbo","text":"If `zinit load`, `zinit light` or `zinit snippet` will be preceded with `wait', `load', `unload' or `on-update-of`/`subscribe' ice-mods then the plugin or snipped is to be loaded in turbo-mode, and this function adds it to internal data structures, so that @zinit-scheduler can run (load, unload) this as a task. Has 14 line(s). Doesn't call other functions. Called by: zinit","title":".zinit-submit-turbo"},{"location":"zinit.zsh/#zinit-unregister-plugin","text":"Removes the plugin from ZINIT_REGISTERED_PLUGINS array and from the zsh_loaded_plugins array (managed according to the plugin standard) Has 5 line(s). Calls functions: .zinit-unregister-plugin `-- .zinit-any-to-user-plugin Called by: zinit-autoload.zsh/.zinit-unload","title":".zinit-unregister-plugin"},{"location":"zinit.zsh/#zinit-wrap-track-functions","text":"Has 19 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-load-plugin .zinit-load-snippet","title":".zinit-wrap-track-functions"},{"location":"zinit.zsh/#zinit","text":"Main function directly exposed to user, obtains subcommand and its arguments, has completion. Has 290 line(s). Calls functions: zinit |-- compinit |-- .zinit-clear-debug-report | `-- zinit-autoload.zsh/.zinit-clear-report-for |-- .zinit-compdef-clear |-- .zinit-compdef-replay |-- .zinit-debug-start | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | `-- .zinit-shadow-on |-- .zinit-debug-stop | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | `-- .zinit-shadow-off |-- .zinit-debug-unload | `-- zinit-autoload.zsh/.zinit-unload |-- .zinit-ice |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet |-- .zinit-submit-turbo |-- zinit-autoload.zsh/.zinit-cdisable |-- zinit-autoload.zsh/.zinit-cenable |-- zinit-autoload.zsh/.zinit-clear-completions |-- zinit-autoload.zsh/.zinit-compiled |-- zinit-autoload.zsh/.zinit-compile-uncompile-all |-- zinit-autoload.zsh/.zinit-compinit |-- zinit-autoload.zsh/.zinit-help |-- zinit-autoload.zsh/.zinit-list-bindkeys |-- zinit-autoload.zsh/.zinit-list-compdef-replay |-- zinit-autoload.zsh/.zinit-ls |-- zinit-autoload.zsh/.zinit-module |-- zinit-autoload.zsh/.zinit-recently |-- zinit-autoload.zsh/.zinit-search-completions |-- zinit-autoload.zsh/.zinit-self-update |-- zinit-autoload.zsh/.zinit-show-all-reports |-- zinit-autoload.zsh/.zinit-show-completions |-- zinit-autoload.zsh/.zinit-show-debug-report |-- zinit-autoload.zsh/.zinit-show-registered-plugins |-- zinit-autoload.zsh/.zinit-show-report |-- zinit-autoload.zsh/.zinit-show-times |-- zinit-autoload.zsh/.zinit-show-zstatus |-- zinit-autoload.zsh/.zinit-uncompile-plugin |-- zinit-autoload.zsh/.zinit-uninstall-completions |-- zinit-autoload.zsh/.zinit-unload |-- zinit-autoload.zsh/.zinit-update-or-status |-- zinit-autoload.zsh/.zinit-update-or-status-all |-- zinit-install.zsh/.zinit-compile-plugin |-- zinit-install.zsh/.zinit-forget-completion `-- zinit-install.zsh/.zinit-install-completions Uses feature(s): autoload , eval , source Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zinit"},{"location":"zinit.zsh/#-zinit_scheduler_add_sh","text":"Copies task into ZINIT_RUN array, called when a task timeouts. A small function ran from pattern in /-substitution as a math function. Has 7 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zinit_scheduler_add_sh"},{"location":"zinit.zsh/#add-zsh-hook","text":"Has 93 line(s). Doesn't call other functions. Uses feature(s): autoload , getopts Called by: Script-Body @zinit-scheduler","title":"add-zsh-hook"},{"location":"zinit.zsh/#compinit","text":"Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: zpcompinit zinit","title":"compinit"},{"location":"zinit.zsh/#is-at-least","text":"Has 56 line(s). Doesn't call other functions. Called by: Script-Body :zinit-shadow-bindkey","title":"is-at-least"},{"location":"zplugin-autoload.zsh/","text":"zinit-autoload.zsh(1) # NAME # zinit-autoload.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # .zinit-any-to-uspl2 .zinit-at-eval .zinit-build-module .zinit-cd .zinit-cdisable .zinit-cenable .zinit-changes .zinit-check-comp-consistency .zinit-check-which-completions-are-enabled .zinit-check-which-completions-are-installed .zinit-clear-completions .zinit-clear-report-for .zinit-compiled .zinit-compile-uncompile-all .zinit-compinit .zinit-compute-ice .zinit-confirm .zinit-create .zinit-delete .zinit-diff-env-compute .zinit-diff-functions-compute .zinit-diff-options-compute .zinit-diff-parameter-compute .zinit-edit .zinit-exists-message .zinit-find-completions-of-plugin .zinit-format-env .zinit-format-functions .zinit-format-options .zinit-format-parameter .zinit-get-completion-owner .zinit-get-completion-owner-uspl2col .zinit-get-path .zinit-glance .zinit-help .zinit-list-bindkeys .zinit-list-compdef-replay .zinit-ls .zinit-module .zinit-prepare-readlink .zinit-recall .zinit-recently .zinit-restore-extendedglob .zinit-save-set-extendedglob .zinit-search-completions .zinit-self-update .zinit-show-all-reports .zinit-show-completions .zinit-show-debug-report .zinit-show-registered-plugins .zinit-show-report .zinit-show-times .zinit-show-zstatus .zinit-stress .zinit-uncompile-plugin .zinit-uninstall-completions .zinit-unload .zinit-update-or-status .zinit-update-or-status-all .zinit-update-or-status-snippet AUTOLOAD compinit DETAILS # Script Body # Has 5 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source .zinit-any-to-uspl2 # Converts given plugin-spec to format that's used in keys for hash tables. So basically, creates string \"user/plugin\" (this format is called: uspl2). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 2 line(s). Calls functions: .zinit-any-to-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-clear-report-for .zinit-exists-message .zinit-at-eval # Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-update-or-status .zinit-build-module # Performs ./configure && make on the module and displays information how to load the module in .zshrc. Has 27 line(s). Calls functions: .zinit-build-module `-- .zinit-module Uses feature(s): trap Called by: .zinit-module .zinit-cd # Jumps to plugin's directory (in Zinit's home directory). User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: .zinit-cd `-- .zinit-get-path |-- zinit-side.zsh/.zinit-exists-physically |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-cdisable # Enables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 30 line(s). Calls functions: .zinit-cdisable |-- .zinit-check-comp-consistency |-- .zinit-get-completion-owner-uspl2col | |-- .zinit-get-completion-owner | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- .zinit-prepare-readlink Called by: zinit.zsh/zinit .zinit-cenable # Disables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 31 line(s). Calls functions: .zinit-cenable |-- .zinit-check-comp-consistency |-- .zinit-get-completion-owner-uspl2col | |-- .zinit-get-completion-owner | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- .zinit-prepare-readlink Called by: zinit.zsh/zinit .zinit-changes # Shows `git log` of given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 9 line(s). Calls functions: .zinit-changes |-- zinit-side.zsh/.zinit-exists-physically-message `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-check-comp-consistency # Zinit creates symlink for each installed completion. This function checks whether given completion (i.e. file like \"_mkdir\") is indeed a symlink. Backup file is a completion that is disabled - has the leading \"_\" removed. $1 - path to completion within plugin's directory $2 - path to backup file within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: .zinit-cdisable .zinit-cenable .zinit-check-which-completions-are-enabled # For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is disabled - returns 0 or 1 on corresponding positions in reply. Uninstalled completions will be reported as \"0\" - i.e. disabled $1, ... - path to completion within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-check-which-completions-are-installed # For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is installed - returns 0 or 1 on corresponding positions in reply. $1, ... - path to completion within plugin's directory Has 12 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-clear-completions # Delete stray and improper completions. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 37 line(s). Calls functions: .zinit-clear-completions |-- .zinit-get-completion-owner |-- .zinit-prepare-readlink `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-clear-report-for # Clears all report data for given user/plugin. This is done by resetting all related global ZINIT_* hashes. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 23 line(s). Calls functions: .zinit-clear-report-for `-- .zinit-any-to-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-unload zinit.zsh/.zinit-clear-debug-report .zinit-compiled # Displays list of plugins that are compiled. User-action entry point. Has 26 line(s). Calls functions: .zinit-compiled |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit .zinit-compile-uncompile-all # Compiles or uncompiles all existing (on disk) plugins. User-action entry point. Has 23 line(s). Calls functions: .zinit-compile-uncompile-all |-- .zinit-uncompile-plugin | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit-install.zsh/.zinit-compile-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit .zinit-compinit # User-exposed `compinit' frontend which first ensures that all completions managed by Zinit are forgotten by Zshell. After that it runs normal `compinit', which should more easily detect Zinit's completions. No arguments. Has 23 line(s). Calls functions: .zinit-compinit |-- compinit `-- zinit-install.zsh/.zinit-forget-completion Uses feature(s): autoload , unfunction Called by: zinit.zsh/zinit .zinit-compute-ice # Computes ZINIT_ICE array (default, it can be specified via $3) from a) input ZINIT_ICE, b) static ice, c) saved ice, taking priorities into account. Also returns path to snippet directory and optional name of snippet file (only valid if ZINIT_ICE[svn] is not set). Can also pack resulting ices into ZINIT_SICE (see $2). $1 - URL (also plugin-spec) $2 - \"pack\" or \"nopack\" or \"pack-nf\" - packing means ZINIT_ICE wins with static ice; \"pack-nf\" means that disk-ices will be ignored (no-file?) $3 - name of output associative array, \"ZINIT_ICE\" is the default $4 - name of output string parameter, to hold path to directory (\"local_dir\") $5 - name of output string parameter, to hold filename (\"filename\") Has 98 line(s). Calls functions: .zinit-compute-ice |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-pack-ice Uses feature(s): wait Called by: .zinit-recall .zinit-update-or-status-snippet .zinit-update-or-status .zinit-confirm # Prints given question, waits for \"y\" key, evals given expression if \"y\" obtained $1 - question $2 - expression Has 5 line(s). Doesn't call other functions. Uses feature(s): eval , read Called by: .zinit-delete .zinit-create # Creates a plugin, also on Github (if not \"_local/name\" plugin). User-action entry point. $1 - (optional) plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 66 line(s). Calls functions: .zinit-create |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): vared Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-delete # Deletes plugin's or snippet's directory (in Zinit's home directory). User-action entry point. $1 - snippet URL or plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 54 line(s). Calls functions: .zinit-delete |-- .zinit-confirm |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-diff-env-compute # Computes ZINIT_PATH, ZINIT_FPATH that hold (f)path components added by plugin. Uses data gathered earlier by .zinit-diff-env(). $1 - user/plugin Has 30 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload .zinit-diff-functions-compute # Computes FUNCTIONS that holds new functions added by plugin. Uses data gathered earlier by .zinit-diff-functions(). $1 - user/plugin Has 19 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload .zinit-diff-options-compute # Computes OPTIONS that holds options changed by plugin. Uses data gathered earlier by .zinit-diff-options(). $1 - user/plugin Has 17 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload .zinit-diff-parameter-compute # Computes ZINIT_PARAMETERS_PRE, ZINIT_PARAMETERS_POST that hold parameters created or changed (their type) by plugin. Uses data gathered earlier by .zinit-diff-parameter(). $1 - user/plugin Has 28 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload .zinit-edit # Runs $EDITOR on source of given plugin. If the variable is not set then defaults to `vim'. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: .zinit-edit |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-exists-message # Checks if plugin is loaded. Testable. Also outputs error message if plugin is not loaded. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 7 line(s). Calls functions: .zinit-exists-message |-- .zinit-any-to-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: .zinit-show-report .zinit-unload .zinit-find-completions-of-plugin # Searches for completions owned by given plugin. Returns them in `reply' array. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 6 line(s). Calls functions: .zinit-find-completions-of-plugin `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-show-report .zinit-format-env # Creates one-column text about FPATH or PATH elements added when given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) $2 - if 1, then examine PATH, if 2, then examine FPATH Has 16 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-format-functions # Creates a one or two columns text with functions created by given plugin. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 36 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-format-options # Creates one-column text about options that changed when plugin \"$1\" was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 21 line(s). Calls functions: .zinit-format-options |-- .zinit-restore-extendedglob `-- .zinit-save-set-extendedglob Called by: .zinit-show-report .zinit-format-parameter # Creates one column text that lists global parameters that changed when the given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 34 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-get-completion-owner # Returns \"user---plugin\" string (uspl1 format) of plugin that owns given completion. Both :A and readlink will be used, then readlink's output if results differ. Readlink might not be available. :A will read the link \"twice\" and give the final repository directory, possibly without username in the uspl format; readlink will read the link \"once\" $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 22 line(s). Doesn't call other functions. Called by: .zinit-clear-completions .zinit-get-completion-owner-uspl2col .zinit-show-completions .zinit-get-completion-owner-uspl2col # For shortening of code - returns colorized plugin name that owns given completion. $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 2 line(s). Calls functions: .zinit-get-completion-owner-uspl2col |-- .zinit-get-completion-owner `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: .zinit-cdisable .zinit-cenable .zinit-get-path # Returns path of given ID-string, which may be a plugin-spec (like \"user/plugin\" or \"user\" \"plugin\"), an absolute path (\"%\" \"/home/...\" and also \"%SNIPPETS/...\" etc.), or a plugin nickname (i.e. id-as'' ice-mod), or a snippet nickname. Has 35 line(s). Calls functions: .zinit-get-path |-- zinit-side.zsh/.zinit-exists-physically |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-cd .zinit-uninstall-completions .zinit-glance # Shows colorized source code of plugin. Is able to use pygmentize, highlight, GNU source-highlight. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 39 line(s). Calls functions: .zinit-glance |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-help # Shows usage information. User-action entry point. Has 68 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit .zinit-list-bindkeys # Has 42 line(s). Calls functions: .zinit-list-bindkeys `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-list-compdef-replay # Shows recorded compdefs (called by plugins loaded earlier). Plugins often call `compdef' hoping for `compinit' being already ran. Zinit solves this by recording compdefs. User-action entry point. Has 5 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit .zinit-ls # Has 19 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit .zinit-module # Function that has sub-commands passed as long-options (with two dashes, --). It's an attempt to plugin only this one function into `zinit' function defined in zinit.zsh, to not make this file longer than it's needed. Has 24 line(s). Calls functions: .zinit-module `-- .zinit-build-module Called by: .zinit-build-module zinit.zsh/zinit .zinit-prepare-readlink # Prepares readlink command, used for establishing completion's owner. $REPLY = \":\" or \"readlink\" Has 4 line(s). Doesn't call other functions. Uses feature(s): type Called by: .zinit-cdisable .zinit-cenable .zinit-clear-completions .zinit-show-completions .zinit-recall # Has 37 line(s). Calls functions: .zinit-recall `-- .zinit-compute-ice |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-pack-ice Uses feature(s): wait Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-recently # Shows plugins that obtained commits in specified past time. User-action entry point. $1 - time spec, e.g. \"1 week\" Has 26 line(s). Calls functions: .zinit-recently `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-restore-extendedglob # Restores extendedglob-option from state saved earlier. Has 1 line(s). Doesn't call other functions. Called by: .zinit-format-options .zinit-show-registered-plugins .zinit-unload .zinit-save-set-extendedglob # Enables extendedglob-option first saving if it was already enabled, for restoration of this state later. Has 2 line(s). Doesn't call other functions. Called by: .zinit-format-options .zinit-show-registered-plugins .zinit-unload .zinit-search-completions # While .zinit-show-completions() shows what completions are installed, this functions searches through all plugin dirs showing what's available in general (for installation). User-action entry point. Has 43 line(s). Calls functions: .zinit-search-completions `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-self-update # Updates Zinit code (does a git pull). User-action entry point. Has 23 line(s). Doesn't call other functions. Uses feature(s): zcompile Called by: zinit.zsh/zinit .zinit-show-all-reports # Displays reports of all loaded plugins. User-action entry point. Has 5 line(s). Calls functions: .zinit-show-all-reports `-- .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit .zinit-show-completions # Display installed (enabled and disabled), completions. Detect stray and improper ones. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 72 line(s). Calls functions: .zinit-show-completions |-- .zinit-get-completion-owner |-- .zinit-prepare-readlink `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-show-debug-report # Displays dtrace report (data recorded in interactive session). User-action entry point. Has 1 line(s). Calls functions: .zinit-show-debug-report `-- .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit .zinit-show-registered-plugins # Lists loaded plugins (subcommands list, lodaded). User-action entry point. Has 21 line(s). Calls functions: .zinit-show-registered-plugins |-- .zinit-restore-extendedglob |-- .zinit-save-set-extendedglob `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-show-report # Displays report of the plugin given. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 71 line(s). Calls functions: .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-show-all-reports .zinit-show-debug-report zinit.zsh/zinit .zinit-show-times # Shows loading times of all loaded plugins. User-action entry point. Has 42 line(s). Calls functions: .zinit-show-times `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit .zinit-show-zstatus # Shows Zinit status, i.e. number of loaded plugins, of available completions, etc. User-action entry point. Has 41 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit .zinit-stress # Compiles plugin with various options on and off to see how well the code is written. The options are: NO_SHORT_LOOPS, IGNORE_BRACES, IGNORE_CLOSE_BRACES, SH_GLOB, CSH_JUNKIE_QUOTES, NO_MULTI_FUNC_DEF. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 35 line(s). Calls functions: .zinit-stress |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): zcompile Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-uncompile-plugin # Uncompiles given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 22 line(s). Calls functions: .zinit-uncompile-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-compile-uncompile-all zinit.zsh/zinit .zinit-uninstall-completions # Removes all completions of given plugin from Zshell (i.e. from FPATH). The FPATH is typically `~/.zinit/completions/'. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 41 line(s). Calls functions: .zinit-uninstall-completions |-- .zinit-get-path | |-- zinit-side.zsh/.zinit-exists-physically | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | `-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit-install.zsh/.zinit-forget-completion Called by: zinit.zsh/zinit .zinit-unload # 0. Call the Zsh Plugin's Standard *_plugin_unload function 1. Delete bindkeys (...) 2. Delete Zstyles 3. Restore options 4. Remove aliases 5. Restore Zle state 6. Unfunction functions (created by plugin) 7. Clean-up FPATH and PATH 8. Delete created variables 9. Forget the plugin User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 347 line(s). Calls functions: .zinit-unload |-- .zinit-clear-report-for | `-- .zinit-any-to-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-restore-extendedglob |-- .zinit-save-set-extendedglob |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit.zsh/.zinit-clear-debug-report `-- zinit.zsh/.zinit-unregister-plugin Uses feature(s): alias , bindkey , unalias , unfunction , zle , zstyle Called by: zinit.zsh/.zinit-debug-unload zinit.zsh/.zinit-run-task zinit.zsh/zinit .zinit-update-or-status # Updates (git pull) or does `git status' for given plugin. User-action entry point. $1 - \"status\" for status, other for update $2 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $3 - plugin (only when $1 - i.e. user - given) Has 212 line(s). Calls functions: .zinit-update-or-status |-- .zinit-at-eval |-- .zinit-compute-ice | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | |-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit.zsh/.zinit-pack-ice |-- .zinit-update-or-status-snippet | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | `-- zinit.zsh/.zinit-load-snippet |-- zinit-install.zsh/.zinit-get-latest-gh-r-version |-- zinit-install.zsh/.zinit-setup-plugin-dir |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-store-ices |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): kill , read , source , wait Called by: .zinit-update-or-status-all zinit.zsh/zinit .zinit-update-or-status-all # Updates (git pull) or does `git status` for all existing plugins. This includes also plugins that are not loaded into Zsh (but exist on disk). Also updates (i.e. redownloads) snippets. User-action entry point. Has 63 line(s). Calls functions: .zinit-update-or-status-all |-- .zinit-update-or-status | |-- .zinit-at-eval | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | |-- .zinit-update-or-status-snippet | | |-- .zinit-compute-ice | | | |-- zinit-side.zsh/.zinit-exists-physically-message | | | |-- zinit-side.zsh/.zinit-shands-exp | | | |-- zinit-side.zsh/.zinit-two-paths | | | |-- zinit.zsh/.zinit-any-to-user-plugin | | | `-- zinit.zsh/.zinit-pack-ice | | `-- zinit.zsh/.zinit-load-snippet | |-- zinit-install.zsh/.zinit-get-latest-gh-r-version | |-- zinit-install.zsh/.zinit-setup-plugin-dir | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-store-ices | |-- zinit-side.zsh/.zinit-two-paths | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-update-or-status-snippet | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | `-- zinit.zsh/.zinit-load-snippet |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit .zinit-update-or-status-snippet # Implements update or status operation for snippet given by URL. $1 - \"status\" or \"update\" $2 - snippet URL Has 19 line(s). Calls functions: .zinit-update-or-status-snippet |-- .zinit-compute-ice | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | |-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit.zsh/.zinit-pack-ice `-- zinit.zsh/.zinit-load-snippet Called by: .zinit-update-or-status-all .zinit-update-or-status compinit # Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: .zinit-compinit","title":"zinit-autoload.zsh(1)"},{"location":"zplugin-autoload.zsh/#zinit-autoloadzsh1","text":"","title":"zinit-autoload.zsh(1)"},{"location":"zplugin-autoload.zsh/#name","text":"zinit-autoload.zsh - a shell script","title":"NAME"},{"location":"zplugin-autoload.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin-autoload.zsh/#functions","text":".zinit-any-to-uspl2 .zinit-at-eval .zinit-build-module .zinit-cd .zinit-cdisable .zinit-cenable .zinit-changes .zinit-check-comp-consistency .zinit-check-which-completions-are-enabled .zinit-check-which-completions-are-installed .zinit-clear-completions .zinit-clear-report-for .zinit-compiled .zinit-compile-uncompile-all .zinit-compinit .zinit-compute-ice .zinit-confirm .zinit-create .zinit-delete .zinit-diff-env-compute .zinit-diff-functions-compute .zinit-diff-options-compute .zinit-diff-parameter-compute .zinit-edit .zinit-exists-message .zinit-find-completions-of-plugin .zinit-format-env .zinit-format-functions .zinit-format-options .zinit-format-parameter .zinit-get-completion-owner .zinit-get-completion-owner-uspl2col .zinit-get-path .zinit-glance .zinit-help .zinit-list-bindkeys .zinit-list-compdef-replay .zinit-ls .zinit-module .zinit-prepare-readlink .zinit-recall .zinit-recently .zinit-restore-extendedglob .zinit-save-set-extendedglob .zinit-search-completions .zinit-self-update .zinit-show-all-reports .zinit-show-completions .zinit-show-debug-report .zinit-show-registered-plugins .zinit-show-report .zinit-show-times .zinit-show-zstatus .zinit-stress .zinit-uncompile-plugin .zinit-uninstall-completions .zinit-unload .zinit-update-or-status .zinit-update-or-status-all .zinit-update-or-status-snippet AUTOLOAD compinit","title":"FUNCTIONS"},{"location":"zplugin-autoload.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin-autoload.zsh/#script_body","text":"Has 5 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source","title":"Script Body"},{"location":"zplugin-autoload.zsh/#zinit-any-to-uspl2","text":"Converts given plugin-spec to format that's used in keys for hash tables. So basically, creates string \"user/plugin\" (this format is called: uspl2). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 2 line(s). Calls functions: .zinit-any-to-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-clear-report-for .zinit-exists-message","title":".zinit-any-to-uspl2"},{"location":"zplugin-autoload.zsh/#zinit-at-eval","text":"Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-update-or-status","title":".zinit-at-eval"},{"location":"zplugin-autoload.zsh/#zinit-build-module","text":"Performs ./configure && make on the module and displays information how to load the module in .zshrc. Has 27 line(s). Calls functions: .zinit-build-module `-- .zinit-module Uses feature(s): trap Called by: .zinit-module","title":".zinit-build-module"},{"location":"zplugin-autoload.zsh/#zinit-cd","text":"Jumps to plugin's directory (in Zinit's home directory). User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: .zinit-cd `-- .zinit-get-path |-- zinit-side.zsh/.zinit-exists-physically |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-cd"},{"location":"zplugin-autoload.zsh/#zinit-cdisable","text":"Enables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 30 line(s). Calls functions: .zinit-cdisable |-- .zinit-check-comp-consistency |-- .zinit-get-completion-owner-uspl2col | |-- .zinit-get-completion-owner | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- .zinit-prepare-readlink Called by: zinit.zsh/zinit","title":".zinit-cdisable"},{"location":"zplugin-autoload.zsh/#zinit-cenable","text":"Disables given installed completion. User-action entry point. $1 - e.g. \"_mkdir\" or \"mkdir\" Has 31 line(s). Calls functions: .zinit-cenable |-- .zinit-check-comp-consistency |-- .zinit-get-completion-owner-uspl2col | |-- .zinit-get-completion-owner | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- .zinit-prepare-readlink Called by: zinit.zsh/zinit","title":".zinit-cenable"},{"location":"zplugin-autoload.zsh/#zinit-changes","text":"Shows `git log` of given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 9 line(s). Calls functions: .zinit-changes |-- zinit-side.zsh/.zinit-exists-physically-message `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-changes"},{"location":"zplugin-autoload.zsh/#zinit-check-comp-consistency","text":"Zinit creates symlink for each installed completion. This function checks whether given completion (i.e. file like \"_mkdir\") is indeed a symlink. Backup file is a completion that is disabled - has the leading \"_\" removed. $1 - path to completion within plugin's directory $2 - path to backup file within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: .zinit-cdisable .zinit-cenable","title":".zinit-check-comp-consistency"},{"location":"zplugin-autoload.zsh/#zinit-check-which-completions-are-enabled","text":"For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is disabled - returns 0 or 1 on corresponding positions in reply. Uninstalled completions will be reported as \"0\" - i.e. disabled $1, ... - path to completion within plugin's directory Has 11 line(s). Doesn't call other functions. Called by: .zinit-show-report","title":".zinit-check-which-completions-are-enabled"},{"location":"zplugin-autoload.zsh/#zinit-check-which-completions-are-installed","text":"For each argument that each should be a path to completion within a plugin's dir, it checks whether that completion is installed - returns 0 or 1 on corresponding positions in reply. $1, ... - path to completion within plugin's directory Has 12 line(s). Doesn't call other functions. Called by: .zinit-show-report","title":".zinit-check-which-completions-are-installed"},{"location":"zplugin-autoload.zsh/#zinit-clear-completions","text":"Delete stray and improper completions. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 37 line(s). Calls functions: .zinit-clear-completions |-- .zinit-get-completion-owner |-- .zinit-prepare-readlink `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-clear-completions"},{"location":"zplugin-autoload.zsh/#zinit-clear-report-for","text":"Clears all report data for given user/plugin. This is done by resetting all related global ZINIT_* hashes. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 23 line(s). Calls functions: .zinit-clear-report-for `-- .zinit-any-to-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-unload zinit.zsh/.zinit-clear-debug-report","title":".zinit-clear-report-for"},{"location":"zplugin-autoload.zsh/#zinit-compiled","text":"Displays list of plugins that are compiled. User-action entry point. Has 26 line(s). Calls functions: .zinit-compiled |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit","title":".zinit-compiled"},{"location":"zplugin-autoload.zsh/#zinit-compile-uncompile-all","text":"Compiles or uncompiles all existing (on disk) plugins. User-action entry point. Has 23 line(s). Calls functions: .zinit-compile-uncompile-all |-- .zinit-uncompile-plugin | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit-install.zsh/.zinit-compile-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit","title":".zinit-compile-uncompile-all"},{"location":"zplugin-autoload.zsh/#zinit-compinit","text":"User-exposed `compinit' frontend which first ensures that all completions managed by Zinit are forgotten by Zshell. After that it runs normal `compinit', which should more easily detect Zinit's completions. No arguments. Has 23 line(s). Calls functions: .zinit-compinit |-- compinit `-- zinit-install.zsh/.zinit-forget-completion Uses feature(s): autoload , unfunction Called by: zinit.zsh/zinit","title":".zinit-compinit"},{"location":"zplugin-autoload.zsh/#zinit-compute-ice","text":"Computes ZINIT_ICE array (default, it can be specified via $3) from a) input ZINIT_ICE, b) static ice, c) saved ice, taking priorities into account. Also returns path to snippet directory and optional name of snippet file (only valid if ZINIT_ICE[svn] is not set). Can also pack resulting ices into ZINIT_SICE (see $2). $1 - URL (also plugin-spec) $2 - \"pack\" or \"nopack\" or \"pack-nf\" - packing means ZINIT_ICE wins with static ice; \"pack-nf\" means that disk-ices will be ignored (no-file?) $3 - name of output associative array, \"ZINIT_ICE\" is the default $4 - name of output string parameter, to hold path to directory (\"local_dir\") $5 - name of output string parameter, to hold filename (\"filename\") Has 98 line(s). Calls functions: .zinit-compute-ice |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-pack-ice Uses feature(s): wait Called by: .zinit-recall .zinit-update-or-status-snippet .zinit-update-or-status","title":".zinit-compute-ice"},{"location":"zplugin-autoload.zsh/#zinit-confirm","text":"Prints given question, waits for \"y\" key, evals given expression if \"y\" obtained $1 - question $2 - expression Has 5 line(s). Doesn't call other functions. Uses feature(s): eval , read Called by: .zinit-delete","title":".zinit-confirm"},{"location":"zplugin-autoload.zsh/#zinit-create","text":"Creates a plugin, also on Github (if not \"_local/name\" plugin). User-action entry point. $1 - (optional) plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 66 line(s). Calls functions: .zinit-create |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): vared Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-create"},{"location":"zplugin-autoload.zsh/#zinit-delete","text":"Deletes plugin's or snippet's directory (in Zinit's home directory). User-action entry point. $1 - snippet URL or plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 54 line(s). Calls functions: .zinit-delete |-- .zinit-confirm |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-delete"},{"location":"zplugin-autoload.zsh/#zinit-diff-env-compute","text":"Computes ZINIT_PATH, ZINIT_FPATH that hold (f)path components added by plugin. Uses data gathered earlier by .zinit-diff-env(). $1 - user/plugin Has 30 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload","title":".zinit-diff-env-compute"},{"location":"zplugin-autoload.zsh/#zinit-diff-functions-compute","text":"Computes FUNCTIONS that holds new functions added by plugin. Uses data gathered earlier by .zinit-diff-functions(). $1 - user/plugin Has 19 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload","title":".zinit-diff-functions-compute"},{"location":"zplugin-autoload.zsh/#zinit-diff-options-compute","text":"Computes OPTIONS that holds options changed by plugin. Uses data gathered earlier by .zinit-diff-options(). $1 - user/plugin Has 17 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload","title":".zinit-diff-options-compute"},{"location":"zplugin-autoload.zsh/#zinit-diff-parameter-compute","text":"Computes ZINIT_PARAMETERS_PRE, ZINIT_PARAMETERS_POST that hold parameters created or changed (their type) by plugin. Uses data gathered earlier by .zinit-diff-parameter(). $1 - user/plugin Has 28 line(s). Doesn't call other functions. Called by: .zinit-show-report .zinit-unload","title":".zinit-diff-parameter-compute"},{"location":"zplugin-autoload.zsh/#zinit-edit","text":"Runs $EDITOR on source of given plugin. If the variable is not set then defaults to `vim'. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 13 line(s). Calls functions: .zinit-edit |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-edit"},{"location":"zplugin-autoload.zsh/#zinit-exists-message","text":"Checks if plugin is loaded. Testable. Also outputs error message if plugin is not loaded. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - (optional) plugin (only when $1 - i.e. user - given) Has 7 line(s). Calls functions: .zinit-exists-message |-- .zinit-any-to-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: .zinit-show-report .zinit-unload","title":".zinit-exists-message"},{"location":"zplugin-autoload.zsh/#zinit-find-completions-of-plugin","text":"Searches for completions owned by given plugin. Returns them in `reply' array. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 6 line(s). Calls functions: .zinit-find-completions-of-plugin `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-show-report","title":".zinit-find-completions-of-plugin"},{"location":"zplugin-autoload.zsh/#zinit-format-env","text":"Creates one-column text about FPATH or PATH elements added when given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) $2 - if 1, then examine PATH, if 2, then examine FPATH Has 16 line(s). Doesn't call other functions. Called by: .zinit-show-report","title":".zinit-format-env"},{"location":"zplugin-autoload.zsh/#zinit-format-functions","text":"Creates a one or two columns text with functions created by given plugin. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 36 line(s). Doesn't call other functions. Called by: .zinit-show-report","title":".zinit-format-functions"},{"location":"zplugin-autoload.zsh/#zinit-format-options","text":"Creates one-column text about options that changed when plugin \"$1\" was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 21 line(s). Calls functions: .zinit-format-options |-- .zinit-restore-extendedglob `-- .zinit-save-set-extendedglob Called by: .zinit-show-report","title":".zinit-format-options"},{"location":"zplugin-autoload.zsh/#zinit-format-parameter","text":"Creates one column text that lists global parameters that changed when the given plugin was loaded. $1 - user/plugin (i.e. uspl2 format of plugin-spec) Has 34 line(s). Doesn't call other functions. Called by: .zinit-show-report","title":".zinit-format-parameter"},{"location":"zplugin-autoload.zsh/#zinit-get-completion-owner","text":"Returns \"user---plugin\" string (uspl1 format) of plugin that owns given completion. Both :A and readlink will be used, then readlink's output if results differ. Readlink might not be available. :A will read the link \"twice\" and give the final repository directory, possibly without username in the uspl format; readlink will read the link \"once\" $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 22 line(s). Doesn't call other functions. Called by: .zinit-clear-completions .zinit-get-completion-owner-uspl2col .zinit-show-completions","title":".zinit-get-completion-owner"},{"location":"zplugin-autoload.zsh/#zinit-get-completion-owner-uspl2col","text":"For shortening of code - returns colorized plugin name that owns given completion. $1 - absolute path to completion file (in COMPLETIONS_DIR) $2 - readlink command (\":\" or \"readlink\") Has 2 line(s). Calls functions: .zinit-get-completion-owner-uspl2col |-- .zinit-get-completion-owner `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: .zinit-cdisable .zinit-cenable","title":".zinit-get-completion-owner-uspl2col"},{"location":"zplugin-autoload.zsh/#zinit-get-path","text":"Returns path of given ID-string, which may be a plugin-spec (like \"user/plugin\" or \"user\" \"plugin\"), an absolute path (\"%\" \"/home/...\" and also \"%SNIPPETS/...\" etc.), or a plugin nickname (i.e. id-as'' ice-mod), or a snippet nickname. Has 35 line(s). Calls functions: .zinit-get-path |-- zinit-side.zsh/.zinit-exists-physically |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-cd .zinit-uninstall-completions","title":".zinit-get-path"},{"location":"zplugin-autoload.zsh/#zinit-glance","text":"Shows colorized source code of plugin. Is able to use pygmentize, highlight, GNU source-highlight. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 39 line(s). Calls functions: .zinit-glance |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-glance"},{"location":"zplugin-autoload.zsh/#zinit-help","text":"Shows usage information. User-action entry point. Has 68 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit","title":".zinit-help"},{"location":"zplugin-autoload.zsh/#zinit-list-bindkeys","text":"Has 42 line(s). Calls functions: .zinit-list-bindkeys `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-list-bindkeys"},{"location":"zplugin-autoload.zsh/#zinit-list-compdef-replay","text":"Shows recorded compdefs (called by plugins loaded earlier). Plugins often call `compdef' hoping for `compinit' being already ran. Zinit solves this by recording compdefs. User-action entry point. Has 5 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit","title":".zinit-list-compdef-replay"},{"location":"zplugin-autoload.zsh/#zinit-ls","text":"Has 19 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit","title":".zinit-ls"},{"location":"zplugin-autoload.zsh/#zinit-module","text":"Function that has sub-commands passed as long-options (with two dashes, --). It's an attempt to plugin only this one function into `zinit' function defined in zinit.zsh, to not make this file longer than it's needed. Has 24 line(s). Calls functions: .zinit-module `-- .zinit-build-module Called by: .zinit-build-module zinit.zsh/zinit","title":".zinit-module"},{"location":"zplugin-autoload.zsh/#zinit-prepare-readlink","text":"Prepares readlink command, used for establishing completion's owner. $REPLY = \":\" or \"readlink\" Has 4 line(s). Doesn't call other functions. Uses feature(s): type Called by: .zinit-cdisable .zinit-cenable .zinit-clear-completions .zinit-show-completions","title":".zinit-prepare-readlink"},{"location":"zplugin-autoload.zsh/#zinit-recall","text":"Has 37 line(s). Calls functions: .zinit-recall `-- .zinit-compute-ice |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-shands-exp |-- zinit-side.zsh/.zinit-two-paths |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-pack-ice Uses feature(s): wait Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-recall"},{"location":"zplugin-autoload.zsh/#zinit-recently","text":"Shows plugins that obtained commits in specified past time. User-action entry point. $1 - time spec, e.g. \"1 week\" Has 26 line(s). Calls functions: .zinit-recently `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-recently"},{"location":"zplugin-autoload.zsh/#zinit-restore-extendedglob","text":"Restores extendedglob-option from state saved earlier. Has 1 line(s). Doesn't call other functions. Called by: .zinit-format-options .zinit-show-registered-plugins .zinit-unload","title":".zinit-restore-extendedglob"},{"location":"zplugin-autoload.zsh/#zinit-save-set-extendedglob","text":"Enables extendedglob-option first saving if it was already enabled, for restoration of this state later. Has 2 line(s). Doesn't call other functions. Called by: .zinit-format-options .zinit-show-registered-plugins .zinit-unload","title":".zinit-save-set-extendedglob"},{"location":"zplugin-autoload.zsh/#zinit-search-completions","text":"While .zinit-show-completions() shows what completions are installed, this functions searches through all plugin dirs showing what's available in general (for installation). User-action entry point. Has 43 line(s). Calls functions: .zinit-search-completions `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-search-completions"},{"location":"zplugin-autoload.zsh/#zinit-self-update","text":"Updates Zinit code (does a git pull). User-action entry point. Has 23 line(s). Doesn't call other functions. Uses feature(s): zcompile Called by: zinit.zsh/zinit","title":".zinit-self-update"},{"location":"zplugin-autoload.zsh/#zinit-show-all-reports","text":"Displays reports of all loaded plugins. User-action entry point. Has 5 line(s). Calls functions: .zinit-show-all-reports `-- .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit","title":".zinit-show-all-reports"},{"location":"zplugin-autoload.zsh/#zinit-show-completions","text":"Display installed (enabled and disabled), completions. Detect stray and improper ones. Completions live even when plugin isn't loaded - if they are installed and enabled. User-action entry point. Has 72 line(s). Calls functions: .zinit-show-completions |-- .zinit-get-completion-owner |-- .zinit-prepare-readlink `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-show-completions"},{"location":"zplugin-autoload.zsh/#zinit-show-debug-report","text":"Displays dtrace report (data recorded in interactive session). User-action entry point. Has 1 line(s). Calls functions: .zinit-show-debug-report `-- .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit","title":".zinit-show-debug-report"},{"location":"zplugin-autoload.zsh/#zinit-show-registered-plugins","text":"Lists loaded plugins (subcommands list, lodaded). User-action entry point. Has 21 line(s). Calls functions: .zinit-show-registered-plugins |-- .zinit-restore-extendedglob |-- .zinit-save-set-extendedglob `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-show-registered-plugins"},{"location":"zplugin-autoload.zsh/#zinit-show-report","text":"Displays report of the plugin given. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 71 line(s). Calls functions: .zinit-show-report |-- .zinit-check-which-completions-are-enabled |-- .zinit-check-which-completions-are-installed |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-find-completions-of-plugin | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-format-env |-- .zinit-format-functions |-- .zinit-format-options | |-- .zinit-restore-extendedglob | `-- .zinit-save-set-extendedglob |-- .zinit-format-parameter `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-show-all-reports .zinit-show-debug-report zinit.zsh/zinit","title":".zinit-show-report"},{"location":"zplugin-autoload.zsh/#zinit-show-times","text":"Shows loading times of all loaded plugins. User-action entry point. Has 42 line(s). Calls functions: .zinit-show-times `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 Called by: zinit.zsh/zinit","title":".zinit-show-times"},{"location":"zplugin-autoload.zsh/#zinit-show-zstatus","text":"Shows Zinit status, i.e. number of loaded plugins, of available completions, etc. User-action entry point. Has 41 line(s). Doesn't call other functions. Called by: zinit.zsh/zinit","title":".zinit-show-zstatus"},{"location":"zplugin-autoload.zsh/#zinit-stress","text":"Compiles plugin with various options on and off to see how well the code is written. The options are: NO_SHORT_LOOPS, IGNORE_BRACES, IGNORE_CLOSE_BRACES, SH_GLOB, CSH_JUNKIE_QUOTES, NO_MULTI_FUNC_DEF. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 35 line(s). Calls functions: .zinit-stress |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): zcompile Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-stress"},{"location":"zplugin-autoload.zsh/#zinit-uncompile-plugin","text":"Uncompiles given plugin. User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $2 - plugin (only when $1 - i.e. user - given) Has 22 line(s). Calls functions: .zinit-uncompile-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-compile-uncompile-all zinit.zsh/zinit","title":".zinit-uncompile-plugin"},{"location":"zplugin-autoload.zsh/#zinit-uninstall-completions","text":"Removes all completions of given plugin from Zshell (i.e. from FPATH). The FPATH is typically `~/.zinit/completions/'. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 41 line(s). Calls functions: .zinit-uninstall-completions |-- .zinit-get-path | |-- zinit-side.zsh/.zinit-exists-physically | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | `-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit-install.zsh/.zinit-forget-completion Called by: zinit.zsh/zinit","title":".zinit-uninstall-completions"},{"location":"zplugin-autoload.zsh/#zinit-unload","text":"0. Call the Zsh Plugin's Standard *_plugin_unload function 1. Delete bindkeys (...) 2. Delete Zstyles 3. Restore options 4. Remove aliases 5. Restore Zle state 6. Unfunction functions (created by plugin) 7. Clean-up FPATH and PATH 8. Delete created variables 9. Forget the plugin User-action entry point. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 347 line(s). Calls functions: .zinit-unload |-- .zinit-clear-report-for | `-- .zinit-any-to-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-diff-env-compute |-- .zinit-diff-functions-compute |-- .zinit-diff-options-compute |-- .zinit-diff-parameter-compute |-- .zinit-exists-message | |-- .zinit-any-to-uspl2 | | `-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- .zinit-restore-extendedglob |-- .zinit-save-set-extendedglob |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit.zsh/.zinit-clear-debug-report `-- zinit.zsh/.zinit-unregister-plugin Uses feature(s): alias , bindkey , unalias , unfunction , zle , zstyle Called by: zinit.zsh/.zinit-debug-unload zinit.zsh/.zinit-run-task zinit.zsh/zinit","title":".zinit-unload"},{"location":"zplugin-autoload.zsh/#zinit-update-or-status","text":"Updates (git pull) or does `git status' for given plugin. User-action entry point. $1 - \"status\" for status, other for update $2 - plugin spec (4 formats: user---plugin, user/plugin, user (+ plugin in $2), plugin) $3 - plugin (only when $1 - i.e. user - given) Has 212 line(s). Calls functions: .zinit-update-or-status |-- .zinit-at-eval |-- .zinit-compute-ice | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | |-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit.zsh/.zinit-pack-ice |-- .zinit-update-or-status-snippet | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | `-- zinit.zsh/.zinit-load-snippet |-- zinit-install.zsh/.zinit-get-latest-gh-r-version |-- zinit-install.zsh/.zinit-setup-plugin-dir |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically-message |-- zinit-side.zsh/.zinit-store-ices |-- zinit-side.zsh/.zinit-two-paths `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): kill , read , source , wait Called by: .zinit-update-or-status-all zinit.zsh/zinit","title":".zinit-update-or-status"},{"location":"zplugin-autoload.zsh/#zinit-update-or-status-all","text":"Updates (git pull) or does `git status` for all existing plugins. This includes also plugins that are not loaded into Zsh (but exist on disk). Also updates (i.e. redownloads) snippets. User-action entry point. Has 63 line(s). Calls functions: .zinit-update-or-status-all |-- .zinit-update-or-status | |-- .zinit-at-eval | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | |-- .zinit-update-or-status-snippet | | |-- .zinit-compute-ice | | | |-- zinit-side.zsh/.zinit-exists-physically-message | | | |-- zinit-side.zsh/.zinit-shands-exp | | | |-- zinit-side.zsh/.zinit-two-paths | | | |-- zinit.zsh/.zinit-any-to-user-plugin | | | `-- zinit.zsh/.zinit-pack-ice | | `-- zinit.zsh/.zinit-load-snippet | |-- zinit-install.zsh/.zinit-get-latest-gh-r-version | |-- zinit-install.zsh/.zinit-setup-plugin-dir | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-store-ices | |-- zinit-side.zsh/.zinit-two-paths | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-update-or-status-snippet | |-- .zinit-compute-ice | | |-- zinit-side.zsh/.zinit-exists-physically-message | | |-- zinit-side.zsh/.zinit-shands-exp | | |-- zinit-side.zsh/.zinit-two-paths | | |-- zinit.zsh/.zinit-any-to-user-plugin | | `-- zinit.zsh/.zinit-pack-ice | `-- zinit.zsh/.zinit-load-snippet |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit.zsh/zinit","title":".zinit-update-or-status-all"},{"location":"zplugin-autoload.zsh/#zinit-update-or-status-snippet","text":"Implements update or status operation for snippet given by URL. $1 - \"status\" or \"update\" $2 - snippet URL Has 19 line(s). Calls functions: .zinit-update-or-status-snippet |-- .zinit-compute-ice | |-- zinit-side.zsh/.zinit-exists-physically-message | |-- zinit-side.zsh/.zinit-shands-exp | |-- zinit-side.zsh/.zinit-two-paths | |-- zinit.zsh/.zinit-any-to-user-plugin | `-- zinit.zsh/.zinit-pack-ice `-- zinit.zsh/.zinit-load-snippet Called by: .zinit-update-or-status-all .zinit-update-or-status","title":".zinit-update-or-status-snippet"},{"location":"zplugin-autoload.zsh/#compinit","text":"Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: .zinit-compinit","title":"compinit"},{"location":"zplugin-install.zsh/","text":"zinit-install.zsh(1) # NAME # zinit-install.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # .zinit-at-eval .zinit-compile-plugin .zinit-download-file-stdout .zinit-download-snippet .zinit-forget-completion .zinit-get-latest-gh-r-version .zinit-handle-binary-file .zinit-install-completions .zinit-mirror-using-svn .zinit-setup-plugin-dir DETAILS # Script Body # Has 3 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source .zinit-at-eval # Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-download-snippet .zinit-compile-plugin # Compiles given plugin (its main source file, and also an additional \"....zsh\" file if it exists). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 50 line(s). Calls functions: .zinit-compile-plugin |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): eval , zcompile Called by: .zinit-setup-plugin-dir zinit-autoload.zsh/.zinit-compile-uncompile-all zinit.zsh/zinit .zinit-download-file-stdout # Downloads file to stdout. Supports following backend commands: curl, wget, lftp, lynx. Used by snippet loading. Has 32 line(s). Calls functions: .zinit-download-file-stdout Uses feature(s): type Called by: .zinit-download-snippet .zinit-setup-plugin-dir .zinit-download-snippet # Downloads snippet \u2013 either a file \u2013 with curl, wget, lftp or lynx, or a directory, with Subversion \u2013 when svn-ICE is active. Github supports Subversion protocol and allows to clone subdirectories. This is used to provide a layer of support for Oh-My-Zsh and Prezto. Has 233 line(s). Calls functions: .zinit-download-snippet |-- .zinit-at-eval |-- .zinit-download-file-stdout |-- .zinit-install-completions | |-- .zinit-forget-completion | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-mirror-using-svn `-- zinit-side.zsh/.zinit-store-ices Uses feature(s): eval , zcompile Called by: zinit.zsh/.zinit-load-snippet .zinit-forget-completion # Implements alternation of Zsh state so that already initialized completion stops being visible to Zsh. $1 - completion function name, e.g. \"_cp\"; can also be \"cp\" Has 15 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-install-completions zinit-autoload.zsh/.zinit-compinit zinit-autoload.zsh/.zinit-uninstall-completions zinit.zsh/zinit .zinit-get-latest-gh-r-version # Gets version string of latest release of given Github package. Connects to Github releases page. Has 14 line(s). Calls functions: .zinit-get-latest-gh-r-version `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit-autoload.zsh/.zinit-update-or-status .zinit-handle-binary-file # If the file is an archive, it is extracted by this function. Next stage is scanning of files with the common utility `file', to detect executables. They are given +x mode. There are also messages to the user on performed actions. $1 - url $2 - file Has 66 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-setup-plugin-dir .zinit-install-completions # Installs all completions of given plugin. After that they are visible to `compinit'. Visible completions can be selectively disabled and enabled. User can access completion data with `clist' or `completions' subcommand. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $3 - if 1, then reinstall, otherwise only install completions that aren't there Has 34 line(s). Calls functions: .zinit-install-completions |-- .zinit-forget-completion |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically-message `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-download-snippet .zinit-setup-plugin-dir zinit.zsh/zinit .zinit-mirror-using-svn # Used to clone subdirectories from Github. If in update mode (see $2), then invokes `svn update', in normal mode invokes `svn checkout --non-interactive -q <URL>'. In test mode only compares remote and local revision and outputs true if update is needed. $1 - URL $2 - mode, \"\" - normal, \"-u\" - update, \"-t\" - test $3 - subdirectory (not path) with working copy, needed for -t and -u Has 27 line(s). Doesn't call other functions. Called by: .zinit-download-snippet .zinit-setup-plugin-dir # Clones given plugin into PLUGIN_DIR. Supports multiple sites (respecting `from' and `proto' ice modifiers). Invokes compilation of plugin's main file. $1 - user $2 - plugin Has 182 line(s). Calls functions: .zinit-setup-plugin-dir |-- .zinit-compile-plugin | |-- zinit-side.zsh/.zinit-first | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-download-file-stdout |-- .zinit-handle-binary-file |-- .zinit-install-completions | |-- .zinit-forget-completion | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | `-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit-side.zsh/.zinit-store-ices Uses feature(s): eval Called by: zinit-autoload.zsh/.zinit-update-or-status zinit.zsh/.zinit-load","title":"zinit-install.zsh(1)"},{"location":"zplugin-install.zsh/#zinit-installzsh1","text":"","title":"zinit-install.zsh(1)"},{"location":"zplugin-install.zsh/#name","text":"zinit-install.zsh - a shell script","title":"NAME"},{"location":"zplugin-install.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin-install.zsh/#functions","text":".zinit-at-eval .zinit-compile-plugin .zinit-download-file-stdout .zinit-download-snippet .zinit-forget-completion .zinit-get-latest-gh-r-version .zinit-handle-binary-file .zinit-install-completions .zinit-mirror-using-svn .zinit-setup-plugin-dir","title":"FUNCTIONS"},{"location":"zplugin-install.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin-install.zsh/#script_body","text":"Has 3 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). Uses feature(s): source","title":"Script Body"},{"location":"zplugin-install.zsh/#zinit-at-eval","text":"Has 1 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-download-snippet","title":".zinit-at-eval"},{"location":"zplugin-install.zsh/#zinit-compile-plugin","text":"Compiles given plugin (its main source file, and also an additional \"....zsh\" file if it exists). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 50 line(s). Calls functions: .zinit-compile-plugin |-- zinit-side.zsh/.zinit-first `-- zinit.zsh/.zinit-any-to-user-plugin Uses feature(s): eval , zcompile Called by: .zinit-setup-plugin-dir zinit-autoload.zsh/.zinit-compile-uncompile-all zinit.zsh/zinit","title":".zinit-compile-plugin"},{"location":"zplugin-install.zsh/#zinit-download-file-stdout","text":"Downloads file to stdout. Supports following backend commands: curl, wget, lftp, lynx. Used by snippet loading. Has 32 line(s). Calls functions: .zinit-download-file-stdout Uses feature(s): type Called by: .zinit-download-snippet .zinit-setup-plugin-dir","title":".zinit-download-file-stdout"},{"location":"zplugin-install.zsh/#zinit-download-snippet","text":"Downloads snippet \u2013 either a file \u2013 with curl, wget, lftp or lynx, or a directory, with Subversion \u2013 when svn-ICE is active. Github supports Subversion protocol and allows to clone subdirectories. This is used to provide a layer of support for Oh-My-Zsh and Prezto. Has 233 line(s). Calls functions: .zinit-download-snippet |-- .zinit-at-eval |-- .zinit-download-file-stdout |-- .zinit-install-completions | |-- .zinit-forget-completion | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-mirror-using-svn `-- zinit-side.zsh/.zinit-store-ices Uses feature(s): eval , zcompile Called by: zinit.zsh/.zinit-load-snippet","title":".zinit-download-snippet"},{"location":"zplugin-install.zsh/#zinit-forget-completion","text":"Implements alternation of Zsh state so that already initialized completion stops being visible to Zsh. $1 - completion function name, e.g. \"_cp\"; can also be \"cp\" Has 15 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-install-completions zinit-autoload.zsh/.zinit-compinit zinit-autoload.zsh/.zinit-uninstall-completions zinit.zsh/zinit","title":".zinit-forget-completion"},{"location":"zplugin-install.zsh/#zinit-get-latest-gh-r-version","text":"Gets version string of latest release of given Github package. Connects to Github releases page. Has 14 line(s). Calls functions: .zinit-get-latest-gh-r-version `-- zinit.zsh/.zinit-any-to-user-plugin Called by: zinit-autoload.zsh/.zinit-update-or-status","title":".zinit-get-latest-gh-r-version"},{"location":"zplugin-install.zsh/#zinit-handle-binary-file","text":"If the file is an archive, it is extracted by this function. Next stage is scanning of files with the common utility `file', to detect executables. They are given +x mode. There are also messages to the user on performed actions. $1 - url $2 - file Has 66 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-setup-plugin-dir","title":".zinit-handle-binary-file"},{"location":"zplugin-install.zsh/#zinit-install-completions","text":"Installs all completions of given plugin. After that they are visible to `compinit'. Visible completions can be selectively disabled and enabled. User can access completion data with `clist' or `completions' subcommand. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $3 - if 1, then reinstall, otherwise only install completions that aren't there Has 34 line(s). Calls functions: .zinit-install-completions |-- .zinit-forget-completion |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 |-- zinit-side.zsh/.zinit-exists-physically-message `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-download-snippet .zinit-setup-plugin-dir zinit.zsh/zinit","title":".zinit-install-completions"},{"location":"zplugin-install.zsh/#zinit-mirror-using-svn","text":"Used to clone subdirectories from Github. If in update mode (see $2), then invokes `svn update', in normal mode invokes `svn checkout --non-interactive -q <URL>'. In test mode only compares remote and local revision and outputs true if update is needed. $1 - URL $2 - mode, \"\" - normal, \"-u\" - update, \"-t\" - test $3 - subdirectory (not path) with working copy, needed for -t and -u Has 27 line(s). Doesn't call other functions. Called by: .zinit-download-snippet","title":".zinit-mirror-using-svn"},{"location":"zplugin-install.zsh/#zinit-setup-plugin-dir","text":"Clones given plugin into PLUGIN_DIR. Supports multiple sites (respecting `from' and `proto' ice modifiers). Invokes compilation of plugin's main file. $1 - user $2 - plugin Has 182 line(s). Calls functions: .zinit-setup-plugin-dir |-- .zinit-compile-plugin | |-- zinit-side.zsh/.zinit-first | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-download-file-stdout |-- .zinit-handle-binary-file |-- .zinit-install-completions | |-- .zinit-forget-completion | |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 | |-- zinit-side.zsh/.zinit-exists-physically-message | `-- zinit.zsh/.zinit-any-to-user-plugin |-- zinit-side.zsh/.zinit-any-colorify-as-uspl2 `-- zinit-side.zsh/.zinit-store-ices Uses feature(s): eval Called by: zinit-autoload.zsh/.zinit-update-or-status zinit.zsh/.zinit-load","title":".zinit-setup-plugin-dir"},{"location":"zplugin-side.zsh/","text":"zinit-side.zsh(1) # NAME # zinit-side.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # .zinit-any-colorify-as-uspl2 .zinit-exists-physically .zinit-exists-physically-message .zinit-first .zinit-get-plg-dir .zinit-shands-exp .zinit-store-ices .zinit-two-paths DETAILS # Script Body # Has 1 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.). .zinit-any-colorify-as-uspl2 # Returns ANSI-colorified \"user/plugin\" string, from any supported plugin spec (user---plugin, user/plugin, user plugin, plugin). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $REPLY = ANSI-colorified \"user/plugin\" string Has 11 line(s). Calls functions: .zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-exists-physically-message zinit-autoload.zsh/.zinit-clear-completions zinit-autoload.zsh/.zinit-compiled zinit-autoload.zsh/.zinit-compile-uncompile-all zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-exists-message zinit-autoload.zsh/.zinit-get-completion-owner-uspl2col zinit-autoload.zsh/.zinit-list-bindkeys zinit-autoload.zsh/.zinit-recently zinit-autoload.zsh/.zinit-search-completions zinit-autoload.zsh/.zinit-show-completions zinit-autoload.zsh/.zinit-show-registered-plugins zinit-autoload.zsh/.zinit-show-times zinit-autoload.zsh/.zinit-uncompile-plugin zinit-autoload.zsh/.zinit-unload zinit-autoload.zsh/.zinit-update-or-status-all zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-install-completions zinit-install.zsh/.zinit-setup-plugin-dir .zinit-exists-physically # Checks if directory of given plugin exists in PLUGIN_DIR. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 10 line(s). Calls functions: .zinit-exists-physically |-- .zinit-shands-exp `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-exists-physically-message zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-get-path .zinit-exists-physically-message # Checks if directory of given plugin exists in PLUGIN_DIR, and outputs error message if it doesn't. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 11 line(s). Calls functions: .zinit-exists-physically-message |-- .zinit-any-colorify-as-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-exists-physically | |-- .zinit-shands-exp | `-- zinit.zsh/.zinit-any-to-user-plugin `-- .zinit-shands-exp Called by: zinit-autoload.zsh/.zinit-changes zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-stress zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-install-completions .zinit-first # Finds the main file of plugin. There are multiple file name formats, they are ordered in order starting from more correct ones, and matched. .zinit-load-plugin() has similar code parts and doesn't call .zinit-first() \u2013 for performance. Obscure matching is done in .zinit-find-other-matches, here and in .zinit-load(). Obscure = non-standard main-file naming convention. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 17 line(s). Calls functions: .zinit-first |-- .zinit-get-plg-dir |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-find-other-matches Called by: zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-stress zinit-install.zsh/.zinit-compile-plugin .zinit-get-plg-dir # Has 9 line(s). Doesn't call other functions. Called by: .zinit-first .zinit-shands-exp # Does expansion of currently little unstandarized shorthands like \"%SNIPPETS\", \"%HOME\", \"OMZ::\", \"PZT::\". Has 3 line(s). Doesn't call other functions. Called by: .zinit-exists-physically-message .zinit-exists-physically zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-get-path .zinit-store-ices # Saves ice mods in given hash onto disk. $1 - directory where to create / delete files $2 - name of hash that holds values $3 - additional keys of hash to store, space separated $4 - additional keys of hash to store, empty-meaningful ices, space separated Has 30 line(s). Doesn't call other functions. Uses feature(s): wait Called by: zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-download-snippet zinit-install.zsh/.zinit-setup-plugin-dir .zinit-two-paths # Obtains a snippet URL without specification if it is an SVN URL (points to directory) or regular URL (points to file), returns 2 possible paths for further examination Has 19 line(s). Doesn't call other functions. Called by: zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-get-path zinit-autoload.zsh/.zinit-update-or-status","title":"zinit-side.zsh(1)"},{"location":"zplugin-side.zsh/#zinit-sidezsh1","text":"","title":"zinit-side.zsh(1)"},{"location":"zplugin-side.zsh/#name","text":"zinit-side.zsh - a shell script","title":"NAME"},{"location":"zplugin-side.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin-side.zsh/#functions","text":".zinit-any-colorify-as-uspl2 .zinit-exists-physically .zinit-exists-physically-message .zinit-first .zinit-get-plg-dir .zinit-shands-exp .zinit-store-ices .zinit-two-paths","title":"FUNCTIONS"},{"location":"zplugin-side.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin-side.zsh/#script_body","text":"Has 1 line(s). No functions are called (may set up e.g. a hook, a Zle widget bound to a key, etc.).","title":"Script Body"},{"location":"zplugin-side.zsh/#zinit-any-colorify-as-uspl2","text":"Returns ANSI-colorified \"user/plugin\" string, from any supported plugin spec (user---plugin, user/plugin, user plugin, plugin). $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) $REPLY = ANSI-colorified \"user/plugin\" string Has 11 line(s). Calls functions: .zinit-any-colorify-as-uspl2 `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-exists-physically-message zinit-autoload.zsh/.zinit-clear-completions zinit-autoload.zsh/.zinit-compiled zinit-autoload.zsh/.zinit-compile-uncompile-all zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-exists-message zinit-autoload.zsh/.zinit-get-completion-owner-uspl2col zinit-autoload.zsh/.zinit-list-bindkeys zinit-autoload.zsh/.zinit-recently zinit-autoload.zsh/.zinit-search-completions zinit-autoload.zsh/.zinit-show-completions zinit-autoload.zsh/.zinit-show-registered-plugins zinit-autoload.zsh/.zinit-show-times zinit-autoload.zsh/.zinit-uncompile-plugin zinit-autoload.zsh/.zinit-unload zinit-autoload.zsh/.zinit-update-or-status-all zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-install-completions zinit-install.zsh/.zinit-setup-plugin-dir","title":".zinit-any-colorify-as-uspl2"},{"location":"zplugin-side.zsh/#zinit-exists-physically","text":"Checks if directory of given plugin exists in PLUGIN_DIR. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 10 line(s). Calls functions: .zinit-exists-physically |-- .zinit-shands-exp `-- zinit.zsh/.zinit-any-to-user-plugin Called by: .zinit-exists-physically-message zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-get-path","title":".zinit-exists-physically"},{"location":"zplugin-side.zsh/#zinit-exists-physically-message","text":"Checks if directory of given plugin exists in PLUGIN_DIR, and outputs error message if it doesn't. Testable. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 11 line(s). Calls functions: .zinit-exists-physically-message |-- .zinit-any-colorify-as-uspl2 | `-- zinit.zsh/.zinit-any-to-user-plugin |-- .zinit-exists-physically | |-- .zinit-shands-exp | `-- zinit.zsh/.zinit-any-to-user-plugin `-- .zinit-shands-exp Called by: zinit-autoload.zsh/.zinit-changes zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-stress zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-install-completions","title":".zinit-exists-physically-message"},{"location":"zplugin-side.zsh/#zinit-first","text":"Finds the main file of plugin. There are multiple file name formats, they are ordered in order starting from more correct ones, and matched. .zinit-load-plugin() has similar code parts and doesn't call .zinit-first() \u2013 for performance. Obscure matching is done in .zinit-find-other-matches, here and in .zinit-load(). Obscure = non-standard main-file naming convention. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin (only when $1 - i.e. user - given) Has 17 line(s). Calls functions: .zinit-first |-- .zinit-get-plg-dir |-- zinit.zsh/.zinit-any-to-user-plugin `-- zinit.zsh/.zinit-find-other-matches Called by: zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-stress zinit-install.zsh/.zinit-compile-plugin","title":".zinit-first"},{"location":"zplugin-side.zsh/#zinit-get-plg-dir","text":"Has 9 line(s). Doesn't call other functions. Called by: .zinit-first","title":".zinit-get-plg-dir"},{"location":"zplugin-side.zsh/#zinit-shands-exp","text":"Does expansion of currently little unstandarized shorthands like \"%SNIPPETS\", \"%HOME\", \"OMZ::\", \"PZT::\". Has 3 line(s). Doesn't call other functions. Called by: .zinit-exists-physically-message .zinit-exists-physically zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-get-path","title":".zinit-shands-exp"},{"location":"zplugin-side.zsh/#zinit-store-ices","text":"Saves ice mods in given hash onto disk. $1 - directory where to create / delete files $2 - name of hash that holds values $3 - additional keys of hash to store, space separated $4 - additional keys of hash to store, empty-meaningful ices, space separated Has 30 line(s). Doesn't call other functions. Uses feature(s): wait Called by: zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-download-snippet zinit-install.zsh/.zinit-setup-plugin-dir","title":".zinit-store-ices"},{"location":"zplugin-side.zsh/#zinit-two-paths","text":"Obtains a snippet URL without specification if it is an SVN URL (points to directory) or regular URL (points to file), returns 2 possible paths for further examination Has 19 line(s). Doesn't call other functions. Called by: zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-get-path zinit-autoload.zsh/.zinit-update-or-status","title":".zinit-two-paths"},{"location":"zplugin.zsh/","text":"zinit.zsh(1) # NAME # zinit.zsh - a shell script SYNOPSIS # Documentation automatically generated with `zshelldoc' FUNCTIONS # pmodload zpcdclear zpcdreplay zpcompdef zpcompinit .zinit-add-report .zinit-any-to-user-plugin .zinit-clear-debug-report .zinit-compdef-clear .zinit-compdef-replay .zinit-debug-start .zinit-debug-stop .zinit-debug-unload .zinit-deploy-message .zinit-diff .zinit-diff-env .zinit-diff-functions .zinit-diff-options .zinit-diff-parameter .zinit-find-other-matches .zinit-ice .zinit-load .zinit-load-plugin .zinit-load-snippet .zinit-pack-ice .zinit-prepare-home .zinit-register-plugin @zplg-register-z-plugin :zinit-reload-and-run .zinit-run-task .zinit-service :zinit-shadow-alias :zinit-shadow-autoload :zinit-shadow-bindkey :zinit-shadow-compdef .zinit-shadow-off .zinit-shadow-on :zinit-shadow-zle :zinit-shadow-zstyle .zinit-submit-turbo .zinit-unregister-plugin .zinit-wrap-track-functions zinit -zinit_scheduler_add_sh AUTOLOAD add-zsh-hook AUTOLOAD compinit AUTOLOAD is-at-least PRECMD-HOOK @zinit-scheduler DETAILS # Script Body # Has 117 line(s). Calls functions: Script-Body |-- add-zsh-hook |-- is-at-least `-- .zinit-prepare-home Uses feature(s): alias , autoload , export , zmodload , zstyle Exports (environment): ZPFX pmodload # Compatibility with Prezto. Calls can be recursive. Has 9 line(s). Calls functions: pmodload `-- .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcdclear # A wrapper for `zinit cdclear -q' which can be called from hook ices like the atinit'', atload'', etc. ices. Has 1 line(s). Calls functions: zpcdclear `-- .zinit-compdef-clear Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcdreplay # A function that can be invoked from within `atinit', `atload', etc. ice-mod. It works like `zinit cdreplay', which cannot be invoked from such hook ices. Has 1 line(s). Calls functions: zpcdreplay `-- .zinit-compdef-replay Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcompdef # Stores compdef for a replay with `zpcdreplay' (turbo mode) or with `zinit cdreplay' (normal mode). An utility functton of an undefined use case. Has 1 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). zpcompinit # A function that can be invoked from within `atinit', `atload', etc. ice-mod. It runs `autoload compinit; compinit' and respects ZINIT[ZCOMPDUMP_PATH] and ZINIT[COMPINIT_OPTS]. Has 1 line(s). Calls functions: zpcompinit `-- compinit Uses feature(s): autoload Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-add-report # Adds a report line for given plugin. $1 - uspl2, i.e. user/plugin $2, ... - the text Has 2 line(s). Doesn't call other functions. Called by: .zinit-load-plugin :zinit-shadow-alias :zinit-shadow-autoload :zinit-shadow-bindkey :zinit-shadow-compdef :zinit-shadow-zle :zinit-shadow-zstyle .zinit-any-to-user-plugin # Allows elastic plugin-spec across the code. $1 - plugin spec (2 formats: user/plugin, user plugin) $2 - plugin (only when $1 - i.e. user - given) Returns user and plugin in $reply Has 23 line(s). Doesn't call other functions. Called by: .zinit-load .zinit-unregister-plugin zinit-autoload.zsh/.zinit-any-to-uspl2 zinit-autoload.zsh/.zinit-changes zinit-autoload.zsh/.zinit-compiled zinit-autoload.zsh/.zinit-compile-uncompile-all zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-find-completions-of-plugin zinit-autoload.zsh/.zinit-get-path zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-show-report zinit-autoload.zsh/.zinit-stress zinit-autoload.zsh/.zinit-uncompile-plugin zinit-autoload.zsh/.zinit-unload zinit-autoload.zsh/.zinit-update-or-status-all zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-compile-plugin zinit-install.zsh/.zinit-get-latest-gh-r-version zinit-install.zsh/.zinit-install-completions zinit-side.zsh/.zinit-any-colorify-as-uspl2 zinit-side.zsh/.zinit-exists-physically zinit-side.zsh/.zinit-first .zinit-clear-debug-report # Forgets dtrace repport gathered up to this moment. Has 1 line(s). Calls functions: .zinit-clear-debug-report `-- zinit-autoload.zsh/.zinit-clear-report-for Called by: zinit zinit-autoload.zsh/.zinit-unload .zinit-compdef-clear # Implements user-exposed functionality to clear gathered compdefs. Has 3 line(s). Doesn't call other functions. Called by: zpcdclear zinit .zinit-compdef-replay # Runs gathered compdef calls. This allows to run `compinit' after loading plugins. Has 16 line(s). Doesn't call other functions. Called by: zpcdreplay zinit .zinit-debug-start # Starts Dtrace, i.e. session tracking for changes in Zsh state. Has 9 line(s). Calls functions: .zinit-debug-start |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter `-- .zinit-shadow-on Called by: zinit .zinit-debug-stop # Stops Dtrace, i.e. session tracking for changes in Zsh state. Has 3 line(s). Calls functions: .zinit-debug-stop |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter `-- .zinit-shadow-off Called by: zinit .zinit-debug-unload # Reverts changes detected by dtrace run. Has 5 line(s). Calls functions: .zinit-debug-unload `-- zinit-autoload.zsh/.zinit-unload Called by: zinit .zinit-deploy-message # Deploys a sub-prompt message to be displayed OR a `zle .reset-prompt' call to be invoked Has 12 line(s). Doesn't call other functions. Uses feature(s): read , zle Called by: .zinit-load-snippet .zinit-load .zinit-diff # Performs diff actions of all types Has 4 line(s). Calls functions: .zinit-diff |-- .zinit-diff-env |-- .zinit-diff-functions |-- .zinit-diff-options `-- .zinit-diff-parameter Called by: .zinit-debug-start .zinit-debug-stop .zinit-load-plugin .zinit-diff-env # Implements detection of change in PATH and FPATH. $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 18 line(s). Doesn't call other functions. Called by: .zinit-diff .zinit-load-plugin .zinit-diff-functions # Implements detection of newly created functions. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 8 line(s). Doesn't call other functions. Called by: .zinit-diff .zinit-diff-options # Implements detection of change in option state. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 7 line(s). Doesn't call other functions. Called by: .zinit-diff .zinit-diff-parameter # Implements detection of change in any parameter's existence and type. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 9 line(s). Doesn't call other functions. Called by: .zinit-diff .zinit-find-other-matches # Plugin's main source file is in general `name.plugin.zsh'. However, there can be different conventions, if that file is not found, then this functions examines other conventions in order of most expected sanity. Has 14 line(s). Doesn't call other functions. Called by: .zinit-load-plugin zinit-side.zsh/.zinit-first .zinit-ice # Parses ICE specification (`zplg ice' subcommand), puts the result into ZINIT_ICE global hash. The ice-spec is valid for next command only (i.e. it \"melts\"), but it can then stick to plugin and activate e.g. at update. Has 8 line(s). Doesn't call other functions. Called by: zinit Environment variables used: ZPFX .zinit-load # Implements the exposed-to-user action of loading a plugin. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin name, if the third format is used Has 42 line(s). Calls functions: .zinit-load |-- .zinit-any-to-user-plugin |-- .zinit-deploy-message |-- .zinit-load-plugin | |-- .zinit-add-report | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | |-- .zinit-diff-env | |-- .zinit-find-other-matches | |-- .zinit-shadow-off | |-- .zinit-shadow-on | `-- .zinit-wrap-track-functions |-- .zinit-pack-ice |-- .zinit-register-plugin `-- zinit-install.zsh/.zinit-setup-plugin-dir Uses feature(s): eval , source , zle Called by: .zinit-run-task .zinit-service zinit .zinit-load-plugin # Lower-level function for loading a plugin. $1 - user $2 - plugin $3 - mode (light or load) Has 96 line(s). Calls functions: .zinit-load-plugin |-- .zinit-add-report |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter |-- .zinit-diff-env |-- .zinit-find-other-matches |-- .zinit-shadow-off |-- .zinit-shadow-on `-- .zinit-wrap-track-functions Uses feature(s): eval , source , zle Called by: .zinit-load .zinit-load-snippet # Implements the exposed-to-user action of loading a snippet. $1 - url (can be local, absolute path) Has 180 line(s). Calls functions: .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): autoload , eval , source , unfunction , zparseopts , zstyle Called by: pmodload .zinit-run-task .zinit-service zinit zinit-autoload.zsh/.zinit-update-or-status-snippet .zinit-pack-ice # Remembers all ice-mods, assigns them to concrete plugin. Ice spec is in general forgotten for second-next command (that's why it's called \"ice\" - it melts), however they glue to the object (plugin or snippet) mentioned in the next command \u2013 for later use with e.g. `zinit update ...' Has 3 line(s). Doesn't call other functions. Called by: .zinit-load-snippet .zinit-load zinit-autoload.zsh/.zinit-compute-ice .zinit-prepare-home # Creates all directories needed by Zinit, first checks if they already exist. Has 28 line(s). Doesn't call other functions. Called by: Script-Body Environment variables used: ZPFX .zinit-register-plugin # Adds the plugin to ZINIT_REGISTERED_PLUGINS array and to the zsh_loaded_plugins array (managed according to the plugin standard: http://zdharma.org/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html) Has 23 line(s). Doesn't call other functions. Called by: .zinit-load @zplg-register-z-plugin # Registers the z-plugin inside Zinit \u2013 i.e. an Zinit extension Has 4 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-reload-and-run # Marks given function ($3) for autoloading, and executes it triggering the load. $1 is the fpath dedicated to the function, $2 are autoload options. This function replaces \"autoload -X\", because using that on older Zsh versions causes problems with traps. So basically one creates function stub that calls :zinit-reload-and-run() instead of \"autoload -X\". $1 - FPATH dedicated to function $2 - autoload options $3 - function name (one that needs autoloading) Author: Bart Schaefer Has 7 line(s). Doesn't call other functions. Uses feature(s): autoload , unfunction Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-run-task # A backend, worker function of .zinit-scheduler. It obtains the tasks index and a few of its properties (like the type: plugin, snippet, service plugin, service snippet) and executes it first checking for additional conditions (like non-numeric wait'' ice). $1 - the pass number, either 1st or 2nd pass $2 - the time assigned to the task $3 - type: plugin, snippet, service plugin, service snippet $4 - task's index in the ZINIT[WAIT_ICE_...] fields $5 - mode: load or light $6 - the plugin-spec or snippet URL or alias name (from id-as'') Has 41 line(s). Calls functions: .zinit-run-task |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet `-- zinit-autoload.zsh/.zinit-unload Uses feature(s): eval , source , zle , zpty Called by: @zinit-scheduler @zinit-scheduler # Searches for timeout tasks, executes them. There's an array of tasks waiting for execution, this scheduler manages them, detects which ones should be run at current moment, decides to remove (or not) them from the array after execution. $1 - if \"following\", then it is non-first (second and more) invocation of the scheduler; this results in chain of `sched' invocations that results in repetitive @zinit-scheduler activity if \"burst\", then all tasks are marked timeout and executed one by one; this is handy if e.g. a docker image starts up and needs to install all turbo-mode plugins without any hesitation (delay), i.e. \"burst\" allows to run package installations from script, not from prompt Has 62 line(s). Is a precmd hook . Calls functions: @zinit-scheduler |-- add-zsh-hook `-- .zinit-run-task |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet `-- zinit-autoload.zsh/.zinit-unload Uses feature(s): sched , zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-service # Handles given service, i.e. obtains lock, runs it, or waits if no lock $1 - type \"p\" or \"s\" (plugin or snippet) $2 - mode - for plugin (light or load) $3 - id - URL or plugin ID or alias name (from id-as'') Has 30 line(s). Calls functions: .zinit-service |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir `-- .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): kill , read Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-shadow-alias # Function defined to hijack plugin's calls to `alias' builtin. The hijacking is to gather report data (which is used in unload). Has 34 line(s). Calls functions: :zinit-shadow-alias `-- .zinit-add-report Uses feature(s): alias , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-shadow-autoload # Function defined to hijack plugin's calls to `autoload' builtin. The hijacking is not only to gather report data, but also to run custom `autoload' function, that doesn't need FPATH. Has 48 line(s). Calls functions: :zinit-shadow-autoload `-- .zinit-add-report Uses feature(s): autoload , eval , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-shadow-bindkey # Function defined to hijack plugin's calls to `bindkey' builtin. The hijacking is to gather report data (which is used in unload). Has 104 line(s). Calls functions: :zinit-shadow-bindkey |-- is-at-least `-- .zinit-add-report Uses feature(s): bindkey , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-shadow-compdef # Function defined to hijack plugin's calls to `compdef' function. The hijacking is not only for reporting, but also to save compdef calls so that `compinit' can be called after loading plugins. Has 4 line(s). Calls functions: :zinit-shadow-compdef `-- .zinit-add-report Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-shadow-off # Turn off shadowing completely for a given mode (\"load\", \"light\", \"light-b\" (i.e. the `trackbinds' mode) or \"compdef\"). Has 18 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-debug-stop .zinit-load-plugin .zinit-shadow-on # Turn on shadowing of builtins and functions according to passed mode (\"load\", \"light\", \"light-b\" or \"compdef\"). The shadowing is to gather report data, and to hijack `autoload', `bindkey' and `compdef' calls. Has 25 line(s). Doesn't call other functions. Called by: .zinit-debug-start .zinit-load-plugin :zinit-shadow-zle # Function defined to hijack plugin's calls to `zle' builtin. The hijacking is to gather report data (which is used in unload). Has 38 line(s). Calls functions: :zinit-shadow-zle `-- .zinit-add-report Uses feature(s): zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). :zinit-shadow-zstyle # Function defined to hijack plugin's calls to `zstyle' builtin. The hijacking is to gather report data (which is used in unload). Has 21 line(s). Calls functions: :zinit-shadow-zstyle `-- .zinit-add-report Uses feature(s): zparseopts , zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). .zinit-submit-turbo # If `zinit load`, `zinit light` or `zinit snippet` will be preceded with `wait', `load', `unload' or `on-update-of`/`subscribe' ice-mods then the plugin or snipped is to be loaded in turbo-mode, and this function adds it to internal data structures, so that @zinit-scheduler can run (load, unload) this as a task. Has 14 line(s). Doesn't call other functions. Called by: zinit .zinit-unregister-plugin # Removes the plugin from ZINIT_REGISTERED_PLUGINS array and from the zsh_loaded_plugins array (managed according to the plugin standard) Has 5 line(s). Calls functions: .zinit-unregister-plugin `-- .zinit-any-to-user-plugin Called by: zinit-autoload.zsh/.zinit-unload .zinit-wrap-track-functions # Has 19 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-load-plugin .zinit-load-snippet zinit # Main function directly exposed to user, obtains subcommand and its arguments, has completion. Has 290 line(s). Calls functions: zinit |-- compinit |-- .zinit-clear-debug-report | `-- zinit-autoload.zsh/.zinit-clear-report-for |-- .zinit-compdef-clear |-- .zinit-compdef-replay |-- .zinit-debug-start | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | `-- .zinit-shadow-on |-- .zinit-debug-stop | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | `-- .zinit-shadow-off |-- .zinit-debug-unload | `-- zinit-autoload.zsh/.zinit-unload |-- .zinit-ice |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet |-- .zinit-submit-turbo |-- zinit-autoload.zsh/.zinit-cdisable |-- zinit-autoload.zsh/.zinit-cenable |-- zinit-autoload.zsh/.zinit-clear-completions |-- zinit-autoload.zsh/.zinit-compiled |-- zinit-autoload.zsh/.zinit-compile-uncompile-all |-- zinit-autoload.zsh/.zinit-compinit |-- zinit-autoload.zsh/.zinit-help |-- zinit-autoload.zsh/.zinit-list-bindkeys |-- zinit-autoload.zsh/.zinit-list-compdef-replay |-- zinit-autoload.zsh/.zinit-ls |-- zinit-autoload.zsh/.zinit-module |-- zinit-autoload.zsh/.zinit-recently |-- zinit-autoload.zsh/.zinit-search-completions |-- zinit-autoload.zsh/.zinit-self-update |-- zinit-autoload.zsh/.zinit-show-all-reports |-- zinit-autoload.zsh/.zinit-show-completions |-- zinit-autoload.zsh/.zinit-show-debug-report |-- zinit-autoload.zsh/.zinit-show-registered-plugins |-- zinit-autoload.zsh/.zinit-show-report |-- zinit-autoload.zsh/.zinit-show-times |-- zinit-autoload.zsh/.zinit-show-zstatus |-- zinit-autoload.zsh/.zinit-uncompile-plugin |-- zinit-autoload.zsh/.zinit-uninstall-completions |-- zinit-autoload.zsh/.zinit-unload |-- zinit-autoload.zsh/.zinit-update-or-status |-- zinit-autoload.zsh/.zinit-update-or-status-all |-- zinit-install.zsh/.zinit-compile-plugin |-- zinit-install.zsh/.zinit-forget-completion `-- zinit-install.zsh/.zinit-install-completions Uses feature(s): autoload , eval , source Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). -zinit_scheduler_add_sh # Copies task into ZINIT_RUN array, called when a task timeouts. A small function ran from pattern in /-substitution as a math function. Has 7 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.). add-zsh-hook # Has 93 line(s). Doesn't call other functions. Uses feature(s): autoload , getopts Called by: Script-Body @zinit-scheduler compinit # Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: zpcompinit zinit is-at-least # Has 56 line(s). Doesn't call other functions. Called by: Script-Body :zinit-shadow-bindkey","title":"zinit.zsh(1)"},{"location":"zplugin.zsh/#zinitzsh1","text":"","title":"zinit.zsh(1)"},{"location":"zplugin.zsh/#name","text":"zinit.zsh - a shell script","title":"NAME"},{"location":"zplugin.zsh/#synopsis","text":"Documentation automatically generated with `zshelldoc'","title":"SYNOPSIS"},{"location":"zplugin.zsh/#functions","text":"pmodload zpcdclear zpcdreplay zpcompdef zpcompinit .zinit-add-report .zinit-any-to-user-plugin .zinit-clear-debug-report .zinit-compdef-clear .zinit-compdef-replay .zinit-debug-start .zinit-debug-stop .zinit-debug-unload .zinit-deploy-message .zinit-diff .zinit-diff-env .zinit-diff-functions .zinit-diff-options .zinit-diff-parameter .zinit-find-other-matches .zinit-ice .zinit-load .zinit-load-plugin .zinit-load-snippet .zinit-pack-ice .zinit-prepare-home .zinit-register-plugin @zplg-register-z-plugin :zinit-reload-and-run .zinit-run-task .zinit-service :zinit-shadow-alias :zinit-shadow-autoload :zinit-shadow-bindkey :zinit-shadow-compdef .zinit-shadow-off .zinit-shadow-on :zinit-shadow-zle :zinit-shadow-zstyle .zinit-submit-turbo .zinit-unregister-plugin .zinit-wrap-track-functions zinit -zinit_scheduler_add_sh AUTOLOAD add-zsh-hook AUTOLOAD compinit AUTOLOAD is-at-least PRECMD-HOOK @zinit-scheduler","title":"FUNCTIONS"},{"location":"zplugin.zsh/#details","text":"","title":"DETAILS"},{"location":"zplugin.zsh/#script_body","text":"Has 117 line(s). Calls functions: Script-Body |-- add-zsh-hook |-- is-at-least `-- .zinit-prepare-home Uses feature(s): alias , autoload , export , zmodload , zstyle Exports (environment): ZPFX","title":"Script Body"},{"location":"zplugin.zsh/#pmodload","text":"Compatibility with Prezto. Calls can be recursive. Has 9 line(s). Calls functions: pmodload `-- .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"pmodload"},{"location":"zplugin.zsh/#zpcdclear","text":"A wrapper for `zinit cdclear -q' which can be called from hook ices like the atinit'', atload'', etc. ices. Has 1 line(s). Calls functions: zpcdclear `-- .zinit-compdef-clear Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcdclear"},{"location":"zplugin.zsh/#zpcdreplay","text":"A function that can be invoked from within `atinit', `atload', etc. ice-mod. It works like `zinit cdreplay', which cannot be invoked from such hook ices. Has 1 line(s). Calls functions: zpcdreplay `-- .zinit-compdef-replay Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcdreplay"},{"location":"zplugin.zsh/#zpcompdef","text":"Stores compdef for a replay with `zpcdreplay' (turbo mode) or with `zinit cdreplay' (normal mode). An utility functton of an undefined use case. Has 1 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcompdef"},{"location":"zplugin.zsh/#zpcompinit","text":"A function that can be invoked from within `atinit', `atload', etc. ice-mod. It runs `autoload compinit; compinit' and respects ZINIT[ZCOMPDUMP_PATH] and ZINIT[COMPINIT_OPTS]. Has 1 line(s). Calls functions: zpcompinit `-- compinit Uses feature(s): autoload Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zpcompinit"},{"location":"zplugin.zsh/#zinit-add-report","text":"Adds a report line for given plugin. $1 - uspl2, i.e. user/plugin $2, ... - the text Has 2 line(s). Doesn't call other functions. Called by: .zinit-load-plugin :zinit-shadow-alias :zinit-shadow-autoload :zinit-shadow-bindkey :zinit-shadow-compdef :zinit-shadow-zle :zinit-shadow-zstyle","title":".zinit-add-report"},{"location":"zplugin.zsh/#zinit-any-to-user-plugin","text":"Allows elastic plugin-spec across the code. $1 - plugin spec (2 formats: user/plugin, user plugin) $2 - plugin (only when $1 - i.e. user - given) Returns user and plugin in $reply Has 23 line(s). Doesn't call other functions. Called by: .zinit-load .zinit-unregister-plugin zinit-autoload.zsh/.zinit-any-to-uspl2 zinit-autoload.zsh/.zinit-changes zinit-autoload.zsh/.zinit-compiled zinit-autoload.zsh/.zinit-compile-uncompile-all zinit-autoload.zsh/.zinit-compute-ice zinit-autoload.zsh/.zinit-create zinit-autoload.zsh/.zinit-delete zinit-autoload.zsh/.zinit-edit zinit-autoload.zsh/.zinit-find-completions-of-plugin zinit-autoload.zsh/.zinit-get-path zinit-autoload.zsh/.zinit-glance zinit-autoload.zsh/.zinit-show-report zinit-autoload.zsh/.zinit-stress zinit-autoload.zsh/.zinit-uncompile-plugin zinit-autoload.zsh/.zinit-unload zinit-autoload.zsh/.zinit-update-or-status-all zinit-autoload.zsh/.zinit-update-or-status zinit-install.zsh/.zinit-compile-plugin zinit-install.zsh/.zinit-get-latest-gh-r-version zinit-install.zsh/.zinit-install-completions zinit-side.zsh/.zinit-any-colorify-as-uspl2 zinit-side.zsh/.zinit-exists-physically zinit-side.zsh/.zinit-first","title":".zinit-any-to-user-plugin"},{"location":"zplugin.zsh/#zinit-clear-debug-report","text":"Forgets dtrace repport gathered up to this moment. Has 1 line(s). Calls functions: .zinit-clear-debug-report `-- zinit-autoload.zsh/.zinit-clear-report-for Called by: zinit zinit-autoload.zsh/.zinit-unload","title":".zinit-clear-debug-report"},{"location":"zplugin.zsh/#zinit-compdef-clear","text":"Implements user-exposed functionality to clear gathered compdefs. Has 3 line(s). Doesn't call other functions. Called by: zpcdclear zinit","title":".zinit-compdef-clear"},{"location":"zplugin.zsh/#zinit-compdef-replay","text":"Runs gathered compdef calls. This allows to run `compinit' after loading plugins. Has 16 line(s). Doesn't call other functions. Called by: zpcdreplay zinit","title":".zinit-compdef-replay"},{"location":"zplugin.zsh/#zinit-debug-start","text":"Starts Dtrace, i.e. session tracking for changes in Zsh state. Has 9 line(s). Calls functions: .zinit-debug-start |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter `-- .zinit-shadow-on Called by: zinit","title":".zinit-debug-start"},{"location":"zplugin.zsh/#zinit-debug-stop","text":"Stops Dtrace, i.e. session tracking for changes in Zsh state. Has 3 line(s). Calls functions: .zinit-debug-stop |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter `-- .zinit-shadow-off Called by: zinit","title":".zinit-debug-stop"},{"location":"zplugin.zsh/#zinit-debug-unload","text":"Reverts changes detected by dtrace run. Has 5 line(s). Calls functions: .zinit-debug-unload `-- zinit-autoload.zsh/.zinit-unload Called by: zinit","title":".zinit-debug-unload"},{"location":"zplugin.zsh/#zinit-deploy-message","text":"Deploys a sub-prompt message to be displayed OR a `zle .reset-prompt' call to be invoked Has 12 line(s). Doesn't call other functions. Uses feature(s): read , zle Called by: .zinit-load-snippet .zinit-load","title":".zinit-deploy-message"},{"location":"zplugin.zsh/#zinit-diff","text":"Performs diff actions of all types Has 4 line(s). Calls functions: .zinit-diff |-- .zinit-diff-env |-- .zinit-diff-functions |-- .zinit-diff-options `-- .zinit-diff-parameter Called by: .zinit-debug-start .zinit-debug-stop .zinit-load-plugin","title":".zinit-diff"},{"location":"zplugin.zsh/#zinit-diff-env","text":"Implements detection of change in PATH and FPATH. $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 18 line(s). Doesn't call other functions. Called by: .zinit-diff .zinit-load-plugin","title":".zinit-diff-env"},{"location":"zplugin.zsh/#zinit-diff-functions","text":"Implements detection of newly created functions. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 8 line(s). Doesn't call other functions. Called by: .zinit-diff","title":".zinit-diff-functions"},{"location":"zplugin.zsh/#zinit-diff-options","text":"Implements detection of change in option state. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 7 line(s). Doesn't call other functions. Called by: .zinit-diff","title":".zinit-diff-options"},{"location":"zplugin.zsh/#zinit-diff-parameter","text":"Implements detection of change in any parameter's existence and type. Performs data gathering, computation is done in *-compute(). $1 - user/plugin (i.e. uspl2 format) $2 - command, can be \"begin\" or \"end\" Has 9 line(s). Doesn't call other functions. Called by: .zinit-diff","title":".zinit-diff-parameter"},{"location":"zplugin.zsh/#zinit-find-other-matches","text":"Plugin's main source file is in general `name.plugin.zsh'. However, there can be different conventions, if that file is not found, then this functions examines other conventions in order of most expected sanity. Has 14 line(s). Doesn't call other functions. Called by: .zinit-load-plugin zinit-side.zsh/.zinit-first","title":".zinit-find-other-matches"},{"location":"zplugin.zsh/#zinit-ice","text":"Parses ICE specification (`zplg ice' subcommand), puts the result into ZINIT_ICE global hash. The ice-spec is valid for next command only (i.e. it \"melts\"), but it can then stick to plugin and activate e.g. at update. Has 8 line(s). Doesn't call other functions. Called by: zinit Environment variables used: ZPFX","title":".zinit-ice"},{"location":"zplugin.zsh/#zinit-load","text":"Implements the exposed-to-user action of loading a plugin. $1 - plugin spec (4 formats: user---plugin, user/plugin, user, plugin) $2 - plugin name, if the third format is used Has 42 line(s). Calls functions: .zinit-load |-- .zinit-any-to-user-plugin |-- .zinit-deploy-message |-- .zinit-load-plugin | |-- .zinit-add-report | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | |-- .zinit-diff-env | |-- .zinit-find-other-matches | |-- .zinit-shadow-off | |-- .zinit-shadow-on | `-- .zinit-wrap-track-functions |-- .zinit-pack-ice |-- .zinit-register-plugin `-- zinit-install.zsh/.zinit-setup-plugin-dir Uses feature(s): eval , source , zle Called by: .zinit-run-task .zinit-service zinit","title":".zinit-load"},{"location":"zplugin.zsh/#zinit-load-plugin","text":"Lower-level function for loading a plugin. $1 - user $2 - plugin $3 - mode (light or load) Has 96 line(s). Calls functions: .zinit-load-plugin |-- .zinit-add-report |-- .zinit-diff | |-- .zinit-diff-env | |-- .zinit-diff-functions | |-- .zinit-diff-options | `-- .zinit-diff-parameter |-- .zinit-diff-env |-- .zinit-find-other-matches |-- .zinit-shadow-off |-- .zinit-shadow-on `-- .zinit-wrap-track-functions Uses feature(s): eval , source , zle Called by: .zinit-load","title":".zinit-load-plugin"},{"location":"zplugin.zsh/#zinit-load-snippet","text":"Implements the exposed-to-user action of loading a snippet. $1 - url (can be local, absolute path) Has 180 line(s). Calls functions: .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): autoload , eval , source , unfunction , zparseopts , zstyle Called by: pmodload .zinit-run-task .zinit-service zinit zinit-autoload.zsh/.zinit-update-or-status-snippet","title":".zinit-load-snippet"},{"location":"zplugin.zsh/#zinit-pack-ice","text":"Remembers all ice-mods, assigns them to concrete plugin. Ice spec is in general forgotten for second-next command (that's why it's called \"ice\" - it melts), however they glue to the object (plugin or snippet) mentioned in the next command \u2013 for later use with e.g. `zinit update ...' Has 3 line(s). Doesn't call other functions. Called by: .zinit-load-snippet .zinit-load zinit-autoload.zsh/.zinit-compute-ice","title":".zinit-pack-ice"},{"location":"zplugin.zsh/#zinit-prepare-home","text":"Creates all directories needed by Zinit, first checks if they already exist. Has 28 line(s). Doesn't call other functions. Called by: Script-Body Environment variables used: ZPFX","title":".zinit-prepare-home"},{"location":"zplugin.zsh/#zinit-register-plugin","text":"Adds the plugin to ZINIT_REGISTERED_PLUGINS array and to the zsh_loaded_plugins array (managed according to the plugin standard: http://zdharma.org/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html) Has 23 line(s). Doesn't call other functions. Called by: .zinit-load","title":".zinit-register-plugin"},{"location":"zplugin.zsh/#zplg-register-z-plugin","text":"Registers the z-plugin inside Zinit \u2013 i.e. an Zinit extension Has 4 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"@zplg-register-z-plugin"},{"location":"zplugin.zsh/#zinit-reload-and-run","text":"Marks given function ($3) for autoloading, and executes it triggering the load. $1 is the fpath dedicated to the function, $2 are autoload options. This function replaces \"autoload -X\", because using that on older Zsh versions causes problems with traps. So basically one creates function stub that calls :zinit-reload-and-run() instead of \"autoload -X\". $1 - FPATH dedicated to function $2 - autoload options $3 - function name (one that needs autoloading) Author: Bart Schaefer Has 7 line(s). Doesn't call other functions. Uses feature(s): autoload , unfunction Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-reload-and-run"},{"location":"zplugin.zsh/#zinit-run-task","text":"A backend, worker function of .zinit-scheduler. It obtains the tasks index and a few of its properties (like the type: plugin, snippet, service plugin, service snippet) and executes it first checking for additional conditions (like non-numeric wait'' ice). $1 - the pass number, either 1st or 2nd pass $2 - the time assigned to the task $3 - type: plugin, snippet, service plugin, service snippet $4 - task's index in the ZINIT[WAIT_ICE_...] fields $5 - mode: load or light $6 - the plugin-spec or snippet URL or alias name (from id-as'') Has 41 line(s). Calls functions: .zinit-run-task |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet `-- zinit-autoload.zsh/.zinit-unload Uses feature(s): eval , source , zle , zpty Called by: @zinit-scheduler","title":".zinit-run-task"},{"location":"zplugin.zsh/#zinit-scheduler","text":"Searches for timeout tasks, executes them. There's an array of tasks waiting for execution, this scheduler manages them, detects which ones should be run at current moment, decides to remove (or not) them from the array after execution. $1 - if \"following\", then it is non-first (second and more) invocation of the scheduler; this results in chain of `sched' invocations that results in repetitive @zinit-scheduler activity if \"burst\", then all tasks are marked timeout and executed one by one; this is handy if e.g. a docker image starts up and needs to install all turbo-mode plugins without any hesitation (delay), i.e. \"burst\" allows to run package installations from script, not from prompt Has 62 line(s). Is a precmd hook . Calls functions: @zinit-scheduler |-- add-zsh-hook `-- .zinit-run-task |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet `-- zinit-autoload.zsh/.zinit-unload Uses feature(s): sched , zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"@zinit-scheduler"},{"location":"zplugin.zsh/#zinit-service","text":"Handles given service, i.e. obtains lock, runs it, or waits if no lock $1 - type \"p\" or \"s\" (plugin or snippet) $2 - mode - for plugin (light or load) $3 - id - URL or plugin ID or alias name (from id-as'') Has 30 line(s). Calls functions: .zinit-service |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir `-- .zinit-load-snippet |-- .zinit-deploy-message |-- .zinit-pack-ice |-- .zinit-wrap-track-functions `-- zinit-install.zsh/.zinit-download-snippet Uses feature(s): kill , read Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":".zinit-service"},{"location":"zplugin.zsh/#zinit-shadow-alias","text":"Function defined to hijack plugin's calls to `alias' builtin. The hijacking is to gather report data (which is used in unload). Has 34 line(s). Calls functions: :zinit-shadow-alias `-- .zinit-add-report Uses feature(s): alias , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-alias"},{"location":"zplugin.zsh/#zinit-shadow-autoload","text":"Function defined to hijack plugin's calls to `autoload' builtin. The hijacking is not only to gather report data, but also to run custom `autoload' function, that doesn't need FPATH. Has 48 line(s). Calls functions: :zinit-shadow-autoload `-- .zinit-add-report Uses feature(s): autoload , eval , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-autoload"},{"location":"zplugin.zsh/#zinit-shadow-bindkey","text":"Function defined to hijack plugin's calls to `bindkey' builtin. The hijacking is to gather report data (which is used in unload). Has 104 line(s). Calls functions: :zinit-shadow-bindkey |-- is-at-least `-- .zinit-add-report Uses feature(s): bindkey , zparseopts Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-bindkey"},{"location":"zplugin.zsh/#zinit-shadow-compdef","text":"Function defined to hijack plugin's calls to `compdef' function. The hijacking is not only for reporting, but also to save compdef calls so that `compinit' can be called after loading plugins. Has 4 line(s). Calls functions: :zinit-shadow-compdef `-- .zinit-add-report Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-compdef"},{"location":"zplugin.zsh/#zinit-shadow-off","text":"Turn off shadowing completely for a given mode (\"load\", \"light\", \"light-b\" (i.e. the `trackbinds' mode) or \"compdef\"). Has 18 line(s). Doesn't call other functions. Uses feature(s): unfunction Called by: .zinit-debug-stop .zinit-load-plugin","title":".zinit-shadow-off"},{"location":"zplugin.zsh/#zinit-shadow-on","text":"Turn on shadowing of builtins and functions according to passed mode (\"load\", \"light\", \"light-b\" or \"compdef\"). The shadowing is to gather report data, and to hijack `autoload', `bindkey' and `compdef' calls. Has 25 line(s). Doesn't call other functions. Called by: .zinit-debug-start .zinit-load-plugin","title":".zinit-shadow-on"},{"location":"zplugin.zsh/#zinit-shadow-zle","text":"Function defined to hijack plugin's calls to `zle' builtin. The hijacking is to gather report data (which is used in unload). Has 38 line(s). Calls functions: :zinit-shadow-zle `-- .zinit-add-report Uses feature(s): zle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-zle"},{"location":"zplugin.zsh/#zinit-shadow-zstyle","text":"Function defined to hijack plugin's calls to `zstyle' builtin. The hijacking is to gather report data (which is used in unload). Has 21 line(s). Calls functions: :zinit-shadow-zstyle `-- .zinit-add-report Uses feature(s): zparseopts , zstyle Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":":zinit-shadow-zstyle"},{"location":"zplugin.zsh/#zinit-submit-turbo","text":"If `zinit load`, `zinit light` or `zinit snippet` will be preceded with `wait', `load', `unload' or `on-update-of`/`subscribe' ice-mods then the plugin or snipped is to be loaded in turbo-mode, and this function adds it to internal data structures, so that @zinit-scheduler can run (load, unload) this as a task. Has 14 line(s). Doesn't call other functions. Called by: zinit","title":".zinit-submit-turbo"},{"location":"zplugin.zsh/#zinit-unregister-plugin","text":"Removes the plugin from ZINIT_REGISTERED_PLUGINS array and from the zsh_loaded_plugins array (managed according to the plugin standard) Has 5 line(s). Calls functions: .zinit-unregister-plugin `-- .zinit-any-to-user-plugin Called by: zinit-autoload.zsh/.zinit-unload","title":".zinit-unregister-plugin"},{"location":"zplugin.zsh/#zinit-wrap-track-functions","text":"Has 19 line(s). Doesn't call other functions. Uses feature(s): eval Called by: .zinit-load-plugin .zinit-load-snippet","title":".zinit-wrap-track-functions"},{"location":"zplugin.zsh/#zinit","text":"Main function directly exposed to user, obtains subcommand and its arguments, has completion. Has 290 line(s). Calls functions: zinit |-- compinit |-- .zinit-clear-debug-report | `-- zinit-autoload.zsh/.zinit-clear-report-for |-- .zinit-compdef-clear |-- .zinit-compdef-replay |-- .zinit-debug-start | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | `-- .zinit-shadow-on |-- .zinit-debug-stop | |-- .zinit-diff | | |-- .zinit-diff-env | | |-- .zinit-diff-functions | | |-- .zinit-diff-options | | `-- .zinit-diff-parameter | `-- .zinit-shadow-off |-- .zinit-debug-unload | `-- zinit-autoload.zsh/.zinit-unload |-- .zinit-ice |-- .zinit-load | |-- .zinit-any-to-user-plugin | |-- .zinit-deploy-message | |-- .zinit-load-plugin | | |-- .zinit-add-report | | |-- .zinit-diff | | | |-- .zinit-diff-env | | | |-- .zinit-diff-functions | | | |-- .zinit-diff-options | | | `-- .zinit-diff-parameter | | |-- .zinit-diff-env | | |-- .zinit-find-other-matches | | |-- .zinit-shadow-off | | |-- .zinit-shadow-on | | `-- .zinit-wrap-track-functions | |-- .zinit-pack-ice | |-- .zinit-register-plugin | `-- zinit-install.zsh/.zinit-setup-plugin-dir |-- .zinit-load-snippet | |-- .zinit-deploy-message | |-- .zinit-pack-ice | |-- .zinit-wrap-track-functions | `-- zinit-install.zsh/.zinit-download-snippet |-- .zinit-submit-turbo |-- zinit-autoload.zsh/.zinit-cdisable |-- zinit-autoload.zsh/.zinit-cenable |-- zinit-autoload.zsh/.zinit-clear-completions |-- zinit-autoload.zsh/.zinit-compiled |-- zinit-autoload.zsh/.zinit-compile-uncompile-all |-- zinit-autoload.zsh/.zinit-compinit |-- zinit-autoload.zsh/.zinit-help |-- zinit-autoload.zsh/.zinit-list-bindkeys |-- zinit-autoload.zsh/.zinit-list-compdef-replay |-- zinit-autoload.zsh/.zinit-ls |-- zinit-autoload.zsh/.zinit-module |-- zinit-autoload.zsh/.zinit-recently |-- zinit-autoload.zsh/.zinit-search-completions |-- zinit-autoload.zsh/.zinit-self-update |-- zinit-autoload.zsh/.zinit-show-all-reports |-- zinit-autoload.zsh/.zinit-show-completions |-- zinit-autoload.zsh/.zinit-show-debug-report |-- zinit-autoload.zsh/.zinit-show-registered-plugins |-- zinit-autoload.zsh/.zinit-show-report |-- zinit-autoload.zsh/.zinit-show-times |-- zinit-autoload.zsh/.zinit-show-zstatus |-- zinit-autoload.zsh/.zinit-uncompile-plugin |-- zinit-autoload.zsh/.zinit-uninstall-completions |-- zinit-autoload.zsh/.zinit-unload |-- zinit-autoload.zsh/.zinit-update-or-status |-- zinit-autoload.zsh/.zinit-update-or-status-all |-- zinit-install.zsh/.zinit-compile-plugin |-- zinit-install.zsh/.zinit-forget-completion `-- zinit-install.zsh/.zinit-install-completions Uses feature(s): autoload , eval , source Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"zinit"},{"location":"zplugin.zsh/#-zinit_scheduler_add_sh","text":"Copies task into ZINIT_RUN array, called when a task timeouts. A small function ran from pattern in /-substitution as a math function. Has 7 line(s). Doesn't call other functions. Not called by script or any function (may be e.g. a hook, a Zle widget, etc.).","title":"-zinit_scheduler_add_sh"},{"location":"zplugin.zsh/#add-zsh-hook","text":"Has 93 line(s). Doesn't call other functions. Uses feature(s): autoload , getopts Called by: Script-Body @zinit-scheduler","title":"add-zsh-hook"},{"location":"zplugin.zsh/#compinit","text":"Has 549 line(s). Doesn't call other functions. Uses feature(s): autoload , bindkey , eval , read , unfunction , zle , zstyle Called by: zpcompinit zinit","title":"compinit"},{"location":"zplugin.zsh/#is-at-least","text":"Has 56 line(s). Doesn't call other functions. Called by: Script-Body :zinit-shadow-bindkey","title":"is-at-least"},{"location":"zsh-native-scripting-handbook/","text":"Zsh Native Scripting Handbook # This document has been created after 4 years of creating software for Zshell and receiving help from IRC channel #zsh. Avoiding forks was the main guideline when creating the projects and this lead to multiple discoveries of Zsh constructs that are fast, robust and do not depend on external tools. Such code is more like Ruby or Perl code, less like top-down shell scripts. Information # @ is about keeping array form # How to access all array elements in a shell? The standard answer: use @ subscript , i.e. ${array[@]} . However, this is the Bash & Ksh way (and with the option KSH_ARRAYS , Zsh also works this way, i.e. needs @ to access whole array). Zshell is different : it is $array that refers to all elements anyway. There is no need of @ subscript. So what use has @ in the Zsh-world? It is: \" keep array form \" or \" do not join \". When is it activated? When user quotes the array, i.e. invokes \"$array\" , he induces joining of all array elements (into a single string). @ is to have elements still quoted (so empty elements are preserved), but not joined. Two forms are available, \"$array[@]\" and \"${(@)array}\" . First form has additional effect \u2013 when option KSH_ARRAYS is set, it indeed induces referencing to whole array instead of first element only. It should then use braces, i.e. ${array[@]} , \"${array[@]}\" ( KSH_ARRAYS requirement). In practice, if you'll use @ as a subscript \u2013 [@] , not as a flag \u2013 ${(@)...} , then you'll make the code KSH_ARRAYS -compatible. extended_glob # Glob-flags #b and #m require setopt extended_glob . Patterns utilizing ~ and ^ also require it. Extended-glob is one of the main features of Zsh. Constructs # Reading a file # declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) This preserves empty lines because of double-quoting (the outside one). @ -flag is used to obtain array instead of scalar. If you don't want empty lines preserved, you can also skip @ -splitting, as it is explained in Information section: declare -a lines; lines=( ${(f)\"$(<path/file)\"} ) Note: $(<...) construct strips trailing empty lines. Reading from stdin # This topic is governed by the same principles a the previous paragraph ( Reading a file ), with the single difference that instead of the substitution \"$(<file-path)\" the substitution that should be used is \"$(command arg1 ...)\" , i.e.: declare -a lines; lines=( ${(f)\"$(command arg1 ...)\"} ) This will read the command's output into the array lines . The version that does @ splitting and retains any empty lines is: declare -a lines; lines=( \"${(f@)$(command arg1 ...)}\" ) Note that instead of four double-quotes \" , an idiom that is justified (simply suggested) by the Zsh documentation (and was used in the previous paragraph, in the snippet ... \"${(@f)\"$(<path/file)\"}\" ... ), only two double-quotes are being used. I've investigated this form with the main Zsh developers on the zsh-workers@zsh.org mailing list, and it was clearly stated that single, outside quoting of ${(f@)...} substitution works as if it was also separately applied to $(command ...) (or to $(<file-path) ) inner substitution, so the second double-quoting isn't actually needed. Skipping grep # declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) declare -a grepped; grepped=( ${(M)lines:#*query*} ) To have grep -v effect, skip M -flag. To grep case insensitively, use #i glob flag ( ...:#(#i)*query*} ). As it can be seen, ${...:#...} substitution is a filtering of array, which by default filters-out elements ( (M) flag induces the opposite behavior). When used with string, not an array, it behaves similarily: returns empty string when {input_string_var:#pattern} matches whole input string. Side-note: (M) flag can be used also with ${(M)var#pattern} and other substitutions, to retain what's matched by the pattern instead of removing that. Multi-line matching like with grep # Suppose you have a Subversion repository and want to check if it contains files being not under version control. You could do this in Bash style like follows: local svn_status=\"$(svn status)\" if [[ -n \"$(echo \"$svn_status\" | grep \\^\\?)\" ]]; then echo found fi That are 3 forks: for svn status , for echo and for grep . This can be solved by :# substitution and (M) flag described above in this section (just check if the number of matched lines is greater than 0). However, there's a more direct approach: local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = *((#s)|$nl)\\?* ]]; then echo found fi This requires extendedglob . The (#s) means: \"start of the string\". So ((#s)|$nl) means \"start of the string OR preceded by a new-line\". If the extendedglob option cannot be used for some reason, this can be achieved also without it, but essentially it means that alternative (i.e. | ) of two versions of the pattern will have to be matched: setopt localoptions noextendedglob local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = (\\?*|*$nl\\?*) ]]; then echo found fi In general, multi-line matching falls into the following idiom ( extendedglob version): local needle=\"?\" required_preceding='[[:space:]]#' [[ \"$(svn status)\" = *((#s)|$nl)${~required_preceding}${needle}* ]] && echo found It does a single fork (calls svn status ). The ${~variable} means (the ~ in it): \"the variable is holding a pattern, interpret it\". All in all, instead of regular expressions we were using patterns (globs) (see this section ). Pattern matching in AND-fashion # [[ \"abc xyz efg\" = *abc*~^*efg* ]] && print Match found The ~ is a negation -- match *abc* but not ... . Then, ^ is also a negation. The effect is: *abc* but not those that don't have *efg* which equals to: *abc* but those that have also *efg* . This is a regular pattern and it can be used with :# above to search arrays, or with R -subscript flag to search hashes ( ${hsh[(R)*pattern*]} ), etc. Inventor of those patterns is Mikael Magnusson. Skipping tr # declare -A map; map=( a 1 b 2 ); text=( \"ab\" \"ba\" ) text=( ${text[@]//(#m)?/${map[$MATCH]}} ) print $text \u25b6 12 21 #m flag enables the $MATCH parameter. At each // substitution, $map is queried for character-replacement. You can substitute a text variable too, just skip [@] and parentheses in assignment. Ternary expressions with +,-,:+,:- substitutions # HELP=\"yes\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help enabled HELP=\"\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help disabled Ternary expression is known from C language but exists also in Zsh, but directly only in math context, i.e. (( a = a > 0 ? b : c )) . Flexibility of Zsh allows such expressions also in normal context. Above is an example. :+ is \"if not empty, substitute \u2026\" :- is \"if empty, substitute \u2026\". You can save great number of lines of code with those substitutions, it's normally at least 4-lines if condition or lenghty && / || use. Ternary expressions with :# substitution # var=abc; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 is abc var=abcd; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 not abc An one-line \"if var = x, then \u2026, else \u2026\". Again, can spare a great amount of boring code that makes 10-line function a 20-line one. Using built-in regular expressions engine # [[ \"aabbb\" = (#b)(a##)*(b(#c2,2)) ]] && print ${match[1]}-${match[2]} \u25b6 aa-bb ## is: \"1 or more\". (#c2,2) is: \"exactly 2\". A few other constructs: # is \"0 or more\", ? is \"any character\", (a|b|) is \"a or b or empty match\". #b enables the $match parameters. There's also #m but it has one parameter $MATCH for whole matched text, not for any parenthesis. Zsh patterns are basically a custom regular expressions engine. They are slightly faster than zsh/regex module (used for =~ operator) and don't have that dependency (regex module can be not present, e.g. in default static build of Zsh). Also, they can be used in substitutions, for example in // substitution. Skipping uniq # declare -aU array; array=( a a b ); print $array \u25b6 a b declare -a array; array=( a a b ); print ${(u)array} \u25b6 a b Enable -U flag for array so that it guards elements to be unique, or use u -flag to uniquify elements of any array. Skipping awk # declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#b)([^,]##,)(#c3,3)([^,]##)*/${match[2]}}\" \u25b6 1 2 The pattern specifies 3 blocks of [^,]##, so 3 \"not-comma multiple times, then comma\", then single block of \"not-comma multiple times\" in second parentheses -- and then replaces this with second parentheses. Result is 4 th column extracted from multiple lines of text, something awk is often used for. Other method is use of s -flag. For single line of text: text=\"a,b,c,1,e\"; print ${${(s:,:)text}[4]} \u25b6 1 Thanks to in-substitution code-execution capabilities it's possible to use s -flag to apply it to multiple lines: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 There is a problem with the (s::) flag that can be solved if Zsh is version 5.4 or higher: if there will be single input column, e.g. list=( \"column1\" \"a,b\") instead of two or more columns (i.e. list=( \"column1,column2\" \"a,b\" ) ), then (s::) will return string instead of 1-element array . So the index [4] in above snippet will index a string, and show its 4-th letter. Starting with Zsh 5.4, thanks to a patch by Bart Schaefer ( 40640: the (A) parameter flag forces array result even if... ), it is possible to force array -kind of result even for single column, by adding (A) flag, i.e.: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" \"column1\" ); print \"${list[@]/(#m)*/${${(As:,:)MATCH}[4]}}\" \u25b6 1 2 print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 u Side-note: (A) flag is often used together with ::= assignment-substitution and (P) flag, to assign arrays and hashes by-name. Searching arrays # declare -a array; array=( a b \" c1\" d ); print ${array[(r)[[:space:]][[:alpha:]]*]} \u25b6 c1 [[:space:]] contains unicode spaces. This is often used in conditional expression like [[ -z ${array[(r)...]} ]] . Note that Skipping grep that uses :# substitution can also be used to search arrays. Code execution in // substitution # append() { gathered+=( $array[$1] ); } functions -M append 1 1 append declare -a array; array=( \"Value 1\" \"Other data\" \"Value 2\" ) declare -a gathered; integer idx=0 : ${array[@]/(#b)(Value ([[:digit:]]##)|*)/$(( ${#match[2]} > 0 ? append(++idx) : ++idx ))} print $gathered \u25b6 Value 1 Value 2 Use of #b glob flag enables math-code execution (and not only) in / and // substitutions. Implementation is very fast. Serializing data # declare -A hsh deserialized; hsh=( key value ) serialized=\"${(j: :)${(qkv@)hsh}}\" deserialized=( \"${(Q@)${(z@)serialized}}\" ) print ${(kv)deserialized} \u25b6 key value j -flag means join -- by spaces, in this case. Flags kv mean: keys and values, interleaving. Important q -flag means: quote. So what is obtained is each key and value quoted, and put into string separated by spaces. z -flag means: split as if Zsh parser would split. So quoting (with backslashes, double quoting and other) is recognized. Obtained is array ( \"key\" \"value\") which is then dequoted with Q -flag. This yields original data, assigned to hash deserialized . Use this to e.g. implement array of hashes. Note: to be compatible with setopt ksharrays , use [@] instead of (@) , e.g.: ...( \"${(Q)${(z)serialized[@]}[@]}\" ) Tip: serializing with Bash # array=( key1 key2 ) printf -v serialized \"%q \" \"${array[@]}\" eval \"deserialized=($serialized)\" This method works also with Zsh. The drawback is use of eval , however it's impossible that any problem will occurr unless someone compromises variable's value, but as always, eval should be avoided if possible. Real world examples # Testing for Git subcommand # Following code checks if there is a git subcommand $mysub : if git help -a | grep \"^ [a-z]\" | tr ' ' '\\n' | grep -x $mysub > /dev/null > /dev/null; then That are 4 forks. The code can be replaced according to this guide: local -a lines_list lines_list=( ${(f)\"$(git help -a)\"} ) lines_list=( ${(M)${(s: :)${(M)lines_list:# [a-z]*}}:#$mysub} ) if (( ${#lines_list} > 0 )); then The result is just 1 fork. Counting unquoted-only apostrophes # A project was needing this to do some Zle line-continuation tricks (when you put a backslash-\\ at the end of the line and press enter \u2013 it is the line-continuation that occurs at that moment). The required functionality is: in given string, count the number of apostrophes, but only the unquoted ones . This means that only apostrophes with null or an even number of preceding backslashes should be accepted into the count: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" integer count=0 : ${buf//(#b)((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)/$(( count += ${#match[3]} ))} echo $count \u25b6 3 The answer (i.e. the output) to the above presentation and example is: 3 (there are 3 unquoted apostrophes in total in the string kept in the variable $buf ). Below follows a variation of above snippet that doesn't use math-code execution: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" buf=\"${(S)buf//(#b)*((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)*/${match[3]}}\"; buf=${buf%%[^\\']##} integer count=${#buf} echo $count \u25b6 3 This is possible thanks to (S) flag \u2013 non-greedy matching, ([\\\\][\\\\])# trick \u2013 it matches only unquoted following (\\'\\'##) characters (which are the apostrophes) and a general strategy to replace anything-apostrope(s) (unquoted ones) with the-apostrope(s) (and then count them with ${#buf} ). Tips and Tricks # Parsing INI file # With Zshell's extended_glob parsing an ini file is an easy task. It will not result in a nested-arrays data structure (Zsh doesn't support nested hashes), but the hash keys like $DB_CONF[db1_<connection>_host] are actually really intuitive. The code should be placed in file named read-ini-file , in $fpath , and autoload read-ini-file should be invoked. # Copyright (c) 2018 Sebastian Gniazdowski # # $1 - path to the ini file to parse # $2 - name of output hash # $3 - prefix for keys in the hash # # Writes to given hash under keys built in following way: ${3}<section>_field. # Values are values from ini file. Example invocation: # # read-ini-file ./database1-setup.ini DB_CONF db1_ # read-ini-file ./database2-setup.ini DB_CONF db2_ # setopt localoptions extendedglob local __ini_file=\"$1\" __out_hash=\"$2\" __key_prefix=\"$3\" local IFS='' __line __cur_section=\"void\" __access_string local -a match mbegin mend [[ ! -r \"$__ini_file\" ]] && { builtin print -r \"read-ini-file: an ini file is unreadable ($__ini_file)\"; return 1; } while read -r -t 1 __line; do if [[ \"$__line\" = [[:blank:]]#\\;* ]]; then continue # Match \"[Section]\" line elif [[ \"$__line\" = (#b)[[:blank:]]#\\[([^\\]]##)\\][[:blank:]]# ]]; then __cur_section=\"${match[1]}\" # Match \"string = string\" line elif [[ \"$__line\" = (#b)[[:blank:]]#([^[:blank:]=]##)[[:blank:]]#[=][[:blank:]]#(*) ]]; then match[2]=\"${match[2]%\"${match[2]##*[! $'\\t']}\"}\" # severe trick - remove trailing whitespace __access_string=\"${__out_hash}[${__key_prefix}<$__cur_section>_${match[1]}]\" : \"${(P)__access_string::=${match[2]}}\" fi done < \"$__ini_file\" return 0","title":"Zsh Native Scripting Handbook"},{"location":"zsh-native-scripting-handbook/#zsh_native_scripting_handbook","text":"This document has been created after 4 years of creating software for Zshell and receiving help from IRC channel #zsh. Avoiding forks was the main guideline when creating the projects and this lead to multiple discoveries of Zsh constructs that are fast, robust and do not depend on external tools. Such code is more like Ruby or Perl code, less like top-down shell scripts.","title":"Zsh Native Scripting Handbook"},{"location":"zsh-native-scripting-handbook/#information","text":"","title":"Information"},{"location":"zsh-native-scripting-handbook/#is_about_keeping_array_form","text":"How to access all array elements in a shell? The standard answer: use @ subscript , i.e. ${array[@]} . However, this is the Bash & Ksh way (and with the option KSH_ARRAYS , Zsh also works this way, i.e. needs @ to access whole array). Zshell is different : it is $array that refers to all elements anyway. There is no need of @ subscript. So what use has @ in the Zsh-world? It is: \" keep array form \" or \" do not join \". When is it activated? When user quotes the array, i.e. invokes \"$array\" , he induces joining of all array elements (into a single string). @ is to have elements still quoted (so empty elements are preserved), but not joined. Two forms are available, \"$array[@]\" and \"${(@)array}\" . First form has additional effect \u2013 when option KSH_ARRAYS is set, it indeed induces referencing to whole array instead of first element only. It should then use braces, i.e. ${array[@]} , \"${array[@]}\" ( KSH_ARRAYS requirement). In practice, if you'll use @ as a subscript \u2013 [@] , not as a flag \u2013 ${(@)...} , then you'll make the code KSH_ARRAYS -compatible.","title":"@ is about keeping array form"},{"location":"zsh-native-scripting-handbook/#extended_glob","text":"Glob-flags #b and #m require setopt extended_glob . Patterns utilizing ~ and ^ also require it. Extended-glob is one of the main features of Zsh.","title":"extended_glob"},{"location":"zsh-native-scripting-handbook/#constructs","text":"","title":"Constructs"},{"location":"zsh-native-scripting-handbook/#reading_a_file","text":"declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) This preserves empty lines because of double-quoting (the outside one). @ -flag is used to obtain array instead of scalar. If you don't want empty lines preserved, you can also skip @ -splitting, as it is explained in Information section: declare -a lines; lines=( ${(f)\"$(<path/file)\"} ) Note: $(<...) construct strips trailing empty lines.","title":"Reading a file"},{"location":"zsh-native-scripting-handbook/#reading_from_stdin","text":"This topic is governed by the same principles a the previous paragraph ( Reading a file ), with the single difference that instead of the substitution \"$(<file-path)\" the substitution that should be used is \"$(command arg1 ...)\" , i.e.: declare -a lines; lines=( ${(f)\"$(command arg1 ...)\"} ) This will read the command's output into the array lines . The version that does @ splitting and retains any empty lines is: declare -a lines; lines=( \"${(f@)$(command arg1 ...)}\" ) Note that instead of four double-quotes \" , an idiom that is justified (simply suggested) by the Zsh documentation (and was used in the previous paragraph, in the snippet ... \"${(@f)\"$(<path/file)\"}\" ... ), only two double-quotes are being used. I've investigated this form with the main Zsh developers on the zsh-workers@zsh.org mailing list, and it was clearly stated that single, outside quoting of ${(f@)...} substitution works as if it was also separately applied to $(command ...) (or to $(<file-path) ) inner substitution, so the second double-quoting isn't actually needed.","title":"Reading from stdin"},{"location":"zsh-native-scripting-handbook/#skipping_grep","text":"declare -a lines; lines=( \"${(@f)\"$(<path/file)\"}\" ) declare -a grepped; grepped=( ${(M)lines:#*query*} ) To have grep -v effect, skip M -flag. To grep case insensitively, use #i glob flag ( ...:#(#i)*query*} ). As it can be seen, ${...:#...} substitution is a filtering of array, which by default filters-out elements ( (M) flag induces the opposite behavior). When used with string, not an array, it behaves similarily: returns empty string when {input_string_var:#pattern} matches whole input string. Side-note: (M) flag can be used also with ${(M)var#pattern} and other substitutions, to retain what's matched by the pattern instead of removing that.","title":"Skipping grep"},{"location":"zsh-native-scripting-handbook/#multi-line_matching_like_with_grep","text":"Suppose you have a Subversion repository and want to check if it contains files being not under version control. You could do this in Bash style like follows: local svn_status=\"$(svn status)\" if [[ -n \"$(echo \"$svn_status\" | grep \\^\\?)\" ]]; then echo found fi That are 3 forks: for svn status , for echo and for grep . This can be solved by :# substitution and (M) flag described above in this section (just check if the number of matched lines is greater than 0). However, there's a more direct approach: local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = *((#s)|$nl)\\?* ]]; then echo found fi This requires extendedglob . The (#s) means: \"start of the string\". So ((#s)|$nl) means \"start of the string OR preceded by a new-line\". If the extendedglob option cannot be used for some reason, this can be achieved also without it, but essentially it means that alternative (i.e. | ) of two versions of the pattern will have to be matched: setopt localoptions noextendedglob local svn_status=\"$(svn status)\" nl=$'\\n' if [[ \"$svn_status\" = (\\?*|*$nl\\?*) ]]; then echo found fi In general, multi-line matching falls into the following idiom ( extendedglob version): local needle=\"?\" required_preceding='[[:space:]]#' [[ \"$(svn status)\" = *((#s)|$nl)${~required_preceding}${needle}* ]] && echo found It does a single fork (calls svn status ). The ${~variable} means (the ~ in it): \"the variable is holding a pattern, interpret it\". All in all, instead of regular expressions we were using patterns (globs) (see this section ).","title":"Multi-line matching like with grep"},{"location":"zsh-native-scripting-handbook/#pattern_matching_in_and-fashion","text":"[[ \"abc xyz efg\" = *abc*~^*efg* ]] && print Match found The ~ is a negation -- match *abc* but not ... . Then, ^ is also a negation. The effect is: *abc* but not those that don't have *efg* which equals to: *abc* but those that have also *efg* . This is a regular pattern and it can be used with :# above to search arrays, or with R -subscript flag to search hashes ( ${hsh[(R)*pattern*]} ), etc. Inventor of those patterns is Mikael Magnusson.","title":"Pattern matching in AND-fashion"},{"location":"zsh-native-scripting-handbook/#skipping_tr","text":"declare -A map; map=( a 1 b 2 ); text=( \"ab\" \"ba\" ) text=( ${text[@]//(#m)?/${map[$MATCH]}} ) print $text \u25b6 12 21 #m flag enables the $MATCH parameter. At each // substitution, $map is queried for character-replacement. You can substitute a text variable too, just skip [@] and parentheses in assignment.","title":"Skipping tr"},{"location":"zsh-native-scripting-handbook/#ternary_expressions_with_--_substitutions","text":"HELP=\"yes\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help enabled HELP=\"\"; print ${${HELP:+help enabled}:-help disabled} \u25b6 help disabled Ternary expression is known from C language but exists also in Zsh, but directly only in math context, i.e. (( a = a > 0 ? b : c )) . Flexibility of Zsh allows such expressions also in normal context. Above is an example. :+ is \"if not empty, substitute \u2026\" :- is \"if empty, substitute \u2026\". You can save great number of lines of code with those substitutions, it's normally at least 4-lines if condition or lenghty && / || use.","title":"Ternary expressions with +,-,:+,:- substitutions"},{"location":"zsh-native-scripting-handbook/#ternary_expressions_with_substitution","text":"var=abc; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 is abc var=abcd; print ${${${(M)var:#abc}:+is abc}:-not abc} \u25b6 not abc An one-line \"if var = x, then \u2026, else \u2026\". Again, can spare a great amount of boring code that makes 10-line function a 20-line one.","title":"Ternary expressions with :# substitution"},{"location":"zsh-native-scripting-handbook/#using_built-in_regular_expressions_engine","text":"[[ \"aabbb\" = (#b)(a##)*(b(#c2,2)) ]] && print ${match[1]}-${match[2]} \u25b6 aa-bb ## is: \"1 or more\". (#c2,2) is: \"exactly 2\". A few other constructs: # is \"0 or more\", ? is \"any character\", (a|b|) is \"a or b or empty match\". #b enables the $match parameters. There's also #m but it has one parameter $MATCH for whole matched text, not for any parenthesis. Zsh patterns are basically a custom regular expressions engine. They are slightly faster than zsh/regex module (used for =~ operator) and don't have that dependency (regex module can be not present, e.g. in default static build of Zsh). Also, they can be used in substitutions, for example in // substitution.","title":"Using built-in regular expressions engine"},{"location":"zsh-native-scripting-handbook/#skipping_uniq","text":"declare -aU array; array=( a a b ); print $array \u25b6 a b declare -a array; array=( a a b ); print ${(u)array} \u25b6 a b Enable -U flag for array so that it guards elements to be unique, or use u -flag to uniquify elements of any array.","title":"Skipping uniq"},{"location":"zsh-native-scripting-handbook/#skipping_awk","text":"declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#b)([^,]##,)(#c3,3)([^,]##)*/${match[2]}}\" \u25b6 1 2 The pattern specifies 3 blocks of [^,]##, so 3 \"not-comma multiple times, then comma\", then single block of \"not-comma multiple times\" in second parentheses -- and then replaces this with second parentheses. Result is 4 th column extracted from multiple lines of text, something awk is often used for. Other method is use of s -flag. For single line of text: text=\"a,b,c,1,e\"; print ${${(s:,:)text}[4]} \u25b6 1 Thanks to in-substitution code-execution capabilities it's possible to use s -flag to apply it to multiple lines: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" ); print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 There is a problem with the (s::) flag that can be solved if Zsh is version 5.4 or higher: if there will be single input column, e.g. list=( \"column1\" \"a,b\") instead of two or more columns (i.e. list=( \"column1,column2\" \"a,b\" ) ), then (s::) will return string instead of 1-element array . So the index [4] in above snippet will index a string, and show its 4-th letter. Starting with Zsh 5.4, thanks to a patch by Bart Schaefer ( 40640: the (A) parameter flag forces array result even if... ), it is possible to force array -kind of result even for single column, by adding (A) flag, i.e.: declare -a list; list=( \"a,b,c,1,e\" \"p,q,r,2,t\" \"column1\" ); print \"${list[@]/(#m)*/${${(As:,:)MATCH}[4]}}\" \u25b6 1 2 print \"${list[@]/(#m)*/${${(s:,:)MATCH}[4]}}\" \u25b6 1 2 u Side-note: (A) flag is often used together with ::= assignment-substitution and (P) flag, to assign arrays and hashes by-name.","title":"Skipping awk"},{"location":"zsh-native-scripting-handbook/#searching_arrays","text":"declare -a array; array=( a b \" c1\" d ); print ${array[(r)[[:space:]][[:alpha:]]*]} \u25b6 c1 [[:space:]] contains unicode spaces. This is often used in conditional expression like [[ -z ${array[(r)...]} ]] . Note that Skipping grep that uses :# substitution can also be used to search arrays.","title":"Searching arrays"},{"location":"zsh-native-scripting-handbook/#code_execution_in_substitution","text":"append() { gathered+=( $array[$1] ); } functions -M append 1 1 append declare -a array; array=( \"Value 1\" \"Other data\" \"Value 2\" ) declare -a gathered; integer idx=0 : ${array[@]/(#b)(Value ([[:digit:]]##)|*)/$(( ${#match[2]} > 0 ? append(++idx) : ++idx ))} print $gathered \u25b6 Value 1 Value 2 Use of #b glob flag enables math-code execution (and not only) in / and // substitutions. Implementation is very fast.","title":"Code execution in // substitution"},{"location":"zsh-native-scripting-handbook/#serializing_data","text":"declare -A hsh deserialized; hsh=( key value ) serialized=\"${(j: :)${(qkv@)hsh}}\" deserialized=( \"${(Q@)${(z@)serialized}}\" ) print ${(kv)deserialized} \u25b6 key value j -flag means join -- by spaces, in this case. Flags kv mean: keys and values, interleaving. Important q -flag means: quote. So what is obtained is each key and value quoted, and put into string separated by spaces. z -flag means: split as if Zsh parser would split. So quoting (with backslashes, double quoting and other) is recognized. Obtained is array ( \"key\" \"value\") which is then dequoted with Q -flag. This yields original data, assigned to hash deserialized . Use this to e.g. implement array of hashes. Note: to be compatible with setopt ksharrays , use [@] instead of (@) , e.g.: ...( \"${(Q)${(z)serialized[@]}[@]}\" )","title":"Serializing data"},{"location":"zsh-native-scripting-handbook/#tip_serializing_with_bash","text":"array=( key1 key2 ) printf -v serialized \"%q \" \"${array[@]}\" eval \"deserialized=($serialized)\" This method works also with Zsh. The drawback is use of eval , however it's impossible that any problem will occurr unless someone compromises variable's value, but as always, eval should be avoided if possible.","title":"Tip: serializing with Bash"},{"location":"zsh-native-scripting-handbook/#real_world_examples","text":"","title":"Real world examples"},{"location":"zsh-native-scripting-handbook/#testing_for_git_subcommand","text":"Following code checks if there is a git subcommand $mysub : if git help -a | grep \"^ [a-z]\" | tr ' ' '\\n' | grep -x $mysub > /dev/null > /dev/null; then That are 4 forks. The code can be replaced according to this guide: local -a lines_list lines_list=( ${(f)\"$(git help -a)\"} ) lines_list=( ${(M)${(s: :)${(M)lines_list:# [a-z]*}}:#$mysub} ) if (( ${#lines_list} > 0 )); then The result is just 1 fork.","title":"Testing for Git subcommand"},{"location":"zsh-native-scripting-handbook/#counting_unquoted-only_apostrophes","text":"A project was needing this to do some Zle line-continuation tricks (when you put a backslash-\\ at the end of the line and press enter \u2013 it is the line-continuation that occurs at that moment). The required functionality is: in given string, count the number of apostrophes, but only the unquoted ones . This means that only apostrophes with null or an even number of preceding backslashes should be accepted into the count: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" integer count=0 : ${buf//(#b)((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)/$(( count += ${#match[3]} ))} echo $count \u25b6 3 The answer (i.e. the output) to the above presentation and example is: 3 (there are 3 unquoted apostrophes in total in the string kept in the variable $buf ). Below follows a variation of above snippet that doesn't use math-code execution: buf=\"word'continue\\'after\\\\\\'afterSecnd\\\\''afterPair\" buf=\"${(S)buf//(#b)*((#s)|[^\\\\])([\\\\][\\\\])#(\\'\\'#)*/${match[3]}}\"; buf=${buf%%[^\\']##} integer count=${#buf} echo $count \u25b6 3 This is possible thanks to (S) flag \u2013 non-greedy matching, ([\\\\][\\\\])# trick \u2013 it matches only unquoted following (\\'\\'##) characters (which are the apostrophes) and a general strategy to replace anything-apostrope(s) (unquoted ones) with the-apostrope(s) (and then count them with ${#buf} ).","title":"Counting unquoted-only apostrophes"},{"location":"zsh-native-scripting-handbook/#tips_and_tricks","text":"","title":"Tips and Tricks"},{"location":"zsh-native-scripting-handbook/#parsing_ini_file","text":"With Zshell's extended_glob parsing an ini file is an easy task. It will not result in a nested-arrays data structure (Zsh doesn't support nested hashes), but the hash keys like $DB_CONF[db1_<connection>_host] are actually really intuitive. The code should be placed in file named read-ini-file , in $fpath , and autoload read-ini-file should be invoked. # Copyright (c) 2018 Sebastian Gniazdowski # # $1 - path to the ini file to parse # $2 - name of output hash # $3 - prefix for keys in the hash # # Writes to given hash under keys built in following way: ${3}<section>_field. # Values are values from ini file. Example invocation: # # read-ini-file ./database1-setup.ini DB_CONF db1_ # read-ini-file ./database2-setup.ini DB_CONF db2_ # setopt localoptions extendedglob local __ini_file=\"$1\" __out_hash=\"$2\" __key_prefix=\"$3\" local IFS='' __line __cur_section=\"void\" __access_string local -a match mbegin mend [[ ! -r \"$__ini_file\" ]] && { builtin print -r \"read-ini-file: an ini file is unreadable ($__ini_file)\"; return 1; } while read -r -t 1 __line; do if [[ \"$__line\" = [[:blank:]]#\\;* ]]; then continue # Match \"[Section]\" line elif [[ \"$__line\" = (#b)[[:blank:]]#\\[([^\\]]##)\\][[:blank:]]# ]]; then __cur_section=\"${match[1]}\" # Match \"string = string\" line elif [[ \"$__line\" = (#b)[[:blank:]]#([^[:blank:]=]##)[[:blank:]]#[=][[:blank:]]#(*) ]]; then match[2]=\"${match[2]%\"${match[2]##*[! $'\\t']}\"}\" # severe trick - remove trailing whitespace __access_string=\"${__out_hash}[${__key_prefix}<$__cur_section>_${match[1]}]\" : \"${(P)__access_string::=${match[2]}}\" fi done < \"$__ini_file\" return 0","title":"Parsing INI file"},{"location":"zsh-plugin-standard/","text":"Version: 1.0, 11/22/2019 Zsh Plugin Standard # This document defines the Zsh Plugin Standard. Zinit fully supports this standard. This document is also available as a PDF . What Is A Zsh Plugin? # Historically, Zsh plugins were first defined by Oh My Zsh. They provide for a way to package together files that extend or configure the shell\u2019s functionality in a particular way. At a simple level, a plugin: Has its directory added to $fpath ( Zsh documentation ). This is being done either by a plugin manager or by the plugin itself (see 5 th section for more information). Has its first *.plugin.zsh file sourced (or *.zsh , init.zsh , *.sh , these are non-standard). The first point allows plugins to provide completions and functions that are loaded via Zsh\u2019s autoload mechanism (a single function per-file). From a more broad perspective, a plugin consists of: A directory containing various files (main script, autoload functions, completions, Makefiles, backend programs, documentation). A sourcable script that obtains the path to its directory via $0 (see the next section for a related enhancement proposal). A Github (or other site) repository identified by two components username / pluginname . A software package containing any type of command line artifacts \u2013 when used with advanced plugin managers that have hooks, can run Makefiles, add directories to $PATH . Below follow proposed enhancements and codifications of the definition of a \"Zsh plugin\" and the actions of plugin managers \u2013 the proposed standardization. They cover the information of how to write a Zsh plugin. 1. Standardized \\$0 Handling # To get the plugin\u2019s location, plugins should do: 0=\"${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}\" 0=\"${${(M)0:#/*}:-$PWD/$0}\" # Then ${0:h} to get plugin\u2019s directory The one-line code above will: Be backwards-compatible with normal $0 setting and usage. Use ZERO if it\u2019s not empty, the plugin manager will be easily able to alter effective $0 before loading a plugin, this allows for e.g. eval \"$(<plugin)\" , which can be faster than source ( comparison , note that it\u2019s not for a compiled script). Use $0 if it doesn\u2019t contain the path to the Zsh binary, plugin manager will still be able to set $0 , although more difficultly (requires unsetopt function_argzero before sourcing plugin script, and 0=\u2026\u200b assignment), unsetopt function_argzero will be detected (it causes $0 not to contain plugin-script path, but path to Zsh binary, if not overwritten by a 0=\u2026\u200b assignment), setopt posix_argzero will be detected (as above). Use %N prompt expansion flag, which always gives absolute path to script, plugin manager cannot alter this (no advanced loading of plugin is possible), but simple plugin-file sourcing (without a plugin manager) will be saved from breaking caused by the mentioned *_argzero options, so this is a very good last-resort fallback. Finally, in the second line, it will ensure that $0 contains an absolute path by prepending it with $PWD if necessary. The goal is flexibility, with essential motivation to support eval \"$(<plugin)\" and definitely solve setopt no_function_argzero and setopt posix_argzero cases. A plugin manager will be even able to convert a plugin to a function (author implemented such proof of concept functionality, it\u2019s fully possible \u2013 also in an automatic fashion), but performance differences of this are yet unclear. It might however provide a use case. The last, 5 th point also allows to use the $0 handling in scripts (i.e. runnables with the hashbang #!\u2026 ) to get the directory in which the script file resides. The assignment uses quoting to make it resilient to combination of GLOB_SUBST and GLOB_ASSIGN options. It's a standard snippet of code, so it has to be always working. When you'll set e.g.: the zsh emulation in a function, you in general don't have to quote assignments. Adoption Status # Plugin managers: Zinit, Zgen (after and if the PR will be merged) Plugins: GitHub search 2. Unload Function # If a plugin is named e.g. kalc (and is available via an-user/kalc plugin-ID), then it can provide a function, kalc_plugin_unload , that can be called by a plugin manager to undo the effects of loading that plugin. A plugin manager can implement its own tracking of changes made by a plugin so this is in general optional. However, to properly unload e.g. a prompt, dedicated tracking (easy to do for the plugin creator) can provide better, predictable results. Any special, uncommon effects of loading a plugin are possible to undo only by a dedicated function. However, an interesting compromise approach is available \u2013 to withdraw only the special effects of loading a plugin via the dedicated, plugin-provided function and leave the rest to the plugin manager. The value of such approach is that maintaining of such function (if it is to withdraw all plugin side-effects) can be a daunting task requiring constant monitoring of it during the plugin develoment process. Adoption Status # One plugin manager, Zinit, implements plugin unloading and calls the function. One plugin, romkatv/powerlevel10k , is Two plugins: romkatv/powerlevel10k , is using the function to execute a specific task: shutdown of the binary, background gitstatus demon, with a very good results, agkozak/agkozak-zsh-prompt , is using the function for the full unload of the theme. 3. @zsh-plugin-run-on-unload Call # The plugin manager can provide a function @zsh-plugin-run-on-unload which has the following call syntax: @zsh-plugin-run-on-unload \"{code-snippet-1}\" \"{code-snippet-2}\" \u2026 The function registers pieces of code to be run by the plugin manager on unload of the plugin . The execution of the code should be done by the eval builtin in the same order as they are passed to the call. The code should be executed in the plugin's directory, in the current shell. The mechanism thus provides another way, side to the unload function , for the plugin to participate in the process of unloading it. Adoption Status # It's a recent addition to the standard and only one plugin manager, Zinit, implements it. 4. @zsh-plugin-run-on-update Call # The plugin manager can provide a function @zsh-plugin-run-on-update which has the following call syntax: @zsh-plugin-run-on-update \"{code-snippet-1}\" \"{code-snippet-2}\" \u2026 The function registers pieces of code to be run by the plugin manager on update of the plugin . The execution of the code should be done by the eval builtin in the same order as they are passed to the call. The code should be executed in the plugin's directory, possibly in a subshell. Adoption Status # It's a recent addition to the standard and only one plugin manager, Zinit, implements it. 5. Plugin Manager Activity Indicator # Plugin managers should set the $zsh_loaded_plugins array to contain all previously loaded plugins and the plugin currently being loaded (as the last element). This will allow any plugin to: Check which plugins are already loaded. Check if it is being loaded by a plugin manager (i.e. not just sourced). The first item allows a plugin to e.g. issue a notice about missing dependencies. Instead of issuing a notice, it may be able to satisfy the dependencies from resources it provides. For example, pure prompt provides zsh-async dependency library within its source tree, which is normally a separate project. Consequently, the prompt can decide to source its private copy of zsh-async , having also reliable $0 defined by previous section (note: pure doesn\u2019t normally do this). The second item allows a plugin to e.g. set up $fpath , knowing that plugin manager will not handle this: if [[ ${zsh_loaded_plugins[-1]} != */kalc && -z ${fpath[(r)${0:h}]} ]] then fpath+=( \"${0:h}\" ) fi This will allow user to reliably source the plugin without using a plugin manager. The code uses the wrapping braces around variables (i.e.: e.g.: ${fpath\u2026} ) to make it compatible with the KSH_ARRAYS option and the quoting around ${0:h} to make it compatible with the SH_WORD_SPLIT option. Adoption Status # Plugin managers: Zinit, Zgen (after and if the PR will be merged) Plugins: GitHub search 5. Global Parameter With PREFIX For Make, Configure, Etc. # Plugin managers may export the parameter $ZPFX which should contain a path to a directory dedicated for user-land software, i.e. for directories $ZPFX/bin , $ZPFX/lib , $ZPFX/share , etc. Suggested name of the directory is polaris , Zinit uses this name and places this directory at ~/.zinit/polaris by default. User can then configure hooks (feature of e.g. zplug and Zinit) to invoke e.g. make PREFIX=$ZPFX install at clone & update of the plugin to install software like e.g. tj/git-extras . This is a developing role of Zsh plugin managers as package managers, where .zshrc has a similar role to Chef or Puppet configuration and allows to declare system state, and have the same state on different accounts / machines. No-narration facts-list related to $ZPFX : export ZPFX=\"$HOME/polaris\" (or e.g. $HOME/.zinit/polaris ) make PREFIX=$ZPFX install ./configure --prefix=$ZPFX cmake -DCMAKE_INSTALL_PREFIX=$ZPFX . zinit ice make\"PREFIX=$ZPFX install\" zplug \u2026 hook-build:\"make PREFIX=$PFX install\" Adoption Status # One plugin manager, Zinit, provides the $ZPFX parameter. Zsh Plugin-Programming Best Practices # The document is to define a Zsh-plugin but also to serve as an information source for plugin creators. Therefore, it covers also a best practices information in this section. Use Of add-zsh-hook To Install Hooks # Zsh ships with a function add-zsh-hook . It has the following invocation syntax: add-zsh-hook [ -L | -dD ] [ -Uzk ] hook function The command installs a function as one of the supported zsh hook entries. which are one of: chpwd , periodic , precmd , preexec , zshaddhistory , zshexit , zsh_directory_name . For their meaning refer to the Zsh documentation . Use Of add-zle-hook-widget To Install Zle Hooks # Zle editor is the part of the Zsh that is responsible for receiving the text from the user. It can be said that it\u2019s based on widgets, which are nothing more than Zsh functions that are allowed to be ran in Zle context, i.e. from the Zle editor (plus a few minor differences, like e.g.: the $WIDGET parameter that\u2019s automatically set by the Zle editor). The syntax of the call is: add-zle-hook-widget [ -L | -dD ] [ -Uzk ] hook widgetname The call resembles the syntax of the add-zsh-hook function. The only difference is that it takes a widgetname , not a function name, and that the hook is being one of: isearch-exit , isearch-update , line-pre-redraw , line-init , line-finish , history-line-set , or keymap-select . Their meaning is explained in the Zsh documentation . The use of this function is recommended because it allows to install multiple hooks per each hook entry. Before introducing the add-zle-hook-widget function the \"normal\" way to install a hook was to define widget with the name of one of the special widgets. Now, after the function has been introduced in Zsh 5.3 it should be used instead. Standard Recommended Options # The following code snippet is recommended to be included at the beginning of each of the main functions provided by the plugin: emulate -L zsh setopt extended_glob warn_create_global typeset_silent \\ no_short_loops rc_quotes no_auto_pushd It resets all the options to their default state according to the zsh emulation mode, with use of the local_options option \u2013 so the options will be restored to their previous state when leaving the function. It then alters the emulation by 6 different options: extended_glob \u2013 enables one of the main Zshell features \u2013 the advanced, built-in regex-like globing mechanism, warn_create_global \u2013 enables warnings to be printed each time a (global) variable is defined without being explicitly defined by a typeset , local , declare , etc. call; it allows to catch typos and missing localizations of the variables and thus prevents from writing a bad code, typeset_silent \u2013 it allows to call typeset , local , etc. multiple times on the same variable; without it the second call causes the variable contents to be printed first; using this option allows to declare variables inside loops, near the place of their use, which sometimes helps to write a more readable code, no_short_loops \u2013 disables the short-loops syntax; this is done because when the syntax is enabled it limits the parser's ability to detect errors (see this zsh-workers post for the details), rc_quotes \u2013 adds useful ability to insert apostrophes into an apostrophe-quoted string, by use of '' inside it, e.g.: 'a string''s example' will yield the string a string's example , no_auto_pushd - disables the automatic push of the directory passed to cd builtin onto the directory stack; this is useful, because otherwise the internal directory changes done by the plugin will pollute the global directory stack. Standard Recommended Variables # It's good to localize the following variables at the entry of the main function of a plugin: local MATCH REPLY integer MBEGIN MEND local -a match mbegin mend reply The variables starting with m and M are being used by the substitutions utilizing (#b) and (#m) flags, respectively. They should not leak to the global scope. Also, their automatic creation would trigger the warning from the warn_create_global option. The reply and REPLY parameters are being normally used to return an array or a scalar from a function, respectively \u2013 it's the standard way of passing values from functions. Their use is naturally limited to the functions called from the main function of a plugin \u2013 they should not be used to pass data around e.g.: in between prompts, thus it's natural to localize them in the main function. Standard Function Name-Space Prefixes # The recommendation is purely subjective opinion of the author. It can evolve \u2013 if you have any remarks, don't hesitate to fill them . The Problems Solved By The Proposition # However when adopted, the proposition will solve the following issues: Using the underscore _ to namespace functions \u2013 this isn't the right thing to do because the prefix is being already used by the completion functions, so the namespace is already filled up greatly and the plugin functions get lost in it. Not using a prefix at all \u2013 this is also an unwanted practice as it pollutes the command namespace ( an example of such issue appearing). It would allow to quickly discriminate between function types \u2013 e.g.: seeing the : prefix informs the user that it's a hook-type function, while seeing the @ prefix informs the user that it's an API-like function, etc. It also provides an improvement during programming, by allowing to quickly limit the number of completions offered by the editor, e.g.: for Vim's Ctrl-P completing, when entering +<Ctrl-P> , then only a subset of the functions is being completed (see below for the type of the functions). Note: the editor has to be configured so that it accepts such special characters as part of keywords, for Vim it's: :set isk+=@-@,.,+,/,: for all of the proposed prefixes. The Proposed Function-Name Prefixes # The proposition of the standard prefixes is as follows: . : for regular private functions. Example function: .prompt_zinc_get_value . : : for hook-like functions, so it should be used e.g.: for the Zsh hooks and the Zle hooks , but also for any other custom hook-like mechanism in the plugin (e.g.: Zinit annexes use such prefix for the Zinit hook functions). Example function name: :prompt_zinc_precmd . + : for output functions, i.e.: for functions that print to the standard output and error or to a log, etc. Example function name: +prompt_zinc_output_segment . / : for debug functions, i.e: for functions that output debug messages to the screen or to a log or e.g.: gather some debug data. Note: the slash makes it impossible for such functions to be auto-loaded via the autoload mechanism. It is somewhat risky to assume, that this will never be needed for the functions, however the limited number of available ASCII characters justifies such allocation. Example function name: /prompt_zinc_dmsg . @ : for API-like functions, i.e: for functions that are on a boundary to a subsystem and expose its functionality through a well-defined, in general fixed interface. For example this plugin standard defines the function @zsh-plugin-run-on-update , which is exposing a plugin manager's functionality in a well-defined way. Example Code Utilizing The Prefixes # .zinc_register_hooks() { add-zsh-hook precmd :zinc_precmd /zinc_dmsg \"Installed precmd hook with result: $?\" @zsh-plugin-run-on-unload \"add-zsh-hook -d precmd :zinc_precmd\" +zinc_print \"Zinc initialization complete\" } Preventing Function Pollution # When writing a larger autoload function, it very often is the case that the function contains definitions of other functions. When the main function finishes executing, the functions are being left defined. This might be undesired, e.g.: because of the command name-space pollution. The following snippet of code, when added at the beginning of the main function will automatically unset the sub-functions when leaving the main function: # Don't leak any functions typeset -g prjef prjef=( ${(k)functions} ) trap \"unset -f -- \\\"\\${(k)functions[@]:|prjef}\\\" &>/dev/null; unset prjef\" EXIT trap \"unset -f -- \\\"\\${(k)functions[@]:|prjef}\\\" &>/dev/null; unset prjef; return 1\" INT Replace the prj* prefix with your project name, e.g.: rustef for a rust -related plugin. The *ef stands for \"entry functions\". The snippet works as follows: The line prjef=( ${(k)functions} ) remembers all the functions that are currently defined \u2013 which means that the list excludes the functions that are to be yet defined by the body of the main function. The code unset -f -- \"${(k)functions[@]:|prjef}\" first does an subtraction of array contents \u2013 the :| substitution operator \u2013 of the functions that are defined at the moment of leaving of the function (the trap -s invoke the code in this moment) with the list of functions from the start of the main function \u2013 the ones stored in the variables $prjef . It then unsets the resulting list of the functions \u2013 being only the newly defined functions in the main function \u2013 by passing it to unset -f \u2026 . This way the functions defined by the body of the main (most often an autoload) function will be only set during the execution of the function. Preventing Parameter Pollution # When writing a plugin one often needs to keep a state during the Zsh session. To do this it is natural to use global parameters. However, when the number of the parameters grows one might want to limit it. With the following method, only a single global parameter per plugin can be sufficient: typeset -A PLGMAP typeset -A some_map typeset -a some_array # Use PLGMAP[state]=1 some_map[state]=1 some_array[1]=state can be converted into: typeset -A PLGMAP # Use PLGMAP[state]=1 PLGMAP[some_map__state]=1 PLGMAP[some_array__1]=state The use of this method is very unproblematic. The author reduced the number of global parameters in one of projects by 21 by using an automatic conversion with Vim substitution patterns with back references without any problems. Appendix A: Revision History (History Of Updates To The Document) # v1.0, 11/22/2019: Removed quoting from the $0 assignments v0.99, 10/26/2019: Added Adoption Status sub-sections v0.98, 10/25/2019: 1/ Added Standard Recommended Variables section v0.98, 10/25/2019: 2/ Added Standard Function Name-Space Prefixes section v0.98, 10/25/2019: 3/ Added Preventing Function Pollution section v0.98, 10/25/2019: 4/ Added Preventing Parameter Pollution section v0.97, 10/23/2019: Added Standard Recommended Options section v0.96, 10/23/2019: Added @zsh-plugin-run-on-unload and @zsh-plugin-run-on-update calls v0.95, 07/31/2019: Plugin unload function *_unload_plugin \u2192 *_plugin_unload v0.94, 07/20/2019: Add initial version of the best practices section v0.93, 07/20/2019: 1/ Add the second line to the $0 handling. v0.93, 07/20/2019: 2/ Reformat to 80 columns v0.92, 07/14/2019: 1/ Rename LOADED_PLUGINS to zsh_loaded_plugins. v0.92, 07/14/2019: 2/ Suggest that \\$ZPFX is optional. v0.91, 06/02/2018: Fix the link to the PDF for Github. v0.9, 12/12/2017: Remove ZERO references (wrong design), add TOC. Reminder: The date format that uses slashes is MM/DD/YYYY .","title":"Zsh Plugin Standard"},{"location":"zsh-plugin-standard/#zsh_plugin_standard","text":"This document defines the Zsh Plugin Standard. Zinit fully supports this standard. This document is also available as a PDF .","title":"Zsh Plugin Standard"},{"location":"zsh-plugin-standard/#what_is_a_zsh_plugin","text":"Historically, Zsh plugins were first defined by Oh My Zsh. They provide for a way to package together files that extend or configure the shell\u2019s functionality in a particular way. At a simple level, a plugin: Has its directory added to $fpath ( Zsh documentation ). This is being done either by a plugin manager or by the plugin itself (see 5 th section for more information). Has its first *.plugin.zsh file sourced (or *.zsh , init.zsh , *.sh , these are non-standard). The first point allows plugins to provide completions and functions that are loaded via Zsh\u2019s autoload mechanism (a single function per-file). From a more broad perspective, a plugin consists of: A directory containing various files (main script, autoload functions, completions, Makefiles, backend programs, documentation). A sourcable script that obtains the path to its directory via $0 (see the next section for a related enhancement proposal). A Github (or other site) repository identified by two components username / pluginname . A software package containing any type of command line artifacts \u2013 when used with advanced plugin managers that have hooks, can run Makefiles, add directories to $PATH . Below follow proposed enhancements and codifications of the definition of a \"Zsh plugin\" and the actions of plugin managers \u2013 the proposed standardization. They cover the information of how to write a Zsh plugin.","title":"What Is A Zsh Plugin?"},{"location":"zsh-plugin-standard/#1_standardized_0_handling","text":"To get the plugin\u2019s location, plugins should do: 0=\"${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}\" 0=\"${${(M)0:#/*}:-$PWD/$0}\" # Then ${0:h} to get plugin\u2019s directory The one-line code above will: Be backwards-compatible with normal $0 setting and usage. Use ZERO if it\u2019s not empty, the plugin manager will be easily able to alter effective $0 before loading a plugin, this allows for e.g. eval \"$(<plugin)\" , which can be faster than source ( comparison , note that it\u2019s not for a compiled script). Use $0 if it doesn\u2019t contain the path to the Zsh binary, plugin manager will still be able to set $0 , although more difficultly (requires unsetopt function_argzero before sourcing plugin script, and 0=\u2026\u200b assignment), unsetopt function_argzero will be detected (it causes $0 not to contain plugin-script path, but path to Zsh binary, if not overwritten by a 0=\u2026\u200b assignment), setopt posix_argzero will be detected (as above). Use %N prompt expansion flag, which always gives absolute path to script, plugin manager cannot alter this (no advanced loading of plugin is possible), but simple plugin-file sourcing (without a plugin manager) will be saved from breaking caused by the mentioned *_argzero options, so this is a very good last-resort fallback. Finally, in the second line, it will ensure that $0 contains an absolute path by prepending it with $PWD if necessary. The goal is flexibility, with essential motivation to support eval \"$(<plugin)\" and definitely solve setopt no_function_argzero and setopt posix_argzero cases. A plugin manager will be even able to convert a plugin to a function (author implemented such proof of concept functionality, it\u2019s fully possible \u2013 also in an automatic fashion), but performance differences of this are yet unclear. It might however provide a use case. The last, 5 th point also allows to use the $0 handling in scripts (i.e. runnables with the hashbang #!\u2026 ) to get the directory in which the script file resides. The assignment uses quoting to make it resilient to combination of GLOB_SUBST and GLOB_ASSIGN options. It's a standard snippet of code, so it has to be always working. When you'll set e.g.: the zsh emulation in a function, you in general don't have to quote assignments.","title":"1. Standardized \\$0 Handling"},{"location":"zsh-plugin-standard/#adoption_status","text":"Plugin managers: Zinit, Zgen (after and if the PR will be merged) Plugins: GitHub search","title":"Adoption Status"},{"location":"zsh-plugin-standard/#2_unload_function","text":"If a plugin is named e.g. kalc (and is available via an-user/kalc plugin-ID), then it can provide a function, kalc_plugin_unload , that can be called by a plugin manager to undo the effects of loading that plugin. A plugin manager can implement its own tracking of changes made by a plugin so this is in general optional. However, to properly unload e.g. a prompt, dedicated tracking (easy to do for the plugin creator) can provide better, predictable results. Any special, uncommon effects of loading a plugin are possible to undo only by a dedicated function. However, an interesting compromise approach is available \u2013 to withdraw only the special effects of loading a plugin via the dedicated, plugin-provided function and leave the rest to the plugin manager. The value of such approach is that maintaining of such function (if it is to withdraw all plugin side-effects) can be a daunting task requiring constant monitoring of it during the plugin develoment process.","title":"2. Unload Function"},{"location":"zsh-plugin-standard/#adoption_status_1","text":"One plugin manager, Zinit, implements plugin unloading and calls the function. One plugin, romkatv/powerlevel10k , is Two plugins: romkatv/powerlevel10k , is using the function to execute a specific task: shutdown of the binary, background gitstatus demon, with a very good results, agkozak/agkozak-zsh-prompt , is using the function for the full unload of the theme.","title":"Adoption Status"},{"location":"zsh-plugin-standard/#3_zsh-plugin-run-on-unload_call","text":"The plugin manager can provide a function @zsh-plugin-run-on-unload which has the following call syntax: @zsh-plugin-run-on-unload \"{code-snippet-1}\" \"{code-snippet-2}\" \u2026 The function registers pieces of code to be run by the plugin manager on unload of the plugin . The execution of the code should be done by the eval builtin in the same order as they are passed to the call. The code should be executed in the plugin's directory, in the current shell. The mechanism thus provides another way, side to the unload function , for the plugin to participate in the process of unloading it.","title":"3. @zsh-plugin-run-on-unload Call"},{"location":"zsh-plugin-standard/#adoption_status_2","text":"It's a recent addition to the standard and only one plugin manager, Zinit, implements it.","title":"Adoption Status"},{"location":"zsh-plugin-standard/#4_zsh-plugin-run-on-update_call","text":"The plugin manager can provide a function @zsh-plugin-run-on-update which has the following call syntax: @zsh-plugin-run-on-update \"{code-snippet-1}\" \"{code-snippet-2}\" \u2026 The function registers pieces of code to be run by the plugin manager on update of the plugin . The execution of the code should be done by the eval builtin in the same order as they are passed to the call. The code should be executed in the plugin's directory, possibly in a subshell.","title":"4. @zsh-plugin-run-on-update Call"},{"location":"zsh-plugin-standard/#adoption_status_3","text":"It's a recent addition to the standard and only one plugin manager, Zinit, implements it.","title":"Adoption Status"},{"location":"zsh-plugin-standard/#5_plugin_manager_activity_indicator","text":"Plugin managers should set the $zsh_loaded_plugins array to contain all previously loaded plugins and the plugin currently being loaded (as the last element). This will allow any plugin to: Check which plugins are already loaded. Check if it is being loaded by a plugin manager (i.e. not just sourced). The first item allows a plugin to e.g. issue a notice about missing dependencies. Instead of issuing a notice, it may be able to satisfy the dependencies from resources it provides. For example, pure prompt provides zsh-async dependency library within its source tree, which is normally a separate project. Consequently, the prompt can decide to source its private copy of zsh-async , having also reliable $0 defined by previous section (note: pure doesn\u2019t normally do this). The second item allows a plugin to e.g. set up $fpath , knowing that plugin manager will not handle this: if [[ ${zsh_loaded_plugins[-1]} != */kalc && -z ${fpath[(r)${0:h}]} ]] then fpath+=( \"${0:h}\" ) fi This will allow user to reliably source the plugin without using a plugin manager. The code uses the wrapping braces around variables (i.e.: e.g.: ${fpath\u2026} ) to make it compatible with the KSH_ARRAYS option and the quoting around ${0:h} to make it compatible with the SH_WORD_SPLIT option.","title":"5. Plugin Manager Activity Indicator"},{"location":"zsh-plugin-standard/#adoption_status_4","text":"Plugin managers: Zinit, Zgen (after and if the PR will be merged) Plugins: GitHub search","title":"Adoption Status"},{"location":"zsh-plugin-standard/#5_global_parameter_with_prefix_for_make_configure_etc","text":"Plugin managers may export the parameter $ZPFX which should contain a path to a directory dedicated for user-land software, i.e. for directories $ZPFX/bin , $ZPFX/lib , $ZPFX/share , etc. Suggested name of the directory is polaris , Zinit uses this name and places this directory at ~/.zinit/polaris by default. User can then configure hooks (feature of e.g. zplug and Zinit) to invoke e.g. make PREFIX=$ZPFX install at clone & update of the plugin to install software like e.g. tj/git-extras . This is a developing role of Zsh plugin managers as package managers, where .zshrc has a similar role to Chef or Puppet configuration and allows to declare system state, and have the same state on different accounts / machines. No-narration facts-list related to $ZPFX : export ZPFX=\"$HOME/polaris\" (or e.g. $HOME/.zinit/polaris ) make PREFIX=$ZPFX install ./configure --prefix=$ZPFX cmake -DCMAKE_INSTALL_PREFIX=$ZPFX . zinit ice make\"PREFIX=$ZPFX install\" zplug \u2026 hook-build:\"make PREFIX=$PFX install\"","title":"5. Global Parameter With PREFIX For Make, Configure, Etc."},{"location":"zsh-plugin-standard/#adoption_status_5","text":"One plugin manager, Zinit, provides the $ZPFX parameter.","title":"Adoption Status"},{"location":"zsh-plugin-standard/#zsh_plugin-programming_best_practices","text":"The document is to define a Zsh-plugin but also to serve as an information source for plugin creators. Therefore, it covers also a best practices information in this section.","title":"Zsh Plugin-Programming Best Practices"},{"location":"zsh-plugin-standard/#use_of_add-zsh-hook_to_install_hooks","text":"Zsh ships with a function add-zsh-hook . It has the following invocation syntax: add-zsh-hook [ -L | -dD ] [ -Uzk ] hook function The command installs a function as one of the supported zsh hook entries. which are one of: chpwd , periodic , precmd , preexec , zshaddhistory , zshexit , zsh_directory_name . For their meaning refer to the Zsh documentation .","title":"Use Of add-zsh-hook To Install Hooks"},{"location":"zsh-plugin-standard/#use_of_add-zle-hook-widget_to_install_zle_hooks","text":"Zle editor is the part of the Zsh that is responsible for receiving the text from the user. It can be said that it\u2019s based on widgets, which are nothing more than Zsh functions that are allowed to be ran in Zle context, i.e. from the Zle editor (plus a few minor differences, like e.g.: the $WIDGET parameter that\u2019s automatically set by the Zle editor). The syntax of the call is: add-zle-hook-widget [ -L | -dD ] [ -Uzk ] hook widgetname The call resembles the syntax of the add-zsh-hook function. The only difference is that it takes a widgetname , not a function name, and that the hook is being one of: isearch-exit , isearch-update , line-pre-redraw , line-init , line-finish , history-line-set , or keymap-select . Their meaning is explained in the Zsh documentation . The use of this function is recommended because it allows to install multiple hooks per each hook entry. Before introducing the add-zle-hook-widget function the \"normal\" way to install a hook was to define widget with the name of one of the special widgets. Now, after the function has been introduced in Zsh 5.3 it should be used instead.","title":"Use Of add-zle-hook-widget To Install Zle Hooks"},{"location":"zsh-plugin-standard/#standard_recommended_options","text":"The following code snippet is recommended to be included at the beginning of each of the main functions provided by the plugin: emulate -L zsh setopt extended_glob warn_create_global typeset_silent \\ no_short_loops rc_quotes no_auto_pushd It resets all the options to their default state according to the zsh emulation mode, with use of the local_options option \u2013 so the options will be restored to their previous state when leaving the function. It then alters the emulation by 6 different options: extended_glob \u2013 enables one of the main Zshell features \u2013 the advanced, built-in regex-like globing mechanism, warn_create_global \u2013 enables warnings to be printed each time a (global) variable is defined without being explicitly defined by a typeset , local , declare , etc. call; it allows to catch typos and missing localizations of the variables and thus prevents from writing a bad code, typeset_silent \u2013 it allows to call typeset , local , etc. multiple times on the same variable; without it the second call causes the variable contents to be printed first; using this option allows to declare variables inside loops, near the place of their use, which sometimes helps to write a more readable code, no_short_loops \u2013 disables the short-loops syntax; this is done because when the syntax is enabled it limits the parser's ability to detect errors (see this zsh-workers post for the details), rc_quotes \u2013 adds useful ability to insert apostrophes into an apostrophe-quoted string, by use of '' inside it, e.g.: 'a string''s example' will yield the string a string's example , no_auto_pushd - disables the automatic push of the directory passed to cd builtin onto the directory stack; this is useful, because otherwise the internal directory changes done by the plugin will pollute the global directory stack.","title":"Standard Recommended Options"},{"location":"zsh-plugin-standard/#standard_recommended_variables","text":"It's good to localize the following variables at the entry of the main function of a plugin: local MATCH REPLY integer MBEGIN MEND local -a match mbegin mend reply The variables starting with m and M are being used by the substitutions utilizing (#b) and (#m) flags, respectively. They should not leak to the global scope. Also, their automatic creation would trigger the warning from the warn_create_global option. The reply and REPLY parameters are being normally used to return an array or a scalar from a function, respectively \u2013 it's the standard way of passing values from functions. Their use is naturally limited to the functions called from the main function of a plugin \u2013 they should not be used to pass data around e.g.: in between prompts, thus it's natural to localize them in the main function.","title":"Standard Recommended Variables"},{"location":"zsh-plugin-standard/#standard_function_name-space_prefixes","text":"The recommendation is purely subjective opinion of the author. It can evolve \u2013 if you have any remarks, don't hesitate to fill them .","title":"Standard Function Name-Space Prefixes"},{"location":"zsh-plugin-standard/#the_problems_solved_by_the_proposition","text":"However when adopted, the proposition will solve the following issues: Using the underscore _ to namespace functions \u2013 this isn't the right thing to do because the prefix is being already used by the completion functions, so the namespace is already filled up greatly and the plugin functions get lost in it. Not using a prefix at all \u2013 this is also an unwanted practice as it pollutes the command namespace ( an example of such issue appearing). It would allow to quickly discriminate between function types \u2013 e.g.: seeing the : prefix informs the user that it's a hook-type function, while seeing the @ prefix informs the user that it's an API-like function, etc. It also provides an improvement during programming, by allowing to quickly limit the number of completions offered by the editor, e.g.: for Vim's Ctrl-P completing, when entering +<Ctrl-P> , then only a subset of the functions is being completed (see below for the type of the functions). Note: the editor has to be configured so that it accepts such special characters as part of keywords, for Vim it's: :set isk+=@-@,.,+,/,: for all of the proposed prefixes.","title":"The Problems Solved By The Proposition"},{"location":"zsh-plugin-standard/#the_proposed_function-name_prefixes","text":"The proposition of the standard prefixes is as follows: . : for regular private functions. Example function: .prompt_zinc_get_value . : : for hook-like functions, so it should be used e.g.: for the Zsh hooks and the Zle hooks , but also for any other custom hook-like mechanism in the plugin (e.g.: Zinit annexes use such prefix for the Zinit hook functions). Example function name: :prompt_zinc_precmd . + : for output functions, i.e.: for functions that print to the standard output and error or to a log, etc. Example function name: +prompt_zinc_output_segment . / : for debug functions, i.e: for functions that output debug messages to the screen or to a log or e.g.: gather some debug data. Note: the slash makes it impossible for such functions to be auto-loaded via the autoload mechanism. It is somewhat risky to assume, that this will never be needed for the functions, however the limited number of available ASCII characters justifies such allocation. Example function name: /prompt_zinc_dmsg . @ : for API-like functions, i.e: for functions that are on a boundary to a subsystem and expose its functionality through a well-defined, in general fixed interface. For example this plugin standard defines the function @zsh-plugin-run-on-update , which is exposing a plugin manager's functionality in a well-defined way.","title":"The Proposed Function-Name Prefixes"},{"location":"zsh-plugin-standard/#example_code_utilizing_the_prefixes","text":".zinc_register_hooks() { add-zsh-hook precmd :zinc_precmd /zinc_dmsg \"Installed precmd hook with result: $?\" @zsh-plugin-run-on-unload \"add-zsh-hook -d precmd :zinc_precmd\" +zinc_print \"Zinc initialization complete\" }","title":"Example Code Utilizing The Prefixes"},{"location":"zsh-plugin-standard/#preventing_function_pollution","text":"When writing a larger autoload function, it very often is the case that the function contains definitions of other functions. When the main function finishes executing, the functions are being left defined. This might be undesired, e.g.: because of the command name-space pollution. The following snippet of code, when added at the beginning of the main function will automatically unset the sub-functions when leaving the main function: # Don't leak any functions typeset -g prjef prjef=( ${(k)functions} ) trap \"unset -f -- \\\"\\${(k)functions[@]:|prjef}\\\" &>/dev/null; unset prjef\" EXIT trap \"unset -f -- \\\"\\${(k)functions[@]:|prjef}\\\" &>/dev/null; unset prjef; return 1\" INT Replace the prj* prefix with your project name, e.g.: rustef for a rust -related plugin. The *ef stands for \"entry functions\". The snippet works as follows: The line prjef=( ${(k)functions} ) remembers all the functions that are currently defined \u2013 which means that the list excludes the functions that are to be yet defined by the body of the main function. The code unset -f -- \"${(k)functions[@]:|prjef}\" first does an subtraction of array contents \u2013 the :| substitution operator \u2013 of the functions that are defined at the moment of leaving of the function (the trap -s invoke the code in this moment) with the list of functions from the start of the main function \u2013 the ones stored in the variables $prjef . It then unsets the resulting list of the functions \u2013 being only the newly defined functions in the main function \u2013 by passing it to unset -f \u2026 . This way the functions defined by the body of the main (most often an autoload) function will be only set during the execution of the function.","title":"Preventing Function Pollution"},{"location":"zsh-plugin-standard/#preventing_parameter_pollution","text":"When writing a plugin one often needs to keep a state during the Zsh session. To do this it is natural to use global parameters. However, when the number of the parameters grows one might want to limit it. With the following method, only a single global parameter per plugin can be sufficient: typeset -A PLGMAP typeset -A some_map typeset -a some_array # Use PLGMAP[state]=1 some_map[state]=1 some_array[1]=state can be converted into: typeset -A PLGMAP # Use PLGMAP[state]=1 PLGMAP[some_map__state]=1 PLGMAP[some_array__1]=state The use of this method is very unproblematic. The author reduced the number of global parameters in one of projects by 21 by using an automatic conversion with Vim substitution patterns with back references without any problems.","title":"Preventing Parameter Pollution"},{"location":"zsh-plugin-standard/#appendix_a_revision_history_history_of_updates_to_the_document","text":"v1.0, 11/22/2019: Removed quoting from the $0 assignments v0.99, 10/26/2019: Added Adoption Status sub-sections v0.98, 10/25/2019: 1/ Added Standard Recommended Variables section v0.98, 10/25/2019: 2/ Added Standard Function Name-Space Prefixes section v0.98, 10/25/2019: 3/ Added Preventing Function Pollution section v0.98, 10/25/2019: 4/ Added Preventing Parameter Pollution section v0.97, 10/23/2019: Added Standard Recommended Options section v0.96, 10/23/2019: Added @zsh-plugin-run-on-unload and @zsh-plugin-run-on-update calls v0.95, 07/31/2019: Plugin unload function *_unload_plugin \u2192 *_plugin_unload v0.94, 07/20/2019: Add initial version of the best practices section v0.93, 07/20/2019: 1/ Add the second line to the $0 handling. v0.93, 07/20/2019: 2/ Reformat to 80 columns v0.92, 07/14/2019: 1/ Rename LOADED_PLUGINS to zsh_loaded_plugins. v0.92, 07/14/2019: 2/ Suggest that \\$ZPFX is optional. v0.91, 06/02/2018: Fix the link to the PDF for Github. v0.9, 12/12/2017: Remove ZERO references (wrong design), add TOC. Reminder: The date format that uses slashes is MM/DD/YYYY .","title":"Appendix A: Revision History (History Of Updates To The Document)"}]}